Code package for calculating correction factors to g_ell using pre-generated
simulation maps for each single mask. This procedure assumes you are running
this code on a cluster-- it is extremely slow to do otherwise.

There is one main script that calls two functions from the xfaster.gcorr_tools
library:

1. xfaster_gcorr ---- This function calls XFaster to run or submit jobs for
   gcorr runs.
2. process_gcorr ---- A function that computes the gcorr correction from the
   ensemble of bandpowers, updates the running total, and backs up the necessary
   files from each iteration.
3. iterate_gcorr.py ---- A iteration script, that calls function 1 and 2 to get
   a new gcorr.npz file each time. This is the main script you'll run.

There is also a config file with options specific to computing gcorr.

---------------------
Gcorr run procedure:

1. Edit the gcorr config file to suit your purposes. An example is given.
   Required fields are:
   * null -- must be true for null tests and false for signal runs
   * map_tags -- comma-separated list of map tags
   * data_subset -- the globabble data_subset argument to xfaster_run,
       but without map tags. So, "full", "chunk*", etc.
   * output_root -- the parent directory where your gcorr XFaster runs will
       be written
   * nsim -- the number of simulations to use to compute gcorr
   * [xfaster_opts] -- this is where you'll put any options
       that will be directly input to xfaster_run
   * [submit_opts] -- this is where you'll put any options
       that will be directly input to xfaster_submit,
       in addition to those in [xfaster_opts]

2. Run iterate_gcorr.py once to get the full set of XFaster output files in the
   output directory.  Since we haven't computed gcorr yet, this will set
   apply_gcorr=False. Make sure to use as many OMP threads as possible since
   this is the step where the sims_xcorr file, which benefits the most from
   extra threads, is computed.  Your command should look like this:

      python iterate_gcorr.py --gcorr-config path-to-my-gcorr-config.ini

3. Run iterate_gcorr.py until convergence is reached. In practice, you will run
   the command above and wait for it to finish. If you include the `--max-iters`
   option with a non-zero value, the code will try to determine whether
   convergence has been reached and stop on its own.  Otherwise, you can look at
   the correction-to-the-correction that it both prints and plots (it should
   converge to 1s for TT, EE, BB), and if it hasn't converged, up+enter (redo)
   the same command you just did.  In much more detail, here's what the code
   does:

   1. Call run_xfaster_gcorr for the 0th sim seed while also reloading gcorr (if
      this is not the first iteration).  This does a couple things-- saves the
      new gcorr in the masks_xcorr file, so later seeds will use the right
      thing. And recompute the transfer function, which doesn't depend on the
      sim_index, so is only necessary to do once.
   2. After the transfer functions are all on disk, submit individual jobs for
      all the other seeds, just doing the bandpowers step for those.
   3. Once they're all done, run compute_gcal, which saves a correction-to-gcorr
      as gcorr_corr_<tag>.npz in the rundir.
   4. Print out the values of the correction-to-gcorr.
   5. Make a plot directory in the output directory-- look here for new plots of
      the total gcorr and the correction-to-gcorr each iteration.
   6. If not the first iteration, load up the correction-to-gcorr computed for
      this iteration. Multiply it by the total gcorr, and save that to the
      output directory as gcorr_total.
   7. Plot gcorr total and the correction to gcorr total. Save in rundir/plots,
      along with copies of the gcorr_corr and gcorr_total data.
   8. Clear out rundir bandpowers/transfer functions/logs.
   9. Exit.

4. After convergence is reached, copy the gcorr_total file from the rundir to
   the mask directory, labeling it mask_map_<tag>_gcorr.npz for signal or
   mask_map_<tag>_gcorr_null.npz for null.

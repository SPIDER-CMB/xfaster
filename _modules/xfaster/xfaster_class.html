

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>xfaster.xfaster_class &mdash; xfaster 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> xfaster
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algorithm.html">Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/XFaster_Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">xfaster</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>xfaster.xfaster_class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for xfaster.xfaster_class</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">xfaster_tools</span> <span class="k">as</span> <span class="n">xft</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parse_tools</span> <span class="k">as</span> <span class="n">pt</span>
<span class="kn">from</span> <span class="nn">configparser</span> <span class="kn">import</span> <span class="n">RawConfigParser</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XFasterConfig&quot;</span><span class="p">,</span> <span class="s2">&quot;XFaster&quot;</span><span class="p">,</span> <span class="s2">&quot;XFasterWarning&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="XFasterWarning"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterWarning">[docs]</a><span class="k">class</span> <span class="nc">XFasterWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning generated by the XFaster algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="XFasterConfig"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig">[docs]</a><span class="k">class</span> <span class="nc">XFasterConfig</span><span class="p">(</span><span class="n">RawConfigParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ConfigParser subclass for storing command line options and config.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_sec</span><span class="o">=</span><span class="s2">&quot;Uncategorized&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class that tracks command-line options for storage to disk.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        defaults : dict</span>
<span class="sd">            Dictionary of overall configuration values.</span>
<span class="sd">            Eg: locals() at beginning of function, or vars(args) from argparse</span>
<span class="sd">        default_sec : string, optional</span>
<span class="sd">            The name of the default section in the configuration file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">XFasterConfig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dict_type</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_sec</span> <span class="o">=</span> <span class="n">default_sec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="n">default_sec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>

<div class="viewcode-block" id="XFasterConfig.update"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update configuration options with a dictionary. Behaves like</span>
<span class="sd">        dict.update() for specified section but also clears options of the same</span>
<span class="sd">        name from the default section.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        options : dict</span>
<span class="sd">            The options to update</span>
<span class="sd">        section : string, optional</span>
<span class="sd">            Name of section to update. Default: self.default_sec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">section</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_sec</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_section</span><span class="p">(</span><span class="n">section</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="c1"># change kwargs to be like any other options</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_sec</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

<div class="viewcode-block" id="XFasterConfig.sort"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the items in each section of the configuration alphabetically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">section</span><span class="p">,</span> <span class="n">section_items</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">section_items</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">section_items</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">section_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">section_items</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">section_items</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">section_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFasterConfig.write"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write an .ini-format representation of the configuration state.</span>
<span class="sd">        Keys are stored alphabetically if `sort` is True.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        fp : file object</span>
<span class="sd">            If None, write to `sys.stdout`.</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort items in each section alphabetically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">sys</span>

            <span class="n">fp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">XFasterConfig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="XFaster"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster">[docs]</a><span class="k">class</span> <span class="nc">XFaster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">checkpoints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;files&quot;</span><span class="p">,</span>
        <span class="s2">&quot;masks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kernels&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sims_transfer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;shape_transfer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;transfer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sims&quot;</span><span class="p">,</span>
        <span class="s2">&quot;beams&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data&quot;</span><span class="p">,</span>
        <span class="s2">&quot;template_noise&quot;</span><span class="p">,</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bandpowers&quot;</span><span class="p">,</span>
        <span class="s2">&quot;beam_errors&quot;</span><span class="p">,</span>
        <span class="s2">&quot;likelihood&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># if starting from KEY, force rerun all steps in VALUES</span>
    <span class="n">checkpoint_tree</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;files&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">,</span> <span class="s2">&quot;sims&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">],</span>
        <span class="s2">&quot;masks&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;kernels&quot;</span><span class="p">,</span> <span class="s2">&quot;sims_transfer&quot;</span><span class="p">,</span> <span class="s2">&quot;sims&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">],</span>
        <span class="s2">&quot;kernels&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">,</span> <span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sims_transfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;shape_transfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;transfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sims&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;beams&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;template_noise&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;bandpowers&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;likelihood&quot;</span><span class="p">],</span>
        <span class="s2">&quot;beam_errors&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;likelihood&quot;</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="n">data_version</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">config</span><span class="p">,</span>
        <span class="n">lmax</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">pol</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pol_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">output_root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">output_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="s2">&quot;notice&quot;</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">checkpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">add_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ref_freq</span><span class="o">=</span><span class="mf">353.0</span><span class="p">,</span>
        <span class="n">beta_ref</span><span class="o">=</span><span class="mf">1.54</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an XFaster instance for computing binned power spectra</span>
<span class="sd">        using a set of data maps along with signal and noise simulations.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        lmax : int</span>
<span class="sd">            The maximum multipole for which spectra are computed</span>
<span class="sd">        pol : bool</span>
<span class="sd">            If True, polarized spectra are computed from the input maps</span>
<span class="sd">        pol_mask : bool</span>
<span class="sd">            If True, two independent masks are applied to every map:</span>
<span class="sd">            one for T maps and one for Q/U maps.</span>
<span class="sd">        output_root : string</span>
<span class="sd">            Path to data output directory</span>
<span class="sd">        output_tag : string</span>
<span class="sd">            Tag to use for output data.  Results are typically stored in</span>
<span class="sd">            the form ``&lt;output_root&gt;/&lt;output_tag&gt;/&lt;name&gt;_&lt;output_tag&gt;.npz``</span>
<span class="sd">        verbose : string</span>
<span class="sd">            Verbosity level to use for log messages.  Can be one of</span>
<span class="sd">            [&quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;all&quot;].</span>
<span class="sd">        debug : bool</span>
<span class="sd">            Store extra data in output files for debugging.</span>
<span class="sd">        checkpoint : string</span>
<span class="sd">            If output data from this step forward exist on disk, they are</span>
<span class="sd">            are re-computed rather than loading from file.</span>
<span class="sd">            Options are {checkpoints}.</span>
<span class="sd">        add_log : bool</span>
<span class="sd">            If True, write log output to a file instead of to STDOUT.</span>
<span class="sd">            The log will be in ``&lt;output_root&gt;/run_&lt;output_tag&gt;.log``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_log</span><span class="p">(</span>
            <span class="n">level</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="s2">&quot;run&quot;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.log&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">add_log</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="n">lmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">=</span> <span class="n">pol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="o">=</span> <span class="n">pol_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_freq</span> <span class="o">=</span> <span class="n">ref_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span> <span class="o">=</span> <span class="n">beta_ref</span>

        <span class="c1"># XXX Fix this</span>
        <span class="c1"># Priors on frequency spectral index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span> <span class="o">=</span> <span class="mf">1.0e-8</span>

        <span class="c1"># map tag configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_map_config</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="c1"># checkpointing</span>
        <span class="k">if</span> <span class="n">checkpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">checkpoint</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid checkpoint </span><span class="si">{}</span><span class="s2">, must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">checkpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">=</span> <span class="n">checkpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span> <span class="o">=</span> <span class="p">{</span><span class="n">cp</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">output_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No output root supplied, using </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_root</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output_root</span> <span class="o">=</span> <span class="n">output_root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span> <span class="o">=</span> <span class="n">output_tag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">)</span>

    <span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">checkpoints</span><span class="o">=</span><span class="n">checkpoints</span><span class="p">)</span>

<div class="viewcode-block" id="XFaster.load_map_config"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.load_map_config">[docs]</a>    <span class="k">def</span> <span class="nf">load_map_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the input map configuration file.</span>

<span class="sd">        The configuration file should be a file that is readable using</span>
<span class="sd">        ``ConfigParser``.  It must contain at least a single section called</span>
<span class="sd">        &quot;frequencies&quot;, with keys for each map tag that may be used by the</span>
<span class="sd">        algorithm.  If using the harmonic-domain foreground fitting portions of</span>
<span class="sd">        the algorith, the value of each key should be the observing frequency in</span>
<span class="sd">        GHz that is appropriate for each tag.  Otherwise, these frequencies can</span>
<span class="sd">        be any floating point value.</span>

<span class="sd">        Other optional sections include:</span>

<span class="sd">        **beam**:</span>
<span class="sd">        Beam window specifications for each of the tags in &quot;frequencies&quot;.  The</span>
<span class="sd">        &quot;beam_product&quot; key should be a path to a .npz file containing a</span>
<span class="sd">        dictionary of beam windows keyed by tag.  The &quot;beam_product_error&quot; key</span>
<span class="sd">        should be a path to a similar dictionary containing fraction beam error</span>
<span class="sd">        envelopes, also keyed by tag.  See ``get_beams`` or ``get_beam_errors``</span>
<span class="sd">        for more details.</span>

<span class="sd">        **fwhm**:</span>
<span class="sd">        If using a Gaussian beam model, this section should contain a list of</span>
<span class="sd">        FWHM in arcmin for each such tag in &quot;frequencies&quot;.  Keys missing here</span>
<span class="sd">        should be present in the beam product file.</span>

<span class="sd">        **fwhm_err**:</span>
<span class="sd">        If using a Gaussian beam model, this section should contain a list of</span>
<span class="sd">        fractional errors on the FWHM for each such tag in &quot;frequencies&quot;.  Keys</span>
<span class="sd">        missing here should be present in the beam error product file.</span>

<span class="sd">        **transfer**:</span>
<span class="sd">        If present, this section should contain each of the keys in</span>
<span class="sd">        &quot;frequencies&quot;, with the value set to &quot;true&quot; if a transfer function</span>
<span class="sd">        should be computed for the tag, and &quot;false&quot; otherwise (in which case the</span>
<span class="sd">        transfer function will be set to unity for all bins).  This option is</span>
<span class="sd">        useful for including, e.g. optimally weighted Planck maps with no</span>
<span class="sd">        transfer function in a joint analysis.  If not supplied, it is assumed</span>
<span class="sd">        that a transfer function should be computed for every tag in</span>
<span class="sd">        &quot;frequencies&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load map configuration file</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;Missing config file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">XFasterConfig</span><span class="p">()</span>
        <span class="n">cfg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># dictionary of map frequencies keyed by map tag</span>
        <span class="k">assert</span> <span class="s2">&quot;frequencies&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">,</span> <span class="s2">&quot;Missing [frequencies] section&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s2">&quot;frequencies&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;frequencies&quot;</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="n">tagset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one map tag is required&quot;</span>

        <span class="c1"># beam fwhm for each tag, if not supplied in beam_product</span>
        <span class="c1"># converted from arcmin to radians</span>
        <span class="k">if</span> <span class="s2">&quot;fwhm&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s2">&quot;fwhm&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">assert</span> <span class="n">tagset</span> <span class="o">&gt;=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">),</span> <span class="s2">&quot;Unknown tags in [fwhm]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># beam fwhm error for each tag, if not supplied in beam_error_product</span>
        <span class="k">if</span> <span class="s2">&quot;fwhm_err&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s2">&quot;fwhm_err&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;fwhm_err&quot;</span><span class="p">]}</span>
            <span class="k">assert</span> <span class="n">tagset</span> <span class="o">&gt;=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">),</span> <span class="s2">&quot;Unknown tags in [fwhm_err]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make sure beam product files exist</span>
        <span class="k">if</span> <span class="s2">&quot;beam&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;beam&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;beam_product&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Missing beam product file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_compat</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">beam_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">tagset</span> <span class="o">&gt;=</span> <span class="n">beam_set</span><span class="p">,</span> <span class="s2">&quot;Unknown tags in beam product&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;beam&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;beam_error_product&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Missing beam error product file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_compat</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">beam_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">tagset</span> <span class="o">&gt;=</span> <span class="n">beam_set</span><span class="p">,</span> <span class="s2">&quot;Unknown tags in beam error product&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make sure all tags are present in either beam products or fwhm tables</span>
        <span class="n">fwhm_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">fwhm_set</span> <span class="o">==</span> <span class="n">tagset</span><span class="p">,</span> <span class="s2">&quot;Missing tags in [fwhm] or beam product&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">):</span>
            <span class="n">fwhm_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">fwhm_set</span> <span class="o">==</span> <span class="n">tagset</span>
            <span class="p">),</span> <span class="s2">&quot;Missing tags in [fwhm_err] or beam error product&quot;</span>

        <span class="c1"># fit for the transfer function for each tag?</span>
        <span class="k">if</span> <span class="s2">&quot;transfer&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s2">&quot;transfer&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">assert</span> <span class="n">tagset</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span><span class="p">),</span> <span class="s2">&quot;Missing tags in [transfer]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># assume true for all tags otherwise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">}</span></div>

<div class="viewcode-block" id="XFaster.init_log"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.init_log">[docs]</a>    <span class="k">def</span> <span class="nf">init_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;notice&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the logger from the input keyword arguments.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        level : string, optional, default: &quot;notice&quot;</span>
<span class="sd">            Verbosity level.</span>
<span class="sd">            Options are &quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;all&quot;.</span>
<span class="sd">        filename : string, optional</span>
<span class="sd">            Logging output filename.  Default: None (print to sys.stdout)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># add NOTICE logging level</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span><span class="p">,</span> <span class="s2">&quot;NOTICE&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">logger_notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log a message with severity &quot;NOTICE&quot;.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">notice</span> <span class="o">=</span> <span class="n">logger_notice</span>

        <span class="k">def</span> <span class="nf">root_notice</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log a message with severity &quot;NOTICE&quot; on the root logger.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">handlers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">()</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">notice</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">notice</span> <span class="o">=</span> <span class="n">root_notice</span>

        <span class="c1"># create handler</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.batch_tools</span> <span class="kn">import</span> <span class="n">get_job_logfile</span>

            <span class="n">filename</span> <span class="o">=</span> <span class="n">get_job_logfile</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># create formatter</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span>
            <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;[ </span><span class="si">%(asctime)s</span><span class="s2"> ] </span><span class="si">%(levelname)s</span><span class="s2">: </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S%Z&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>

        <span class="c1"># configure logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;xfaster&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

        <span class="c1"># set logging level</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;notice&quot;</span>
        <span class="k">elif</span> <span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;notset&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">logging</span><span class="p">,</span> <span class="n">level</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span></div>

<div class="viewcode-block" id="XFaster.log"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log a message with the given logging level.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        level : string, default : None</span>
<span class="sd">            Logging level.  Must be one of &quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;,</span>
<span class="sd">            &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;all&quot;.  If not supplied, &quot;all&quot; is assumed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;notset&quot;</span>
        <span class="n">level</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">logging</span><span class="p">,</span> <span class="n">level</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.warn"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.warn">[docs]</a>    <span class="k">def</span> <span class="nf">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log a warning message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">XFasterWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure logger is shutdown properly when the object is destroyed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># cleanup logging handlers</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_root</span><span class="p">,</span>
        <span class="n">data_subset</span><span class="o">=</span><span class="s2">&quot;full/*0&quot;</span><span class="p">,</span>
        <span class="n">signal_subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">noise_subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span>
        <span class="n">noise_type</span><span class="o">=</span><span class="s2">&quot;stationary&quot;</span><span class="p">,</span>
        <span class="n">noise_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_type</span><span class="o">=</span><span class="s2">&quot;hitsmask_tailored&quot;</span><span class="p">,</span>
        <span class="n">signal_type</span><span class="o">=</span><span class="s2">&quot;r0p03&quot;</span><span class="p">,</span>
        <span class="n">signal_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">signal_transfer_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">foreground_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_planck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all files for the given data root.  Internal function, see</span>
<span class="sd">        ``get_files`` for a complete docstring.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">signal_transfer_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal_transfer_type</span> <span class="o">=</span> <span class="n">signal_type</span>

        <span class="c1"># regularize data root</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">data_root</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing data root </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_root</span><span class="p">))</span>

        <span class="c1"># find all map files</span>
        <span class="n">map_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;data_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_type</span><span class="p">))</span>
        <span class="n">map_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data_subset</span> <span class="o">=</span> <span class="n">data_subset</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">data_subset</span><span class="p">):</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing files in data subset </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="n">map_files</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="n">data_subset</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_subset</span><span class="p">)</span>
        <span class="n">map_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">map_files</span><span class="p">)</span>
        <span class="n">map_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;map_&quot;</span><span class="p">)]</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span>
        <span class="p">]</span>
        <span class="n">map_freqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">map_tags</span><span class="p">:</span>
            <span class="c1"># if map tag is not a plain frequency, extract plain frequency</span>
            <span class="n">map_freqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> map files in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">map_files</span><span class="p">),</span> <span class="n">map_root</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Map files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_files</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Map freqs: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_freqs</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="n">raw_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">raw_files</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># find all corresponding signal sims</span>
        <span class="n">signal_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;signal_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_type</span><span class="p">))</span>
        <span class="n">num_signal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">signal_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
            <span class="n">sfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">signal_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_subset</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sfiles</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing signal sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">num_signal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_signal</span> <span class="o">=</span> <span class="n">nsims1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsims1</span> <span class="o">!=</span> <span class="n">num_signal</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">nsims1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_signal</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">num_signal</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_signal</span><span class="p">,</span> <span class="n">nsims1</span><span class="p">)</span>
            <span class="n">signal_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sfiles</span><span class="p">)</span>
        <span class="n">signal_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="n">num_signal</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">signal_files</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_signal</span><span class="p">,</span> <span class="n">signal_root</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;First signal sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_files</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span> <span class="s2">&quot;debug&quot;</span>
        <span class="p">)</span>

        <span class="c1"># find all corresponding signal transfer function sims</span>
        <span class="n">signal_transfer_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;signal_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_transfer_type</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">num_signal_transfer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">signal_transfer_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
            <span class="n">sfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">signal_transfer_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_subset</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sfiles</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing signal sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">num_signal_transfer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_signal_transfer</span> <span class="o">=</span> <span class="n">nsims1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsims1</span> <span class="o">!=</span> <span class="n">num_signal_transfer</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal_transfer sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">nsims1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_signal_transfer</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">num_signal_transfer</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_signal_transfer</span><span class="p">,</span> <span class="n">nsims1</span><span class="p">)</span>
            <span class="n">signal_transfer_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sfiles</span><span class="p">)</span>
        <span class="n">signal_transfer_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">num_signal_transfer</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">signal_transfer_files</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal transfer sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">num_signal_transfer</span><span class="p">,</span> <span class="n">signal_transfer_root</span>
            <span class="p">),</span>
            <span class="s2">&quot;info&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;First signal transfer sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">signal_transfer_files</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">),</span>
            <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># find all corresponding noise sims</span>
        <span class="k">if</span> <span class="n">noise_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;noise_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_type</span><span class="p">))</span>
            <span class="n">num_noise</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">noise_files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
                <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">noise_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_subset</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing noise sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">num_noise</span> <span class="o">=</span> <span class="n">nsims1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsims1</span> <span class="o">!=</span> <span class="n">num_noise</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> noise sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nsims1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_noise</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">num_noise</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_noise</span><span class="p">,</span> <span class="n">nsims1</span><span class="p">)</span>
                <span class="n">noise_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
            <span class="n">noise_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="n">num_noise</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">noise_files</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> noise sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_noise</span><span class="p">,</span> <span class="n">noise_root</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;First noise sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_files</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span> <span class="s2">&quot;debug&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noise_root</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">noise_files</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># find all corresponding noise sims for sim_index run</span>
        <span class="k">if</span> <span class="n">noise_type_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise_root_sim</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;noise_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_type_sim</span><span class="p">))</span>
            <span class="n">num_noise_sim</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">noise_files_sim</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
                <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">noise_root_sim</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_subset</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing noise sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_noise_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">num_noise_sim</span> <span class="o">=</span> <span class="n">nsims1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsims1</span> <span class="o">!=</span> <span class="n">num_noise_sim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> noise sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nsims1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_noise_sim</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">num_noise_sim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_noise_sim</span><span class="p">,</span> <span class="n">nsims1</span><span class="p">)</span>
                <span class="n">noise_files_sim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
            <span class="n">noise_files_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">noise_files_sim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> noise sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_noise_sim</span><span class="p">,</span> <span class="n">noise_root_sim</span><span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;First noise sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_files_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noise_root_sim</span> <span class="o">=</span> <span class="n">noise_root</span>
            <span class="n">noise_files_sim</span> <span class="o">=</span> <span class="n">noise_files</span>

        <span class="c1"># find all corresponding signal sims for sim_index run</span>
        <span class="k">if</span> <span class="n">signal_type_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal_root_sim</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;signal_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_type_sim</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">num_signal_sim</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">signal_files_sim</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
                <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">signal_root_sim</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_subset</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing signal sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_signal_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">num_signal_sim</span> <span class="o">=</span> <span class="n">nsims1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsims1</span> <span class="o">!=</span> <span class="n">num_signal_sim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nsims1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_signal_sim</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">num_signal_sim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_signal_sim</span><span class="p">,</span> <span class="n">nsims1</span><span class="p">)</span>
                <span class="n">signal_files_sim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
            <span class="n">signal_files_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">signal_files_sim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_signal_sim</span><span class="p">,</span> <span class="n">signal_root_sim</span><span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;First signal sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_files_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_root_sim</span> <span class="o">=</span> <span class="n">signal_root</span>
            <span class="n">signal_files_sim</span> <span class="o">=</span> <span class="n">signal_files</span>

        <span class="c1"># find all corresponding foreground sims for sim_index run</span>
        <span class="k">if</span> <span class="n">foreground_type_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">foreground_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;foreground_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foreground_type_sim</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">num_foreground_sim</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">foreground_files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
                <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">foreground_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_*.fits&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing foreground sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_foreground_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">num_foreground_sim</span> <span class="o">=</span> <span class="n">nsims1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsims1</span> <span class="o">!=</span> <span class="n">num_foreground_sim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> foreground sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nsims1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_foreground_sim</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">num_foreground_sim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_foreground_sim</span><span class="p">,</span> <span class="n">nsims1</span><span class="p">)</span>
                <span class="n">foreground_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
            <span class="n">foreground_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">num_foreground_sim</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">foreground_files</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> foreground sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">num_foreground_sim</span><span class="p">,</span> <span class="n">foreground_root</span>
                <span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;First foreground sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">foreground_files</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">),</span>
                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">foreground_root</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">foreground_files</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># find all corresponding masks</span>
        <span class="k">if</span> <span class="n">mask_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument mask_type required&quot;</span><span class="p">)</span>
        <span class="c1"># If mask is a fits file, use the same mask for all maps</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">mask_type</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.fits&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mask_type</span><span class="p">):</span>
                <span class="c1"># it&#39;s an absolute path</span>
                <span class="n">mask_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mask_type</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_tags</span><span class="p">))</span>
                <span class="n">mask_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">mask_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># it&#39;s relative to base directory structure</span>
                <span class="n">mask_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_tags</span><span class="p">))</span>
                <span class="n">mask_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;masks_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_type</span><span class="p">))</span>
            <span class="c1"># XXX Do this smarter</span>
            <span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mask_root</span><span class="p">,</span> <span class="s2">&quot;mask_map_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">map_tags</span>
            <span class="p">]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mask_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing mask file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> masks in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_files</span><span class="p">),</span> <span class="n">mask_root</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_files</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="c1"># Also need a list of unique map tags for populating dictionaries</span>
        <span class="c1"># in data structures</span>
        <span class="n">map_tags_orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>  <span class="c1"># copy</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">unique_tags</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>

        <span class="c1"># make a list of names corresponding to the order of the cross spectra</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>
        <span class="n">map_pairs_orig</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">map_tags_orig</span><span class="p">)</span>

        <span class="c1"># make a dictionary of map freqs for each unique map tag</span>
        <span class="n">map_freqs_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">im0</span><span class="p">,</span> <span class="n">m0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_tags</span><span class="p">):</span>
            <span class="n">map_freqs_dict</span><span class="p">[</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_freqs</span><span class="p">[</span><span class="n">im0</span><span class="p">]</span>
        <span class="n">map_freqs</span> <span class="o">=</span> <span class="n">map_freqs_dict</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;data_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;data_subset&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_files&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_tags&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_pairs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_tags_orig&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_pairs_orig&quot;</span><span class="p">,</span>
            <span class="s2">&quot;map_freqs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;raw_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;raw_files&quot;</span><span class="p">,</span>
            <span class="s2">&quot;signal_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;signal_files&quot;</span><span class="p">,</span>
            <span class="s2">&quot;signal_root_sim&quot;</span><span class="p">,</span>
            <span class="s2">&quot;signal_files_sim&quot;</span><span class="p">,</span>
            <span class="s2">&quot;signal_transfer_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;signal_transfer_files&quot;</span><span class="p">,</span>
            <span class="s2">&quot;noise_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;noise_files&quot;</span><span class="p">,</span>
            <span class="s2">&quot;noise_root_sim&quot;</span><span class="p">,</span>
            <span class="s2">&quot;noise_files_sim&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mask_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mask_files&quot;</span><span class="p">,</span>
            <span class="s2">&quot;foreground_root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;foreground_files&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">local</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">]</span> <span class="o">=</span> <span class="n">local</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="XFaster.get_files"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_files">[docs]</a>    <span class="k">def</span> <span class="nf">get_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_root</span><span class="p">,</span>
        <span class="n">data_subset</span><span class="o">=</span><span class="s2">&quot;full/*0&quot;</span><span class="p">,</span>
        <span class="n">signal_subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">noise_subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span>
        <span class="n">noise_type</span><span class="o">=</span><span class="s2">&quot;stationary&quot;</span><span class="p">,</span>
        <span class="n">noise_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_type</span><span class="o">=</span><span class="s2">&quot;hitsmask_tailored&quot;</span><span class="p">,</span>
        <span class="n">signal_type</span><span class="o">=</span><span class="s2">&quot;r0p03&quot;</span><span class="p">,</span>
        <span class="n">signal_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">signal_transfer_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_root2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_subset2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">foreground_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_planck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all files for the given data root.  The data structure is::</span>

<span class="sd">            &lt;data_root&gt;</span>
<span class="sd">                -&gt; data_&lt;data_type&gt;</span>
<span class="sd">                    -&gt; full</span>
<span class="sd">                        -&gt; map_x1.fits</span>
<span class="sd">                        ...</span>
<span class="sd">                        -&gt; map_150.fits</span>
<span class="sd">                        -&gt; map_90.fits</span>
<span class="sd">                    -&gt; 1of4 (same filenames as full)</span>
<span class="sd">                    -&gt; 2of4 (&#39;&#39;)</span>
<span class="sd">                    -&gt; 3of4 (&#39;&#39;)</span>
<span class="sd">                    -&gt; 4of4 (&#39;&#39;)</span>
<span class="sd">                -&gt; signal_&lt;signal_type&gt;</span>
<span class="sd">                   -&gt; spec_signal_&lt;signal_type&gt;.dat</span>
<span class="sd">                   -&gt; full</span>
<span class="sd">                      -&gt; map_x1_0000.fits</span>
<span class="sd">                      ...</span>
<span class="sd">                      -&gt; map_90_####.fits</span>
<span class="sd">                   -&gt; 1of4 (same filenames as full)</span>
<span class="sd">                   -&gt; 2of4 (same filenames as full)</span>
<span class="sd">                   -&gt; 3of4 (same filenames as full)</span>
<span class="sd">                   -&gt; 4of4 (same filenames as full)</span>
<span class="sd">                -&gt; noise_&lt;noise_type&gt; (same filenames as signal_&lt;signal_type&gt;)</span>
<span class="sd">                -&gt; masks_&lt;mask_type&gt;</span>
<span class="sd">                    -&gt; mask_map_x1.fits</span>
<span class="sd">                    ...</span>
<span class="sd">                    -&gt; mask_map_90.fits</span>
<span class="sd">                    -&gt; mask_map_150.fits</span>
<span class="sd">                -&gt; foreground_&lt;foreground_type_sim&gt;</span>
<span class="sd">                    (same filenames as signal_&lt;signal_type&gt;)</span>
<span class="sd">                -&gt; templates_&lt;template_type&gt;</span>
<span class="sd">                   -&gt; halfmission-1</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">                   -&gt; halfmission-2</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">                -&gt; reobs_planck (if sub_planck=True)</span>
<span class="sd">                   -&gt; halfmission-1</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">                   -&gt; halfmission-2</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">            &lt;data_root2&gt;</span>
<span class="sd">                ...</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        data_root : string</span>
<span class="sd">            Top level path containing subdirectories for data, signal sims,</span>
<span class="sd">            noise sims, and masks.</span>
<span class="sd">        data_subset : string</span>
<span class="sd">            Subset of maps to use for spectrum estimation.  This should be</span>
<span class="sd">            a string that is parseable using ``glob`` on the path</span>
<span class="sd">            ``data_&lt;data_type&gt;/&lt;data_subset&gt;.fits``.  For example,</span>
<span class="sd">            ``&#39;full/*0&#39;`` will expand to read in the 150 GHz and 90GHz maps.</span>
<span class="sd">            Maps are then sorted in alphabetical order, and identified</span>
<span class="sd">            by their file tag, where each filename is ``map_&lt;tag&gt;.fits``.</span>
<span class="sd">        signal_subset : string</span>
<span class="sd">            Subset of map tags to use for spectrum estimation for signal</span>
<span class="sd">            sims.  This should be a string that is parseable using ``glob``</span>
<span class="sd">            that is added onto the data_subset path to indicate which sims</span>
<span class="sd">            to use. For example, for all, use ``&#39;*&#39;``. For the first 300 sims,</span>
<span class="sd">            use ``&#39;0[0-2]*&#39;``.</span>
<span class="sd">        noise_subset : string</span>
<span class="sd">            Subset of map tags to use for spectrum estimation for noise</span>
<span class="sd">            sims.  This should be a string that is parseable using ``glob``</span>
<span class="sd">            that is added onto the data_subset path to indicate which sims</span>
<span class="sd">            to use. For example, for all, use ``&#39;*&#39;``. For the first 300 sims,</span>
<span class="sd">            use ``&#39;0[0-2]*&#39;``.</span>
<span class="sd">        data_type : string</span>
<span class="sd">            The type of data to use.</span>
<span class="sd">        noise_type: string</span>
<span class="sd">            The variant of noise simulation to use, e.g. &#39;stationary&#39;,</span>
<span class="sd">            &#39;variable&#39;, etc.  The directory should contain the same number</span>
<span class="sd">            of simulations for each map tag.</span>
<span class="sd">        noise_type_sim : string</span>
<span class="sd">            The variant of noise sims to use for sim_index fake data map.</span>
<span class="sd">            This enables having a different noise sim ensemble to use for</span>
<span class="sd">            sim_index run than the ensemble from which the noise is computed.</span>
<span class="sd">        mask_type : string</span>
<span class="sd">            The variant of mask to use, e.g. &#39;hitsmask&#39;, etc.</span>
<span class="sd">            XXX: for the time being we assume a mask per file tag,</span>
<span class="sd">            rather than a mask per file in ``data_&lt;data_type&gt;``.</span>
<span class="sd">        signal_type : string</span>
<span class="sd">            The variant of signal simulation to use, typically identified</span>
<span class="sd">            by the input spectrum model used to generate it, e.g &#39;r0p03&#39;.</span>
<span class="sd">        signal_type_sim : string</span>
<span class="sd">            The variant of signal sims to use for sim_index fake data map.</span>
<span class="sd">            This enables having a different noise sim ensemble to use for</span>
<span class="sd">            sim_index run than the ensemble from which the signal is computed.</span>
<span class="sd">        signal_transfer_type : string</span>
<span class="sd">            The variant of signal simulation to use for transfer function</span>
<span class="sd">            calculation, typically identified by the input spectrum model</span>
<span class="sd">            used to generate it, e.g &#39;r0p03&#39;. This directory may also contain</span>
<span class="sd">            a copy of the input spectrum, to make sure that the correct</span>
<span class="sd">            spectrum is used to compute the transfer function.</span>
<span class="sd">        data_root2, data_subset2 : string</span>
<span class="sd">            The root and subset for a second set of data.</span>
<span class="sd">            If either of these is keywords is supplied, then the two data</span>
<span class="sd">            sets are treated as two halves of a null test.  In this case,</span>
<span class="sd">            XFaster computes the sum and difference spectra for each map</span>
<span class="sd">            tag in order to estimate a null spectrum.</span>
<span class="sd">        foreground_type_sim : string</span>
<span class="sd">            Tag for directory (foreground_&lt;foreground_type_sim&gt;) where foreground</span>
<span class="sd">            sims are that should be added to the signal and noise sims</span>
<span class="sd">            when running in sim_index mode. Note: the same foreground sim</span>
<span class="sd">            map is used for each sim_index, despite signal and noise sims</span>
<span class="sd">            changing.</span>
<span class="sd">        template_type : string</span>
<span class="sd">            Tag for directory (templates_&lt;template_type&gt;) containing templates</span>
<span class="sd">            (e.g. a foreground model) to be scaled by a scalar value per</span>
<span class="sd">            map tag and subtracted from the data. The directory contains one</span>
<span class="sd">            template per map tag.</span>
<span class="sd">        sub_planck : bool</span>
<span class="sd">            If True, subtract reobserved Planck from maps. Properly uses half</span>
<span class="sd">            missions so no Planck autos are used. Useful for removing expected</span>
<span class="sd">            signal residuals from null tests. Maps are expected to be in</span>
<span class="sd">            reobs_planck directory</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        file_settings : dict</span>
<span class="sd">            A dictionary of file settings used throughout the run.</span>
<span class="sd">            These are stored in full as ``&lt;output_root&gt;/files_&lt;output_tag&gt;.npz``,</span>
<span class="sd">            and a subset are added to the run configuration file</span>
<span class="sd">            ``&lt;output_root&gt;/config_&lt;output_tag&gt;.txt``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">signal_transfer_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal_transfer_type</span> <span class="o">=</span> <span class="n">signal_type</span>

        <span class="c1"># make sure sims get rerun correctly</span>
        <span class="k">if</span> <span class="n">signal_transfer_type</span> <span class="o">==</span> <span class="n">signal_type</span><span class="p">:</span>
            <span class="c1"># if signal types match, then sims are run before computing the</span>
            <span class="c1"># transfer function, so need to set the correct checkpoint to rerun</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">==</span> <span class="s2">&quot;sims&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">=</span> <span class="s2">&quot;sims_transfer&quot;</span>

        <span class="c1"># one of these must be set to do a null test</span>
        <span class="n">null_run</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">data_root2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">data_subset2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_root2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data_root2</span> <span class="o">=</span> <span class="n">data_root</span>
            <span class="k">if</span> <span class="n">data_subset2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data_subset2</span> <span class="o">=</span> <span class="n">data_subset</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">data_subset</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">data_root2</span><span class="p">,</span> <span class="n">data_subset2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Either data_root2 or data_subset2 must differ &quot;</span>
                    <span class="s2">&quot;from data_root/data_subset&quot;</span>
                <span class="p">)</span>
            <span class="n">null_run</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
            <span class="n">noise_type</span><span class="o">=</span><span class="n">noise_type</span><span class="p">,</span>
            <span class="n">noise_type_sim</span><span class="o">=</span><span class="n">noise_type_sim</span><span class="p">,</span>
            <span class="n">mask_type</span><span class="o">=</span><span class="n">mask_type</span><span class="p">,</span>
            <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span>
            <span class="n">signal_type_sim</span><span class="o">=</span><span class="n">signal_type_sim</span><span class="p">,</span>
            <span class="n">signal_transfer_type</span><span class="o">=</span><span class="n">signal_transfer_type</span><span class="p">,</span>
            <span class="n">signal_subset</span><span class="o">=</span><span class="n">signal_subset</span><span class="p">,</span>
            <span class="n">noise_subset</span><span class="o">=</span><span class="n">noise_subset</span><span class="p">,</span>
            <span class="n">foreground_type_sim</span><span class="o">=</span><span class="n">foreground_type_sim</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ref_opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data_subset</span><span class="o">=</span><span class="n">data_subset</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">ref_opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_subset2</span><span class="o">=</span><span class="n">data_subset2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_template_files</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">template_type</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Update options for template cleaning</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># no template fitting for null runs</span>
            <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;null_run&quot;</span><span class="p">]:</span>
                <span class="n">template_type</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="s2">&quot;template_type&quot;</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">template_type</span> <span class="o">==</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_type&quot;</span><span class="p">]:</span>
                    <span class="k">return</span>

            <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">template_type</span>

            <span class="c1"># find all corresponding foreground templates</span>
            <span class="k">if</span> <span class="n">template_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_root&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_root2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_root&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_root2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_template&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_template_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_template_noise</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">hm</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">]:</span>
                    <span class="n">suff</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">hm</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span> <span class="k">else</span> <span class="s2">&quot;2&quot;</span>
                    <span class="n">troot</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;templates_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">template_type</span><span class="p">),</span>
                        <span class="s2">&quot;halfmission-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hm</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="c1">### this block is so sims with template type like</span>
                    <span class="c1"># 353_100_gauss_003 can use ensemble in 353_100_gauss</span>
                    <span class="n">tp</span> <span class="o">=</span> <span class="n">template_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                    <span class="n">ttype</span> <span class="o">=</span> <span class="n">template_type</span>
                    <span class="k">if</span> <span class="n">tp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">ttype</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;353_100&quot;</span><span class="p">,</span> <span class="s2">&quot;217_100&quot;</span><span class="p">]:</span>
                            <span class="n">ttype</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                    <span class="n">tnroot</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;templates_noise_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ttype</span><span class="p">),</span>
                        <span class="s2">&quot;halfmission-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hm</span><span class="p">),</span>
                    <span class="p">)</span>

                    <span class="n">tfiles</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">tnfiles</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;map_files&quot;</span><span class="p">]:</span>
                        <span class="n">nfile</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;map_root&quot;</span><span class="p">],</span> <span class="n">troot</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nfile</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing hm-</span><span class="si">{}</span><span class="s2"> template for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                        <span class="n">tfiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfile</span><span class="p">)</span>
                        <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                            <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;map_root&quot;</span><span class="p">],</span> <span class="n">tnroot</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                                    <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_*.fits&quot;</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                                <span class="s2">&quot;Missing hm-</span><span class="si">{}</span><span class="s2"> template noise for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="n">tnfiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">num_template_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_template_noise</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                                    <span class="s2">&quot;Wrong number of template noise sims.  &quot;</span>
                                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> files, expected </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">),</span> <span class="n">num_template_noise</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>

                        <span class="n">num_template_noise</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfiles</span><span class="p">)</span>

                    <span class="n">tfiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tfiles</span><span class="p">)</span>
                    <span class="n">tnfiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tnfiles</span><span class="p">)</span>
                    <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)]</span> <span class="o">=</span> <span class="n">troot</span>
                    <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_files</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tfiles</span>
                    <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tnroot</span>
                    <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_files</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tnfiles</span>

                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_template&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_files&quot;</span><span class="p">])</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_template_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_template_noise</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> templates in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_template&quot;</span><span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_root&quot;</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;info&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> template noise files in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_template_noise&quot;</span><span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_noise_root&quot;</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;info&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Template files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;template_files&quot;</span><span class="p">]),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;template_type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_root&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_root2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_files&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_files2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_noise_root&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_noise_root2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_noise_files&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_noise_files2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_template&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_template_noise&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">get_planck_files</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">sub_planck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Update options for planck subtraction</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_planck</span><span class="p">:</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_root1_hm1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_root2_hm1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_root1_hm2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_root2_hm2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_files1_hm1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_files2_hm1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_files1_hm2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_files2_hm2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_planck&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">null_split</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">null_split</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">suff</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">suff</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="k">for</span> <span class="n">hm</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">]:</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_planck&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">proot</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;data_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)],</span>
                            <span class="s2">&quot;reobs_planck&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;halfmission-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hm</span><span class="p">),</span>
                        <span class="p">)</span>
                        <span class="n">pfiles</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;map_files</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)]:</span>
                            <span class="n">nfile</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;map_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">)],</span> <span class="n">proot</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nfile</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing hm-</span><span class="si">{}</span><span class="s2"> map for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                            <span class="n">pfiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nfile</span><span class="p">)</span>
                            <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_planck&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">pfiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pfiles</span><span class="p">)</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_root</span><span class="si">{}</span><span class="s2">_hm</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">null_split</span><span class="p">,</span> <span class="n">hm</span><span class="p">)]</span> <span class="o">=</span> <span class="n">proot</span>
                        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_files</span><span class="si">{}</span><span class="s2">_hm</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">null_split</span><span class="p">,</span> <span class="n">hm</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pfiles</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> planck maps in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_planck&quot;</span><span class="p">],</span>
                                <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;planck_root</span><span class="si">{}</span><span class="s2">_hm</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">null_split</span><span class="p">,</span> <span class="n">hm</span><span class="p">)],</span>
                            <span class="p">),</span>
                            <span class="s2">&quot;info&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Planck files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pfiles</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;planck_root1_hm1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_root2_hm1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_root1_hm2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_root2_hm2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_files1_hm1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_files2_hm1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_files1_hm2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;planck_files2_hm2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;num_planck&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;files&quot;</span>
        <span class="n">alt_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">!=</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
            <span class="n">alt_name</span> <span class="o">=</span> <span class="n">save_name</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">template_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alt_name</span> <span class="o">=</span> <span class="n">save_name</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_clean_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">template_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_planck</span><span class="p">:</span>
            <span class="n">alt_name</span> <span class="o">=</span> <span class="n">save_name</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_planck_sub&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">)</span>
        <span class="c1"># load file info from disk</span>
        <span class="k">if</span> <span class="n">signal_type_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">noise_type_sim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span><span class="p">,</span> <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value_ref</span><span class="o">=</span><span class="n">ref_opts</span><span class="p">,</span> <span class="n">alt_name</span><span class="o">=</span><span class="n">alt_name</span>
            <span class="p">)</span>
            <span class="n">save</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fix data root</span>
            <span class="n">ret_data_root</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">]</span>
            <span class="n">ret_data_root2</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_root2&quot;</span><span class="p">,</span> <span class="n">data_root2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_root</span> <span class="o">==</span> <span class="n">ret_data_root</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">null_run</span> <span class="ow">or</span> <span class="n">data_root2</span> <span class="o">==</span> <span class="n">ret_data_root2</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">template_type</span> <span class="o">!=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;template_type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">get_template_files</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">template_type</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sub_planck</span> <span class="ow">and</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;planck_root1&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">get_planck_files</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">sub_planck</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="k">def</span> <span class="nf">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">v</span>
                <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">ret_data_root2</span> <span class="o">!=</span> <span class="n">ret_data_root</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ret_data_root2</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ret_data_root2</span><span class="p">,</span> <span class="n">data_root2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ret_data_root</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ret_data_root</span><span class="p">,</span> <span class="n">data_root</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">v</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span> <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">template_type</span> <span class="o">!=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;template_type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">get_template_files</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">template_type</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sub_planck</span> <span class="ow">and</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;planck_root1&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">get_planck_files</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">sub_planck</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># find all map files</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_files</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">data_subset</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        <span class="c1"># count all the things</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_maps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;map_files&quot;</span><span class="p">])</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;signal_files&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal_transfer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;signal_transfer_files&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;noise_files&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;noise_files&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_noise_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_foreground&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_corr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">num_corr</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_maps&quot;</span><span class="p">])</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">num_corr</span><span class="p">(</span><span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_spec_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">num_corr</span><span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_kern&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_corr&quot;</span><span class="p">]</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;data_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_corr&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_spec&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;mask_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_corr&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_spec_mask&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;kern_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_kern&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;null_run&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">null_run</span>

        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="c1"># find all map files for null tests</span>
            <span class="n">fs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_files</span><span class="p">(</span><span class="n">data_root2</span><span class="p">,</span> <span class="n">data_subset2</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
            <span class="c1"># check for matching number of maps</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;map_files2&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_maps&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> map2 files, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_maps&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="c1"># XXX make sure tags match?</span>

            <span class="c1"># check for matching number of sims</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;signal_files2&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal2 sims, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;signal_transfer_files2&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal_transfer&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal2 transfer sims, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal_transfer&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;noise_files&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;noise_files2&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_noise&quot;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> noise2 sims, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_noise&quot;</span><span class="p">])</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;noise_files_sim2&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_noise_sim&quot;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> noise_sim2 sims, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_noise_sim&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;signal_files_sim2&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal_sim&quot;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> signal_sim2 sims, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_signal_sim&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s2">&quot;foreground_files2&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_foreground&quot;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> foreground2 sims, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">n</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="s2">&quot;num_foreground&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="c1"># XXX make sure sim numbers match?</span>

            <span class="c1"># we&#39;re doing a null test</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">null_run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">fs2</span><span class="p">)</span>

        <span class="n">get_template_files</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">template_type</span><span class="p">)</span>
        <span class="n">get_planck_files</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">sub_planck</span><span class="p">)</span>

        <span class="c1"># store and return settings dictionary</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fs</span></div>

<div class="viewcode-block" id="XFaster.get_map"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">check_nside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an input map from file or from an internal cache.  Maps are</span>
<span class="sd">        checked to make sure they all have a consistent size, and optionally</span>
<span class="sd">        cached to limit disk I/O.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Path to file on disk.</span>
<span class="sd">        check_nside : bool</span>
<span class="sd">            If True (default), make sure that all maps have the same ``nside``,</span>
<span class="sd">            and that it satisfies ``lmax &lt;= 4 * nside``.</span>
<span class="sd">        cache : bool</span>
<span class="sd">            If True, cache the map in memory to avoid rereading from disk.</span>
<span class="sd">            Use this for maps that are used multiple times by the algoritm</span>
<span class="sd">            (e.g. masks).</span>

<span class="sd">        Any remaining arguments are passed to ``healpy.read_map``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map : array_like</span>
<span class="sd">            2D map array containing 1 (T) or 3 (T/Q/U) maps.</span>
<span class="sd">            If the XFaster class was initialized with ``pol = True``, this</span>
<span class="sd">            returns a 2D array of T/Q/U maps from the file. Otherwise a</span>
<span class="sd">            (1, npix) array is returned containing only the T map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="c1"># initialize map cache</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_map_cache&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;reset&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># return a copy from cache if found</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="ow">and</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">])</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;field&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Reading map from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="n">m</span><span class="p">[</span><span class="n">hp</span><span class="o">.</span><span class="n">mask_bad</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">check_nside</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nside&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># check nside</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">get_nside</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="n">nside</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nside</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Input map </span><span class="si">{}</span><span class="s2"> has nside </span><span class="si">{}</span><span class="s2"> expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">filename</span><span class="p">,</span> <span class="n">nside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># check npix</span>
            <span class="n">npix</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">nside2npix</span><span class="p">(</span><span class="n">nside</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;npix&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="n">npix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">npix</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Input map </span><span class="si">{}</span><span class="s2"> has npix </span><span class="si">{}</span><span class="s2"> expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">filename</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># check lmax</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;lmax </span><span class="si">{}</span><span class="s2"> may be too large for nside </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="XFaster.get_mask"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_lims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an input mask from file or from an internal cache.</span>
<span class="sd">        See ``XFaster.get_map`` for details.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Path to mask file on disk.</span>
<span class="sd">        cache : bool</span>
<span class="sd">            This option defaults to True, since masks are typically used</span>
<span class="sd">            for all data and sims for a given map tag.</span>
<span class="sd">        check_lims : bool</span>
<span class="sd">            If True, values in the mask outside of [0,1] are fixed to</span>
<span class="sd">            these limits.</span>

<span class="sd">        Any remaining arguments are passed to ``XFaster.get_map``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : array_like</span>
<span class="sd">            2D array containing 1 (T) or 2 (T/P) maps;  If the XFaster class</span>
<span class="sd">            was initialized with ``pol_mask = True``, this returns a 2D array</span>
<span class="sd">            containing both T and P masks.  Otherwise, a (1, npix) is</span>
<span class="sd">            returned containing only the T map.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields_mask</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;field&quot;</span><span class="p">,</span> <span class="n">fields_mask</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_lims</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">m</span><span class="p">[</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="XFaster.get_filename"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_filename">[docs]</a>    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iter_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bp_opts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a standard output file path to read or write.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : string</span>
<span class="sd">            String name of output type.  E.g. &#39;data_xcorr&#39; for data</span>
<span class="sd">            cross-correlation spectra.</span>
<span class="sd">            If an output tag is set, the name is appended with</span>
<span class="sd">            &#39;_&lt;output_tag&gt;&#39;.</span>
<span class="sd">        ext : string</span>
<span class="sd">            File extension.  The default (&#39;.npz&#39;) is used for storing</span>
<span class="sd">            output data dictionaries.</span>
<span class="sd">        map_tag : string</span>
<span class="sd">            If supplied, the name is appended with &#39;_map_&lt;map_tag&gt;&#39;.</span>
<span class="sd">            Use this argument when storing output data in a loop over</span>
<span class="sd">            input maps.</span>
<span class="sd">        iter_index : int</span>
<span class="sd">            If supplied, the name is appended with &#39;_iter&lt;iter_index&gt;&#39;</span>
<span class="sd">        extra_tag : string</span>
<span class="sd">            If supplied the extra tag is appended to the name as is.</span>
<span class="sd">        bp_opts : bool</span>
<span class="sd">            If True, the output filename is constructed  by checking the</span>
<span class="sd">            following list  of options used in constructing bandpowers:</span>
<span class="sd">            ensemble_mean, ensemble_median, sim_index, template_cleaned,</span>
<span class="sd">            weighted_bins, signal_type_sim, noise_type_sim</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Output filename as ``&lt;output_root&gt;/&lt;name&gt;&lt;ext&gt;``, where</span>
<span class="sd">            &lt;name&gt; can optionally include the map index, iteration index</span>
<span class="sd">            or output tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">bp_opts</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_mean</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_mean&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_median</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_median&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_sim</span><span class="si">{:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_type_sim</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_type_sim</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_type_sim</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_type_sim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">!=</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_clean_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;planck_sub&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_planck_sub&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_wbins&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;return_cls&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_cl&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_map_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iter_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_iter</span><span class="si">{:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">iter_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extra_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">extra_tag</span><span class="p">)</span>

        <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span></div>

<div class="viewcode-block" id="XFaster.load_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.load_data">[docs]</a>    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">checkpoint</span><span class="p">,</span>
        <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">shape_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alt_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">optional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">file_opts</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load xfaster data from an output npz file on disk.</span>

<span class="sd">        This method is called throughout the code at various checkpoints.  If</span>
<span class="sd">        the data exist on disk, they are loaded and returned.  If the data are</span>
<span class="sd">        missing or otherwise incompatible, they are recomputed by the calling</span>
<span class="sd">        method, and trigger all subsequent data to also be recomputed.  Data</span>
<span class="sd">        handling is described in the ``Notes`` section for methods that use this</span>
<span class="sd">        functionality.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the data set.  The filename is contructed from this</span>
<span class="sd">            as ``&lt;output_root&gt;/&lt;name&gt;_&lt;output_tag&gt;.npz``.  If the file is not</span>
<span class="sd">            found then the data are recomputed.</span>
<span class="sd">        checkpoint : string</span>
<span class="sd">            The name of the checkpoint to which this dataset applies.</span>
<span class="sd">            If XFaster is initialized at this checkpoint, or if any of the</span>
<span class="sd">            file checks enabled with the following options fails, all</span>
<span class="sd">            quantities from this point forward are recomputed.</span>
<span class="sd">        fields : list of strings</span>
<span class="sd">            List of fields that should be present in the data file.</span>
<span class="sd">            If any are not found, the entire dataset and all subsequent</span>
<span class="sd">            step are recomputed.</span>
<span class="sd">        to_attrs : bool or list of bools or strings</span>
<span class="sd">            If True, all items in ``fields`` are stored as attributes of the</span>
<span class="sd">            parent object.  If A list of booleans, must have the same length</span>
<span class="sd">            as ``fields``; any field for which this list item is True is then</span>
<span class="sd">            stored as an attribute of the object.  If any list item is a string,</span>
<span class="sd">            then the corresponding field is stored as an attribute with this</span>
<span class="sd">            new name.</span>
<span class="sd">        shape : tuple of ints</span>
<span class="sd">            If set, the field specified by ``shape_ref`` is checked to have this</span>
<span class="sd">            shape.  If this check fails, then all data are recomputed.</span>
<span class="sd">        shape_ref : string</span>
<span class="sd">            The reference field whose shape is checked against ``shape``.</span>
<span class="sd">            If None and ``shape`` is set, use the first field in ``fields``.</span>

<span class="sd">        Remaining options are passed to ``get_filename`` for constructing the</span>
<span class="sd">        output file path.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            If all checks above succeed, the requested data are returned.</span>
<span class="sd">            If any tests fail, None is returned, and all subsequent calls</span>
<span class="sd">            to ``load_data`` also return None to trigger recomputing all data</span>
<span class="sd">            that may depend on this dataset.</span>
<span class="sd">            The output dictionary has the additional key &#39;output_file&#39; which</span>
<span class="sd">            is set to the path to the data file on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># checkpointing</span>
        <span class="k">def</span> <span class="nf">force_rerun_children</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Trigger rerunning steps that depend on this checkpoint.&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_tree</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">if</span> <span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid checkpoint </span><span class="si">{}</span><span class="s2">, must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">checkpoint</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid checkpoint </span><span class="si">{}</span><span class="s2">, must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">checkpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">==</span> <span class="n">checkpoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">checkpoint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">checkpoint</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>

        <span class="n">use_alt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Error loading </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_file</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Output file not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">alt_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">alt_name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Error loading </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_file</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Alternate output file not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">use_alt</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">fields</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">shape_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape_ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">shape_ref</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">to_attrs</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">to_attrs</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">to_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_attrs</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape_ref</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">value_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value_ref</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">to_attrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">optional</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">optional</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">field</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">shape_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="n">field</span><span class="p">,</span> <span class="n">attr</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                    <span class="c1"># check if it&#39;s just an extra dimension, ie (1,500) vs (500,)</span>
                    <span class="n">passes</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">passes</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">passes</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> has shape </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">errmsg</span><span class="p">,</span> <span class="n">shape_ref</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">value_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">field</span><span class="p">,</span> <span class="n">attr</span><span class="p">]:</span>
                    <span class="n">vref</span> <span class="o">=</span> <span class="n">value_ref</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;undef&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vref</span> <span class="o">==</span> <span class="s2">&quot;undef&quot;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">vref</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> has value </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">errmsg</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">vref</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">field</span> <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">attr</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">value_ref</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Missing reference fields </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">value_ref</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">force_rerun_children</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Loaded input data from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_alt</span><span class="p">:</span>
            <span class="c1"># copy data to original file name</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">file_opts</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;output_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_file</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="XFaster.save_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save xfaster data to an output npz file on disk.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the data set.  The filename is contructed from this as</span>
<span class="sd">            ``&lt;output_root&gt;/&lt;name&gt;_&lt;output_tag&gt;.npz``.  If the file is not found</span>
<span class="sd">            then the data are recomputed.</span>
<span class="sd">        from_attrs : list of strings</span>
<span class="sd">            A list of object attributes which should be stored in the data file.</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            Load the dataset corresponding to this map.</span>
<span class="sd">            See ``get_filename`` for documentation.</span>
<span class="sd">        iter_index : int</span>
<span class="sd">            Load the dataset corresponding to this iteration index.</span>
<span class="sd">            See ``get_filename`` for documentation.</span>
<span class="sd">        bp_opts : bool</span>
<span class="sd">            Format output bandpowers file.  See ``get_filename`` for documentation.</span>

<span class="sd">        Any remaining keyword arguments are added to the output dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            A copy of the data dictionary that was stored to disk.</span>
<span class="sd">            The output dictionary has the additional key &#39;output_file&#39; which</span>
<span class="sd">            is set to the path to the data file on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;data_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_version</span>

        <span class="n">file_opts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;map_tag&quot;</span><span class="p">,</span> <span class="s2">&quot;iter_index&quot;</span><span class="p">,</span> <span class="s2">&quot;bp_opts&quot;</span><span class="p">,</span> <span class="s2">&quot;extra_tag&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">file_opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>

        <span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">from_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Saved output data to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;output_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_file</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="XFaster.save_config"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.save_config">[docs]</a>    <span class="k">def</span> <span class="nf">save_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a configuration file for the current run on disk.</span>
<span class="sd">        This method is used by ``xfaster_run`` to store the config</span>
<span class="sd">        in ``&lt;output_root&gt;/config_&lt;output_tag&gt;.txt``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">XFasterConfig</span><span class="p">):</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">XFasterConfig</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">creator</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getlogin</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="n">creator</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;# Created by </span><span class="si">{}</span><span class="s2"> on {:%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">creator</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filename</span></div>

<div class="viewcode-block" id="XFaster.apply_mask"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.apply_mask">[docs]</a>    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the input mask to the data map, in place.</span>

<span class="sd">        If the map is polarized, the appropriate mask is applied</span>
<span class="sd">        to the polarization data, depending on whether the mask</span>
<span class="sd">        is also polarized.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        m : array_like</span>
<span class="sd">            Input map (T/Q/U if polarized, T-only if not)</span>
<span class="sd">            This array is modified in place.</span>
<span class="sd">        mask : array_like</span>
<span class="sd">            Mask to apply (T/P if polarized, T-only if not)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="k">else</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="XFaster.map2alm"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.map2alm">[docs]</a>    <span class="k">def</span> <span class="nf">map2alm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for healpy.map2alm.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        m : array_like</span>
<span class="sd">            Masked input map for which Alms are computed.</span>
<span class="sd">        pol : bool</span>
<span class="sd">            If None, this is set using the value with which the object</span>
<span class="sd">            was initialized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alms : array_like</span>
<span class="sd">            Alms for the input map, computed using the equivalent of</span>
<span class="sd">            ``healpy.map2alm(m, lmax, pol=self.pol, use_weights=True)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="n">pol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span> <span class="n">use_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="XFaster.alm2cl"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.alm2cl">[docs]</a>    <span class="k">def</span> <span class="nf">alm2cl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for healpy.alm2cl.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        m1 : array_like</span>
<span class="sd">            Masked alms for map1</span>
<span class="sd">        m2 : array_like</span>
<span class="sd">            Masked alms for map2</span>
<span class="sd">        lmin : int</span>
<span class="sd">            The minimum ell bin to include in the output Cls.  All ell</span>
<span class="sd">            bins below this are nulled out.</span>
<span class="sd">        lmax : int</span>
<span class="sd">            The maximum ell bin to compute.  If None, this is set to the</span>
<span class="sd">            lmax value with which the class was initialized.</span>
<span class="sd">        symmetric : bool</span>
<span class="sd">            If True, the average cross spectrum of (m1-x-m2 + m2-x-m1) / 2.</span>
<span class="sd">            is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls : array_like</span>
<span class="sd">            Cross-spectrum of m1-x-m2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="n">lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">alms2</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="n">cls_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">alms2</span><span class="o">=</span><span class="n">m1</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">))</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="p">(</span><span class="bp">cls</span> <span class="o">+</span> <span class="n">cls_T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="n">lmin</span><span class="p">:</span>
            <span class="bp">cls</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">lmin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_mask_weights"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_mask_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_gcorr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reload_gcorr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gcorr_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cross spectra of the masks for each data map.</span>

<span class="sd">        Mode counting matrices are also computed and stored for each mask.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        apply_gcorr : bool</span>
<span class="sd">            If True, a correction factor is applied to the g (mode counting)</span>
<span class="sd">            matrix.  The correction factor should have been pre-computed for</span>
<span class="sd">            each map tag.</span>
<span class="sd">        reload_gcorr : bool</span>
<span class="sd">            If True, reload the gcorr file from the masks directory. Useful when</span>
<span class="sd">            iteratively solving for the correction terms.</span>
<span class="sd">        gcorr_file : str</span>
<span class="sd">            If not None, path to gcorr file. Otherwise, use file labeled</span>
<span class="sd">            mask_map_&lt;tag&gt;_gcorr.npy in mask directory for signal, or</span>
<span class="sd">            mask_map_&lt;tag&gt;_gcorr_null.npy for nulls.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;masks&#39; checkpoint, loads or saves a</span>
<span class="sd">        data dictionary with the following keys:</span>

<span class="sd">           wls : (num_map_corr, num_pol_mask_corr, lmax + 1)</span>
<span class="sd">               mask1-x-mask2 mask cross spectra for every mask pair</span>
<span class="sd">           fsky, w1, w2, w4 : (num_map_corr, num_pol_mask_corr)</span>
<span class="sd">               sky fraction and weighted modes per mask product</span>
<span class="sd">           gmat : (num_maps * num_pol_mask_corr, ) * 2</span>
<span class="sd">               mode-counting matrix, computed from</span>
<span class="sd">                   g = fsky * w2 ** 2 / w4</span>

<span class="sd">        Where the dimensions of each item are determined from:</span>

<span class="sd">           num_map_corr : Nmap * (Nmap + 1) / 2</span>
<span class="sd">               number of map-map correlations</span>
<span class="sd">           num_pol_mask_corr : 3 (TT, TP, PP) if pol else 1 (TT)</span>
<span class="sd">               number of mask spectrum correlations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">mask_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_shape</span>
        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;wls&quot;</span><span class="p">,</span> <span class="s2">&quot;fsky&quot;</span><span class="p">,</span> <span class="s2">&quot;w1&quot;</span><span class="p">,</span> <span class="s2">&quot;w2&quot;</span><span class="p">,</span> <span class="s2">&quot;w4&quot;</span><span class="p">,</span> <span class="s2">&quot;gmat&quot;</span><span class="p">,</span> <span class="s2">&quot;nside&quot;</span><span class="p">,</span> <span class="s2">&quot;npix&quot;</span><span class="p">,</span> <span class="s2">&quot;gcorr&quot;</span><span class="p">]</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;masks_xcorr&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;masks&quot;</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gcorr&quot;</span><span class="p">],</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">mask_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;wls&quot;</span><span class="p">,</span>
            <span class="n">alt_name</span><span class="o">=</span><span class="s2">&quot;data_xcorr&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">process_gcorr</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;gcorr&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">apply_gcorr</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mfile</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">apply_gcorr</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">reload_gcorr</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">gcorr_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span><span class="p">:</span>
                        <span class="n">gcorr_file</span> <span class="o">=</span> <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_gcorr_null.npz&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gcorr_file</span> <span class="o">=</span> <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_gcorr.npz&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;G correction file </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="n">gdata</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">)</span>
                <span class="n">gcorr</span> <span class="o">=</span> <span class="n">gdata</span><span class="p">[</span><span class="s2">&quot;gcorr&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gcorr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># check bins match g</span>
                    <span class="n">bd0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="n">gdata</span><span class="p">[</span><span class="s2">&quot;bin_def&quot;</span><span class="p">][</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
                        <span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd0</span><span class="p">)]</span>
                        <span class="n">gcorr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">bd0</span> <span class="o">==</span> <span class="n">bd</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;G correction for map </span><span class="si">{}</span><span class="s2"> has incompatible bin def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">tag</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Found g correction for map </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">gcorr</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">gcorr</span>

            <span class="c1"># compute ell-by-ell mode counting factor</span>
            <span class="n">gmat_ell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ellfac</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">ell</span> <span class="o">+</span> <span class="mf">1.0</span>

            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">apply_gcorr</span><span class="p">:</span>
                    <span class="n">gcorr0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">[</span><span class="n">m0</span><span class="p">]</span>
                    <span class="n">gcorr1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">[</span><span class="n">m1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmat</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">*</span> <span class="n">ellfac</span>
                    <span class="k">if</span> <span class="n">apply_gcorr</span><span class="p">:</span>
                        <span class="n">gcorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gcorr0</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">*</span> <span class="n">gcorr1</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span>
                        <span class="k">for</span> <span class="n">gc</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gcorr</span><span class="p">,</span> <span class="n">bd</span><span class="p">):</span>
                            <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">*=</span> <span class="n">gc</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span> <span class="o">=</span> <span class="n">apply_gcorr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gmat_ell</span> <span class="o">=</span> <span class="n">gmat_ell</span>

        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">process_gcorr</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">apply_gcorr</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reload_gcorr</span> <span class="ow">or</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gcorr&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;gcorr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># mask spectra</span>
        <span class="n">wls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># moments</span>
        <span class="n">fsky</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">fsky_eff</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">w1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">w4</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">gmat</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing Alms for mask </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">mask_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_alms</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">spec_inds</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tt&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;ee&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;bb&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="s2">&quot;te&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;eb&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="s2">&quot;tb&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">imask_alms</span><span class="p">,</span> <span class="n">imask</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">jmask_alms</span><span class="p">,</span> <span class="n">jmask</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">jdx</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing mask spectra </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="n">wls</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imask_alms</span><span class="p">,</span> <span class="n">jmask_alms</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span><span class="p">:</span>
                <span class="c1"># If there is a pol mask in addition to I, copy it to</span>
                <span class="c1"># U so no I masks is [I, Q, U] instead of [I, pol]</span>
                <span class="n">imask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">imask</span><span class="p">,</span> <span class="n">imask</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">jmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">jmask</span><span class="p">,</span> <span class="n">jmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># calculate moments of cross masks</span>
            <span class="c1"># this is an array of shape (pol_dim, pol_dim, npix)</span>
            <span class="c1"># and contains all combinations of mask products</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i...,j...-&gt;ij...&quot;</span><span class="p">,</span> <span class="n">imask</span><span class="p">,</span> <span class="n">jmask</span><span class="p">))</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pol_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># fsky is the fraction of pixels that are nonzero, independent</span>
            <span class="c1"># of weight</span>
            <span class="n">fsky</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span>
            <span class="n">w1</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">counts</span>
            <span class="n">w2</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">counts</span>
            <span class="n">w4</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span> <span class="o">**</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">counts</span>
            <span class="c1"># effective fsky takes into account weights between 0 and 1</span>
            <span class="n">fsky_eff</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">fsky</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">w2</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">/</span> <span class="n">w4</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">fsky</span><span class="p">[</span><span class="n">xname</span><span class="p">])</span>  <span class="c1"># second order correction</span>
            <span class="p">)</span>

            <span class="c1"># compute gmat as the average fsky_eff assuming symmetrically</span>
            <span class="c1"># computed cross spectra, e.g. TE = (T1 * E2 + T2 * E1) / 2</span>
            <span class="n">gmat</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">si</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">spec_inds</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">fsky_eff</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">]</span> <span class="o">+</span> <span class="n">fsky_eff</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sj</span><span class="p">,</span> <span class="n">si</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">gmat</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fsky</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Some fsky are larger than 10</span><span class="si">% - s</span><span class="s2">econd order &quot;</span>
                <span class="s2">&quot;correction may break down here: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fsky</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># store and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wls</span> <span class="o">=</span> <span class="n">wls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fsky</span> <span class="o">=</span> <span class="n">fsky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">=</span> <span class="n">w1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">=</span> <span class="n">w2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w4</span> <span class="o">=</span> <span class="n">w4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gmat</span> <span class="o">=</span> <span class="n">gmat</span>

        <span class="n">process_gcorr</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Fsky: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fsky</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Effective fsky: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fsky_eff</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask moments 1: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask moments 2: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w2</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask moments 4: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w4</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;G matrix: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmat</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_masked_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">template_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sub_planck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sub_hm_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cross spectra of the data maps.</span>

<span class="sd">        Map and mask files must have been loaded in by calling the ``get_files``</span>
<span class="sd">        method with the appropriate file selection options.</span>

<span class="sd">        If only one dataset is selected, spectra are computed for every</span>
<span class="sd">        combination of pairs of data maps.  This results in N * (N + 1) / 2</span>
<span class="sd">        cross spectra for N maps.  A unique mask is used for each input map.</span>

<span class="sd">        If two datasets are selected, then sum and difference cross-spectra are</span>
<span class="sd">        computed by summing and differencing the two datasets.  A unique mask is</span>
<span class="sd">        used for each map in the first dataset, and the same mask is applied to</span>
<span class="sd">        the corresponding map in the second dataset, so that both halves are</span>
<span class="sd">        masked identically.</span>

<span class="sd">        If ``template_alpha`` is supplied, the values given are applied to an</span>
<span class="sd">        appropriate template, and the result is subtracted from the data alms</span>
<span class="sd">        with map tags in the dictionary.  Map alms are cached to speed up</span>
<span class="sd">        processing, if this method is called repeatedly with different values.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        template_alpha : dict</span>
<span class="sd">            Dictionary of template scaling factors to apply to foreground</span>
<span class="sd">            templates to be subtracted from the data.  Keys should match</span>
<span class="sd">            original map tags in the data set.</span>
<span class="sd">        sub_planck : bool</span>
<span class="sd">            If True, subtract reobserved Planck from maps. Properly uses half</span>
<span class="sd">            missions so no Planck autos are used. Useful for removing expected</span>
<span class="sd">            signal residuals from null tests.</span>
<span class="sd">        sub_hm_noise : bool</span>
<span class="sd">            If True, subtract average of Planck ffp10 noise crosses to debias</span>
<span class="sd">            template-cleaned spectra.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;data&#39; checkpoint, loads or saves a data</span>
<span class="sd">        dictionary with the following keys:</span>

<span class="sd">           cls_data : OrderedDict</span>
<span class="sd">               map1-x-map2 cross spectra for every map pair. This contains the</span>
<span class="sd">               sum cross spectra if constructing a null test, or the</span>
<span class="sd">               template-subtracted cross spectra if ``template_alpha`` is</span>
<span class="sd">               supplied.</span>
<span class="sd">           cls_data_null : OrderedDict</span>
<span class="sd">               (map1a-map1b)-x-(map2a-map2b) difference cross spectra</span>
<span class="sd">               for every map pair, if computing a null test</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_files</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">raw_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_files</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="n">null_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span>
        <span class="n">map_files2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># ensure dictionary</span>
        <span class="k">if</span> <span class="n">template_alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">null_run</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># ensure tagged by original tags</span>
        <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Check for output data on disk</span>
        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cls_data&quot;</span><span class="p">,</span> <span class="s2">&quot;nside&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
            <span class="n">data_name</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_name</span> <span class="o">=</span> <span class="s2">&quot;data_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_xcorr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_name</span><span class="p">)</span>
        <span class="n">template_fit</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_null&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sub_planck</span><span class="p">:</span>
                <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_sub_null&quot;</span><span class="p">]</span>
                <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_planck_null&quot;</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">template_fit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_clean_</span><span class="si">{}</span><span class="s2">_xcorr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_type</span><span class="p">)</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;cls_data_clean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_template&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_alpha&quot;</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">sub_planck</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_sub&quot;</span><span class="p">]</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_planck&quot;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">apply_template</span><span class="p">():</span>
            <span class="n">cls_clean</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cls_data_clean&quot;</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">cls_clean</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_clean</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">m0</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs_orig</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                    <span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="n">template_alpha</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)]</span>

                    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t1</span>
                    <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t2</span>
                        <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">+=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t3</span>
                            <span class="c1"># subtract average template noise spectrum to debias</span>
                            <span class="k">if</span> <span class="n">sub_hm_noise</span><span class="p">:</span>
                                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_tnoise_hm1xhm2</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                                <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_clean</span> <span class="o">=</span> <span class="n">cls_clean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="o">=</span> <span class="n">template_alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">subtract_planck_maps</span><span class="p">():</span>
            <span class="n">cls_data_sub</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cls_data_sub&quot;</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">cls_data_sub_null</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cls_data_sub_null&quot;</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">cls_data_sub</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_data_sub</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_planck</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">+=</span> <span class="o">-</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span>

                <span class="c1"># do null specs</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="n">cls_data_sub_null</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_data_sub_null</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_planck_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="n">d</span> <span class="o">+=</span> <span class="o">-</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_sub</span> <span class="o">=</span> <span class="n">cls_data_sub</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_sub_null</span> <span class="o">=</span> <span class="n">cls_data_sub_null</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># change template subtraction coefficients for pre-loaded data</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">template_fit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">template_fit</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">template_alpha</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">}</span>

                <span class="n">apply_template</span><span class="p">()</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">}</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;data&quot;</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_data&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sub_planck</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span><span class="p">:</span>
                    <span class="n">subtract_planck_maps</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">template_alpha</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="n">apply_template</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># map spectra</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cls_null</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># set up template subtraction</span>
        <span class="n">cls_tmp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
            <span class="n">cls_tmp</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">template_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_files2</span><span class="p">))</span>
        <span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># set up planck subtraction</span>
        <span class="n">cls_planck</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sub_planck</span><span class="p">:</span>
            <span class="n">cls_planck</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_planck_null</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">planck_files_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">planck_files1_hm1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">planck_files1_hm2</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">planck_files2_hm1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">planck_files2_hm2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">planck_subtracted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># convenience function</span>
        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing Alms for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">map_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">map_files2</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

                <span class="c1"># sum and diff spectra for null tests</span>
                <span class="c1"># XXX should not take average but sum here if we want to</span>
                <span class="c1"># compare power with sum...</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="n">mn_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">m</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sub_planck</span><span class="p">:</span>
                    <span class="c1"># cache raw data alms and planck alms together</span>
                    <span class="n">mp1hm1</span><span class="p">,</span> <span class="n">mp1hm2</span><span class="p">,</span> <span class="n">mp2hm1</span><span class="p">,</span> <span class="n">mp2hm2</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">plank_files_split</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">m_alms_hm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">mp1hm1</span> <span class="o">+</span> <span class="n">mp2hm1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                    <span class="n">m_alms_hm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">mp1hm2</span> <span class="o">+</span> <span class="n">mp2hm2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                    <span class="n">mn_alms_hm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">mp1hm1</span> <span class="o">-</span> <span class="n">mp2hm1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                    <span class="n">mn_alms_hm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">mp1hm2</span> <span class="o">-</span> <span class="n">mp2hm2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                    <span class="n">m_alms</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">m_alms_hm1</span><span class="p">,</span> <span class="n">m_alms_hm2</span><span class="p">)</span>
                    <span class="n">mn_alms</span> <span class="o">=</span> <span class="p">(</span><span class="n">mn_alms</span><span class="p">,</span> <span class="n">mn_alms_hm1</span><span class="p">,</span> <span class="n">mn_alms_hm2</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">template_fit</span><span class="p">:</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="n">mn_alms</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># cache raw data alms and template alms together</span>
                <span class="n">mn_alms</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">template_files</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Loading template from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tf</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                    <span class="n">mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                    <span class="n">mt_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                    <span class="c1"># null out T template</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                        <span class="n">mt_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">0</span>
                    <span class="n">m_alms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt_alms</span><span class="p">)</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m_alms</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">imap_alms</span><span class="p">,</span> <span class="n">inull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">jmap_alms</span><span class="p">,</span> <span class="n">jnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">jdx</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing spectra </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="c1"># store cross spectra</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_planck</span><span class="p">:</span>
                    <span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># raw map spectrum component</span>
                <span class="n">cls1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># average template alms</span>
                <span class="n">imt</span> <span class="o">=</span> <span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">jmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="c1"># compute maximally symmetric cross spectra</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># multiplies alpha_i</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmt</span><span class="p">)</span>  <span class="c1"># multiplies alpha_j</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># multiplies alpha_i * alpha_j</span>

                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                    <span class="c1"># apply template to TE/TB but not TT</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_planck</span> <span class="ow">and</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_planck</span> <span class="k">if</span> <span class="n">sub_planck</span> <span class="k">else</span> <span class="n">cls_tmp</span>
                    <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">cls_dict</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t3</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="c1"># do this again for the null maps</span>
                    <span class="n">cls_null1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># average template alms</span>
                    <span class="n">imt</span> <span class="o">=</span> <span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">inull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">jmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">jnull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="c1"># compute maximally symmetric cross spectra</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmt</span><span class="p">)</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_planck_null</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                        <span class="n">cls_dict</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t3</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">,</span> <span class="n">jmap_alms</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="n">cls_null1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">,</span> <span class="n">jnull_alms</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="n">cls_null</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_null1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="c1"># store and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span> <span class="o">=</span> <span class="n">cls_null</span>

        <span class="k">if</span> <span class="n">template_cleaned</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span> <span class="o">=</span> <span class="n">cls_tmp</span>
            <span class="n">apply_template</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">sub_planck</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_planck</span> <span class="o">=</span> <span class="n">cls_planck</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_planck_null</span> <span class="o">=</span> <span class="n">cls_planck_null</span>
            <span class="n">subtract_planck_maps</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_masked_sims"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_sims">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_sims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ensemble_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ensemble_median</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sim_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">do_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">sims_add_alms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">qb_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute average signal and noise spectra for a given</span>
<span class="sd">        ensemble of maps.  The same procedure that is used for computing</span>
<span class="sd">        data cross spectra is used for each realization in the sim</span>
<span class="sd">        ensemble, and only the average spectra for all realizations</span>
<span class="sd">        are stored.</span>

<span class="sd">        See ``get_masked_data`` for more details on how cross spectra</span>
<span class="sd">        are computed.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        ensemble_mean : bool</span>
<span class="sd">            If true, the mean signal + noise spectrum is used in place</span>
<span class="sd">            of input data.  This is useful for testing the behavior of</span>
<span class="sd">            the estimator and mapmaker independently of the data.</span>
<span class="sd">        ensemble_median : bool</span>
<span class="sd">            If true, the median signal + noise spectrum is used in place</span>
<span class="sd">            of input data.  This is useful for testing the behavior of</span>
<span class="sd">            the estimator and mapmaker independently of the data.</span>
<span class="sd">        sim_index : int</span>
<span class="sd">            If not None, substitute the sim_index S+N alms for the observed alms</span>
<span class="sd">        sims_add_alms : bool</span>
<span class="sd">            If True and sim_index is not None, add sim alms instead of sim Cls</span>
<span class="sd">            to include signal and noise correlations</span>
<span class="sd">        qb_file : string</span>
<span class="sd">            Pointer to a bandpowers.npz file in the output directory. If used</span>
<span class="sd">            in sim_index mode, the noise sim read from disk will be corrected</span>
<span class="sd">            by the residual qb values stored in qb_file.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;sims&#39; checkpoint, and loads or saves</span>
<span class="sd">        a data dictionary with the following entries::</span>

<span class="sd">            cls_signal : &lt;same shape as cls_data&gt;</span>
<span class="sd">            cls_signal_null : &lt;same as cls_data&gt;</span>
<span class="sd">                Average signal spectra (sum and difference if computing</span>
<span class="sd">                a null test).</span>
<span class="sd">            cls_noise : &lt;same shape as cls_data&gt;</span>
<span class="sd">            cls_noise_null : &lt;same as cls_data&gt;</span>
<span class="sd">                Average null spectra (sum and difference if computing</span>
<span class="sd">                a null test).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">num_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>

        <span class="n">sims_attr</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_files</span>
            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_signal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_signal_transfer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_files</span>
            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_signal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_signal</span>

        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_files</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_noise</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_files_sim</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_files_sim</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_noise_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_noise_sim</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_signal_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_signal_sim</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foreground_files</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_foreground&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_foreground</span>

        <span class="n">foreground_sims</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
            <span class="n">do_noise</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># if qb file is not none, modify cls by residual in file</span>
            <span class="k">if</span> <span class="n">qb_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">qb_file</span><span class="p">):</span>
                    <span class="n">qb_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">,</span> <span class="n">qb_file</span><span class="p">)</span>
                <span class="n">qb_file</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">qb_file</span><span class="p">)</span>

        <span class="n">null_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span>
        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files_sim2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_files_sim2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files_sim2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_files_sim2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foreground_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># convenience functions</span>
        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">files2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qbf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute alms of masked input map</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">filename</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idx2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing Alms for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing Alms for sim </span><span class="si">{}</span><span class="s2"> of map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">idx2</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;all&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="c1"># second null half</span>
                <span class="n">filename2</span> <span class="o">=</span> <span class="n">files2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idx2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filename2</span> <span class="o">=</span> <span class="n">filename2</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">filename2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

                <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="n">mn_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">((</span><span class="n">m</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="n">mn_alms</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">qbf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if qb file is not none, modify alms by residual in file</span>
                <span class="n">rbins</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;res&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qbf</span><span class="p">[</span><span class="s2">&quot;bin_def&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
                <span class="n">rfields</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tt&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;ee&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;bb&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;eebb&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
                <span class="k">for</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rb0</span> <span class="ow">in</span> <span class="n">rbins</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">srb</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">rqb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qbf</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">][</span><span class="n">rb</span><span class="p">])</span>
                    <span class="p">(</span><span class="n">bad</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rqb</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;Unphysical residuals fit, setting to zero </span><span class="si">{}</span><span class="s2"> bins </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">rb</span><span class="p">,</span> <span class="n">bad</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">rqb</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">mod</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">expand_qb</span><span class="p">(</span><span class="n">qrb</span><span class="p">,</span> <span class="n">rb0</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">rfields</span><span class="p">[</span><span class="n">srb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">srb</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                            <span class="n">m_alms</span><span class="p">[</span><span class="n">rf</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">almxfl</span><span class="p">(</span><span class="n">m_alms</span><span class="p">[</span><span class="n">rf</span><span class="p">],</span> <span class="n">mod</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">mn_alms</span><span class="p">[</span><span class="n">rf</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">almxfl</span><span class="p">(</span><span class="n">mn_alms</span><span class="p">[</span><span class="n">rf</span><span class="p">],</span> <span class="n">mod</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">process_files</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute cross spectra</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">sig_field</span> <span class="o">=</span> <span class="s2">&quot;cls_signal&quot;</span>
            <span class="n">sig_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_signal_null&quot;</span>
            <span class="n">noise_field</span> <span class="o">=</span> <span class="s2">&quot;cls_noise&quot;</span>
            <span class="n">noise_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_noise_null&quot;</span>
            <span class="n">tot_field</span> <span class="o">=</span> <span class="s2">&quot;cls_sim&quot;</span>
            <span class="n">tot_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_sim_null&quot;</span>
            <span class="n">med_field</span> <span class="o">=</span> <span class="s2">&quot;cls_med&quot;</span>
            <span class="n">med_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_med_null&quot;</span>

            <span class="c1">### These fields are needed to iteratate on noise from res fits</span>
            <span class="n">noise0_field</span> <span class="o">=</span> <span class="s2">&quot;cls_noise0&quot;</span>
            <span class="n">noise0_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_noise0_null&quot;</span>
            <span class="n">noise1_field</span> <span class="o">=</span> <span class="s2">&quot;cls_noise1&quot;</span>
            <span class="n">noise1_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_noise1_null&quot;</span>
            <span class="n">sxn0_field</span> <span class="o">=</span> <span class="s2">&quot;cls_sxn0&quot;</span>
            <span class="n">sxn0_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_sxn0_null&quot;</span>
            <span class="n">nxs0_field</span> <span class="o">=</span> <span class="s2">&quot;cls_nxs0&quot;</span>
            <span class="n">nxs0_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_nxs0_null&quot;</span>
            <span class="n">sxn1_field</span> <span class="o">=</span> <span class="s2">&quot;cls_sxn1&quot;</span>
            <span class="n">sxn1_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_sxn1_null&quot;</span>
            <span class="n">nxs1_field</span> <span class="o">=</span> <span class="s2">&quot;cls_nxs1&quot;</span>
            <span class="n">nxs1_null_field</span> <span class="o">=</span> <span class="s2">&quot;cls_nxs1_null&quot;</span>
            <span class="c1">###</span>

            <span class="n">sig_files</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files&quot;</span><span class="p">]</span>
            <span class="n">sig_files2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">noise_files</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files&quot;</span><span class="p">]</span>
            <span class="n">noise_files2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">sig_files2</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files2&quot;</span><span class="p">]</span>
                <span class="n">noise_files2</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files2&quot;</span><span class="p">]</span>

            <span class="n">nsim_sig</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_signal&quot;</span><span class="p">]</span>
            <span class="n">nsim_noise</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_noise&quot;</span><span class="p">]</span>

            <span class="n">cls_sig</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_sig</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_noise</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_null_noise</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_tot</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_tot</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_med</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_med</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="c1">### Noise iteration from res fit fields</span>
            <span class="n">cls_noise0</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_null_noise0</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_noise1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_null_noise1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_sxn0</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_sxn0</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_nxs0</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_nxs0</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_sxn1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_sxn1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">cls_nxs1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_null_nxs1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">sig_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">noise_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nsim_noise</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsim_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">nsim_sig</span><span class="p">,</span> <span class="n">nsim_noise</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nsim_min</span> <span class="o">=</span> <span class="n">nsim_sig</span>
            <span class="n">nsim_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">nsim_sig</span><span class="p">,</span> <span class="n">nsim_noise</span><span class="p">])</span>
            <span class="n">cls_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">[</span><span class="n">nsim_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">cls_all_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">nsim_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim_max</span><span class="p">):</span>
                <span class="n">sig_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="n">noise_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Computing spectra </span><span class="si">{}</span><span class="s2"> for signal</span><span class="si">{}</span><span class="s2"> sim </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">xname</span><span class="p">,</span> <span class="s2">&quot;+noise&quot;</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">isim</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_sig</span><span class="p">:</span>
                        <span class="n">simap_alms</span><span class="p">,</span> <span class="n">sinull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">sig_files</span><span class="p">,</span> <span class="n">sig_files2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">sig_cache</span>
                        <span class="p">)</span>
                        <span class="n">sjmap_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">sig_files</span><span class="p">,</span> <span class="n">sig_files2</span><span class="p">,</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">sig_cache</span>
                        <span class="p">)</span>

                        <span class="n">cls1_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">simap_alms</span><span class="p">,</span> <span class="n">sjmap_alms</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_null1_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">sinull_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_noise</span><span class="p">:</span>
                        <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">ninull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">noise_files</span><span class="p">,</span>
                            <span class="n">noise_files2</span><span class="p">,</span>
                            <span class="n">idx</span><span class="p">,</span>
                            <span class="n">isim</span><span class="p">,</span>
                            <span class="n">noise_cache</span><span class="p">,</span>
                            <span class="n">qbf</span><span class="o">=</span><span class="n">qb_file</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">njnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">noise_files</span><span class="p">,</span>
                            <span class="n">noise_files2</span><span class="p">,</span>
                            <span class="n">jdx</span><span class="p">,</span>
                            <span class="n">isim</span><span class="p">,</span>
                            <span class="n">noise_cache</span><span class="p">,</span>
                            <span class="n">qbf</span><span class="o">=</span><span class="n">qb_file</span><span class="p">,</span>
                        <span class="p">)</span>

                        <span class="c1"># need non-symmetric since will potentially modify these</span>
                        <span class="c1"># with different residuals for T, E, B</span>
                        <span class="n">cls1_noise0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                            <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                        <span class="n">cls1_noise1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                            <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                        <span class="n">cls1_noise</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls1_noise0</span> <span class="o">+</span> <span class="n">cls1_noise1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                        <span class="n">cls1_sxn0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">simap_alms</span><span class="p">,</span> <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">cls1_nxs0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">nimap_alms</span><span class="p">,</span> <span class="n">sjmap_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">cls1_sxn1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">njmap_alms</span><span class="p">,</span> <span class="n">simap_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">cls1_nxs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">sjmap_alms</span><span class="p">,</span> <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">cls1_sxn</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls1_sxn0</span> <span class="o">+</span> <span class="n">cls1_sxn1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                        <span class="n">cls1_nxs</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls1_nxs0</span> <span class="o">+</span> <span class="n">cls1_nxs1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_null1_noise0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                                <span class="n">ninull_alms</span><span class="p">,</span> <span class="n">njnull_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="n">cls_null1_noise1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                                <span class="n">njnull_alms</span><span class="p">,</span> <span class="n">ninull_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="n">cls_null1_noise</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls_null1_noise0</span> <span class="o">+</span> <span class="n">cls_null1_noise1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

                            <span class="n">cls_null1_sxn0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                                <span class="n">sinull_alms</span><span class="p">,</span> <span class="n">njnull_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="n">cls_null1_nxs0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                                <span class="n">ninull_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="n">cls_null1_sxn1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                                <span class="n">njnull_alms</span><span class="p">,</span> <span class="n">sinull_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="n">cls_null1_nxs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span>
                                <span class="n">sjnull_alms</span><span class="p">,</span> <span class="n">ninull_alms</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="n">cls_null1_sxn</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls_null1_sxn0</span> <span class="o">+</span> <span class="n">cls_null1_sxn1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                            <span class="n">cls_null1_nxs</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls_null1_nxs0</span> <span class="o">+</span> <span class="n">cls_null1_nxs1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

                        <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_min</span><span class="p">:</span>
                            <span class="n">cls1t</span> <span class="o">=</span> <span class="n">cls1_sig</span> <span class="o">+</span> <span class="n">cls1_sxn</span> <span class="o">+</span> <span class="n">cls1_nxs</span> <span class="o">+</span> <span class="n">cls1_noise</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">cls_null1t</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">cls_null1_sig</span>
                                    <span class="o">+</span> <span class="n">cls_null1_sxn</span>
                                    <span class="o">+</span> <span class="n">cls_null1_nxs</span>
                                    <span class="o">+</span> <span class="n">cls_null1_noise</span>
                                <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cls1t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cls1_sig</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_null1t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cls_null1_sig</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="n">quants</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_sig</span><span class="p">:</span>
                            <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_sig</span><span class="p">,</span> <span class="n">cls1_sig</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_null_sig</span><span class="p">,</span> <span class="n">cls_null1_sig</span><span class="p">]]</span>

                        <span class="k">if</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_noise</span><span class="p">:</span>
                            <span class="n">quants</span> <span class="o">+=</span> <span class="p">[</span>
                                <span class="p">[</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cls1_noise</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">cls_noise0</span><span class="p">,</span> <span class="n">cls1_noise0</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">cls_noise1</span><span class="p">,</span> <span class="n">cls1_noise1</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">cls_sxn0</span><span class="p">,</span> <span class="n">cls1_sxn0</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">cls_sxn1</span><span class="p">,</span> <span class="n">cls1_sxn1</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">cls_nxs0</span><span class="p">,</span> <span class="n">cls1_nxs0</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">cls_nxs1</span><span class="p">,</span> <span class="n">cls1_nxs1</span><span class="p">],</span>
                            <span class="p">]</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">quants</span> <span class="o">+=</span> <span class="p">[</span>
                                    <span class="p">[</span><span class="n">cls_null_noise</span><span class="p">,</span> <span class="n">cls_null1_noise</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">cls_null_noise0</span><span class="p">,</span> <span class="n">cls_null1_noise0</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">cls_null_noise1</span><span class="p">,</span> <span class="n">cls_null1_noise1</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">cls_null_sxn0</span><span class="p">,</span> <span class="n">cls_null1_sxn0</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">cls_null_sxn1</span><span class="p">,</span> <span class="n">cls_null1_sxn1</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">cls_null_nxs0</span><span class="p">,</span> <span class="n">cls_null1_nxs0</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">cls_null_nxs1</span><span class="p">,</span> <span class="n">cls_null1_nxs1</span><span class="p">],</span>
                                <span class="p">]</span>
                        <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_min</span><span class="p">:</span>
                            <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_tot</span><span class="p">,</span> <span class="n">cls1t</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_null_tot</span><span class="p">,</span> <span class="n">cls_null1t</span><span class="p">]]</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">quants</span><span class="p">):</span>
                            <span class="c1"># running average</span>
                            <span class="k">for</span> <span class="n">quant0</span><span class="p">,</span> <span class="n">quant1</span> <span class="ow">in</span> <span class="n">quants</span><span class="p">:</span>
                                <span class="n">d</span> <span class="o">=</span> <span class="n">quant0</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                    <span class="n">xname</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">quant1</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                                <span class="p">)</span>
                                <span class="n">d</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">quant1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">isim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># in-place</span>
                        <span class="n">cls_all</span><span class="p">[</span><span class="n">isim</span><span class="p">][</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_tot</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_all_null</span><span class="p">[</span><span class="n">isim</span><span class="p">][</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_null_tot</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

            <span class="n">cls_med_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cls_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                <span class="n">cls_med</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="n">xname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">):</span>
                    <span class="n">cls_med</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_med_arr</span><span class="p">[</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">cls_null_med_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cls_all_null</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                    <span class="n">cls_null_med</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="n">xname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">):</span>
                        <span class="n">cls_null_med</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_null_med_arr</span><span class="p">[</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_field</span><span class="p">,</span> <span class="n">cls_sig</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_null_field</span><span class="p">,</span> <span class="n">cls_null_sig</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise_field</span><span class="p">,</span> <span class="n">cls_noise</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise_null_field</span><span class="p">,</span> <span class="n">cls_null_noise</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tot_field</span><span class="p">,</span> <span class="n">cls_tot</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tot_null_field</span><span class="p">,</span> <span class="n">cls_null_tot</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">med_field</span><span class="p">,</span> <span class="n">cls_med</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">med_null_field</span><span class="p">,</span> <span class="n">cls_null_med</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise0_field</span><span class="p">,</span> <span class="n">cls_noise0</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise0_null_field</span><span class="p">,</span> <span class="n">cls_null_noise0</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise1_field</span><span class="p">,</span> <span class="n">cls_noise1</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise1_null_field</span><span class="p">,</span> <span class="n">cls_null_noise1</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sxn0_field</span><span class="p">,</span> <span class="n">cls_sxn0</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sxn0_null_field</span><span class="p">,</span> <span class="n">cls_null_sxn0</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sxn1_field</span><span class="p">,</span> <span class="n">cls_sxn1</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sxn1_null_field</span><span class="p">,</span> <span class="n">cls_null_sxn1</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxs0_field</span><span class="p">,</span> <span class="n">cls_nxs0</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxs0_null_field</span><span class="p">,</span> <span class="n">cls_null_nxs0</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxs1_field</span><span class="p">,</span> <span class="n">cls_nxs1</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxs1_null_field</span><span class="p">,</span> <span class="n">cls_null_nxs1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">check_options</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ensemble_mean</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Substitute signal + noise for observed spectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;notice&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span>
                                    <span class="n">spec</span>
                                <span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal_null</span><span class="p">[</span>
                                    <span class="n">spec</span>
                                <span class="p">][</span><span class="n">xname</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ensemble_median</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Substitute signal + noise median for observed spectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;notice&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_med</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_med_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span>
                                <span class="n">xname</span>
                            <span class="p">]</span>

            <span class="k">elif</span> <span class="n">sim_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Substitute #</span><span class="si">{}</span><span class="s2"> sim signal + noise for observed alms&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_index</span><span class="p">),</span> <span class="s2">&quot;notice&quot;</span><span class="p">)</span>

                <span class="c1"># find the sim file that matches the requested sim index</span>
                <span class="c1"># NB: this assumes that the sim files have the form</span>
                <span class="c1"># *_&lt;sim_index&gt;.fits, and will raise an error</span>
                <span class="c1"># if this is not the case, or if the index is not found</span>
                <span class="n">file_indices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">file_index</span> <span class="o">=</span> <span class="n">file_indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sim_index</span><span class="p">)</span>
                <span class="n">scache</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">ncache</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">fgcache</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">simap_alms</span><span class="p">,</span> <span class="n">sinull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">],</span>
                        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files_sim2&quot;</span><span class="p">],</span>
                        <span class="n">idx</span><span class="p">,</span>
                        <span class="n">file_index</span><span class="p">,</span>
                        <span class="n">scache</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">simap_alms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">simap_alms</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">sinull_alms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sinull_alms</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                        <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">ninull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">],</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files_sim2&quot;</span><span class="p">],</span>
                            <span class="n">idx</span><span class="p">,</span>
                            <span class="n">file_index</span><span class="p">,</span>
                            <span class="n">ncache</span><span class="p">,</span>
                            <span class="n">qbf</span><span class="o">=</span><span class="n">qb_file</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">sims_add_alms</span><span class="p">:</span>
                            <span class="n">simap_alms</span> <span class="o">+=</span> <span class="n">nimap_alms</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">sinull_alms</span> <span class="o">+=</span> <span class="n">ninull_alms</span>
                    <span class="k">if</span> <span class="n">foreground_sims</span><span class="p">:</span>
                        <span class="n">fimap_alms</span><span class="p">,</span> <span class="n">finull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">],</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files2&quot;</span><span class="p">],</span>
                            <span class="n">idx</span><span class="p">,</span>
                            <span class="n">file_index</span><span class="p">,</span>
                            <span class="n">fgcache</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">sims_add_alms</span><span class="p">:</span>
                            <span class="n">simap_alms</span> <span class="o">+=</span> <span class="n">fimap_alms</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">sinull_alms</span> <span class="o">+=</span> <span class="n">finull_alms</span>

                    <span class="n">sjmap_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">],</span>
                        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;signal_files_sim2&quot;</span><span class="p">],</span>
                        <span class="n">jdx</span><span class="p">,</span>
                        <span class="n">file_index</span><span class="p">,</span>
                        <span class="n">scache</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">sjmap_alms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sjmap_alms</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">sjnull_alms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sjnull_alms</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                        <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">njnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">],</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;noise_files_sim2&quot;</span><span class="p">],</span>
                            <span class="n">jdx</span><span class="p">,</span>
                            <span class="n">file_index</span><span class="p">,</span>
                            <span class="n">ncache</span><span class="p">,</span>
                            <span class="n">qbf</span><span class="o">=</span><span class="n">qb_file</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">sims_add_alms</span><span class="p">:</span>
                            <span class="n">sjmap_alms</span> <span class="o">+=</span> <span class="n">njmap_alms</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">sjnull_alms</span> <span class="o">+=</span> <span class="n">njnull_alms</span>
                    <span class="k">if</span> <span class="n">foreground_sims</span><span class="p">:</span>
                        <span class="n">fjmap_alms</span><span class="p">,</span> <span class="n">fjnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files&quot;</span><span class="p">],</span>
                            <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;foreground_files2&quot;</span><span class="p">],</span>
                            <span class="n">jdx</span><span class="p">,</span>
                            <span class="n">file_index</span><span class="p">,</span>
                            <span class="n">fgcache</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">sims_add_alms</span><span class="p">:</span>
                            <span class="n">sjmap_alms</span> <span class="o">+=</span> <span class="n">fjmap_alms</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">sjnull_alms</span> <span class="o">+=</span> <span class="n">fjnull_alms</span>

                    <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">simap_alms</span><span class="p">,</span> <span class="n">sjmap_alms</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sims_add_alms</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                            <span class="bp">cls</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">nimap_alms</span><span class="p">,</span> <span class="n">njmap_alms</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">foreground_sims</span><span class="p">:</span>
                            <span class="bp">cls</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">fimap_alms</span><span class="p">,</span> <span class="n">fjmap_alms</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">sinull_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sims_add_alms</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                                <span class="bp">cls</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">ninull_alms</span><span class="p">,</span> <span class="n">njnull_alms</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">foreground_sims</span><span class="p">:</span>
                                <span class="bp">cls</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">finull_alms</span><span class="p">,</span> <span class="n">fjnull_alms</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_mean</span> <span class="o">=</span> <span class="n">ensemble_mean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_median</span> <span class="o">=</span> <span class="n">ensemble_median</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span> <span class="o">=</span> <span class="n">sim_index</span>

        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;cls_signal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_noise&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_sim&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_med&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_noise0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_noise1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_sxn0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_sxn1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_nxs0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_nxs1&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;cls_signal_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_noise_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_sim_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_med_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_noise0_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_noise1_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_sxn0_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_sxn1_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_nxs0_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_nxs1_null&quot;</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;sims_xcorr_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_type</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;sims_transfer&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;sims_xcorr_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_type</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;sims&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="n">cp</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_signal&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">process_files</span><span class="p">()</span>
                <span class="n">check_options</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_noise_null&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">check_options</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">check_options</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># don&#39;t rerun sims a second time if they&#39;ve already been run once</span>
            <span class="c1"># with the same signal type</span>
            <span class="k">if</span> <span class="n">transfer</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_type</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sims&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># process signal, noise, and S+N</span>
        <span class="n">process_files</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_noise</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># save and return</span>
        <span class="n">check_options</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_masked_fake_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_fake_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_fake_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fake_data_r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fake_data_template</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sim_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noise_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">do_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">do_signal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">save_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sub_hm_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In memory, make a fake data map with signal, noise, and</span>
<span class="sd">        foregrounds.</span>
<span class="sd">        Signal maps are signal_scalar + fake_data_r * signal_tensor</span>
<span class="sd">        where scalar maps are assumed to be in signal_r0 directory</span>
<span class="sd">        and tensor maps are assumed to be in signal_r1tens directory.</span>
<span class="sd">        sim_index is used to determine which sims. Noise maps taken</span>
<span class="sd">        from usual noise directory. Templates read read from</span>
<span class="sd">        templates_fake_data_template/halfmission-1.</span>

<span class="sd">        This function doesn&#39;t write anything to disk. It just constructs</span>
<span class="sd">        the maps and computes the Cls and replaces data cls with them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_files</span>
        <span class="n">map_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_root</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">raw_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_files</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="n">data_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_root</span>

        <span class="n">scalar_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;signal_r0&quot;</span><span class="p">)</span>
        <span class="n">tensor_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;signal_r1tens&quot;</span><span class="p">)</span>
        <span class="n">noise_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;noise_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise_type</span><span class="p">))</span>

        <span class="c1"># ensure dictionary</span>
        <span class="k">if</span> <span class="n">template_alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># ensure tagged by original tags</span>
        <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">template_fit</span> <span class="o">=</span> <span class="n">fake_data_template</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
            <span class="n">template_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_files2</span><span class="p">))</span>
            <span class="n">template_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;templates_</span><span class="si">{}</span><span class="s2">/halfmission-1&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fake_data_template</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="p">])</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Fake data r: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fake_data_r</span><span class="p">),</span> <span class="s2">&quot;notice&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="c1"># create the fake map for each map in map_files,</span>
            <span class="c1"># compute alms for that and templates</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Computing Alms for fake data map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span>
            <span class="p">)</span>
            <span class="n">mfile</span> <span class="o">=</span> <span class="n">map_files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">do_signal</span><span class="p">:</span>
                <span class="n">scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span>
                    <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">scalar_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{:04}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_index</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span>
                    <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">tensor_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{:04}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_index</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Using signal 0&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                <span class="n">scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span>
                    <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">scalar_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_0000.fits&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span>
                    <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">tensor_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_0000.fits&quot;</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span>
                    <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">noise_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{:04}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sim_index</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Using noise 0&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span>
                    <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">noise_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_0000.fits&quot;</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">template</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
                <span class="n">template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">template_root</span><span class="p">))</span>

            <span class="n">m_tot</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fake_data_r</span><span class="p">))</span> <span class="o">*</span> <span class="n">tensor</span> <span class="o">+</span> <span class="n">noise</span>
            <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
                <span class="n">m_tot</span> <span class="o">+=</span> <span class="n">template_alpha</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">*</span> <span class="n">template</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m_tot</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m_tot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fake_data_r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">m_totn</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fake_data_r</span><span class="p">))</span> <span class="o">*</span> <span class="n">tensor</span> <span class="o">+</span> <span class="n">noise</span>
                <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
                    <span class="n">m_totn</span> <span class="o">+=</span> <span class="n">template_alpha</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">*</span> <span class="n">template</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m_totn</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                <span class="n">mn_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m_totn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="p">[</span><span class="n">m_alms</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">template_files</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Loading template from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tf</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                    <span class="n">mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                    <span class="n">mt_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                    <span class="c1"># null out T template</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                        <span class="n">mt_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">0</span>
                    <span class="n">m_alms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt_alms</span><span class="p">)</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m_alms</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fake_data_r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_alms</span>

            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">imap_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">jmap_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">jdx</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Computing fake data spectra </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span>
            <span class="p">)</span>

            <span class="c1"># store cross spectra</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fake_data_r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cls1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># average template alms</span>
                    <span class="n">imt</span> <span class="o">=</span> <span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">jmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="c1"># compute maximally symmetric cross spectra</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># multiplies alpha_i</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmt</span><span class="p">)</span>  <span class="c1"># multiplies alpha_j</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># multiplies alpha_i * alpha_j</span>

                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="c1"># apply template to TE/TB but not TT</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t3</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mp_i</span> <span class="o">=</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mn_i</span> <span class="o">=</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">mp_j</span> <span class="o">=</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mn_j</span> <span class="o">=</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">t1_i</span> <span class="o">=</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">t2_i</span> <span class="o">=</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">t1_j</span> <span class="o">=</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">t2_j</span> <span class="o">=</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

                    <span class="n">cls1</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mp_i</span><span class="p">,</span> <span class="n">mn_j</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mn_i</span><span class="p">,</span> <span class="n">mp_j</span><span class="p">))</span>
                        <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mn_i</span><span class="p">,</span> <span class="n">mn_j</span><span class="p">)</span>
                        <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mp_i</span><span class="p">,</span> <span class="n">mp_j</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># average template alms</span>
                    <span class="n">imt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1_i</span> <span class="o">+</span> <span class="n">t2_i</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">jmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1_j</span> <span class="o">+</span> <span class="n">t2_j</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="c1"># compute maximally symmetric cross spectra</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mn_j</span><span class="p">,</span> <span class="n">imt</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mp_j</span><span class="p">,</span> <span class="n">imt</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mn_i</span><span class="p">,</span> <span class="n">jmt</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">mp_i</span><span class="p">,</span> <span class="n">jmt</span><span class="p">)</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">t1_i</span><span class="p">,</span> <span class="n">t2_j</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">t2_i</span><span class="p">,</span> <span class="n">t1_j</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="c1"># apply template to TE/TB but not TT</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t3</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">,</span> <span class="n">jmap_alms</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">apply_template</span><span class="p">():</span>
            <span class="n">cls_clean</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cls_data_clean&quot;</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">cls_clean</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_clean</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">m0</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs_orig</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                    <span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="n">template_alpha</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)]</span>

                    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t1</span>
                    <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t2</span>
                        <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">+=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t3</span>
                            <span class="c1"># subtract average template noise spectrum to debias</span>
                            <span class="k">if</span> <span class="n">sub_hm_noise</span><span class="p">:</span>
                                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_tnoise_hm1xhm2</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                                <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_clean</span> <span class="o">=</span> <span class="n">cls_clean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="o">=</span> <span class="n">template_alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
            <span class="n">apply_template</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">save_data</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;cls_data&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_data_clean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_template&quot;</span><span class="p">,</span>
                <span class="s2">&quot;template_alpha&quot;</span><span class="p">,</span>
                <span class="s2">&quot;nside&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">fake_data_r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rname</span> <span class="o">=</span> <span class="s2">&quot;rmp</span><span class="si">{:03}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fake_data_r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rname</span> <span class="o">=</span> <span class="s2">&quot;rp</span><span class="si">{:03}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fake_data_r</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
            <span class="n">data_name</span> <span class="o">=</span> <span class="s2">&quot;data_</span><span class="si">{}</span><span class="s2">_clean_</span><span class="si">{}</span><span class="s2">_sim</span><span class="si">{:03}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">rname</span><span class="p">,</span> <span class="n">fake_data_template</span><span class="p">,</span> <span class="n">sim_index</span>
            <span class="p">)</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_xcorr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_masked_template_noise"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_template_noise">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_template_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute hm1, hm2, and hm1xhm2 template noise spectra from</span>
<span class="sd">        sim ensemble</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;template_noise&#39; checkpoint,</span>
<span class="sd">        and loads or saves a data dictionary with the following entries:</span>

<span class="sd">            cls_tnoise_hm1 : &lt;same shape as cls_data&gt;</span>
<span class="sd">            cls_tnoise_hm2 : &lt;same shape as cls_data&gt;</span>
<span class="sd">            cls_tnoise_hm1xhm2 : &lt;same shape as cls_data&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">num_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>

        <span class="n">sims_attr</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;template_noise_files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_noise_files</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;template_noise_files2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_noise_files2</span>
        <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_template_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_template_noise</span>

        <span class="c1"># convenience functions</span>
        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute alms of masked input map</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">filename</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idx2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing Alms for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing Alms for sim </span><span class="si">{}</span><span class="s2"> of map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">idx2</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;all&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_alms</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">process_files</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute cross spectra</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">hm1_field</span> <span class="o">=</span> <span class="s2">&quot;cls_tnoise_hm1&quot;</span>
            <span class="n">hm2_field</span> <span class="o">=</span> <span class="s2">&quot;cls_tnoise_hm2&quot;</span>
            <span class="n">hm1xhm2_field</span> <span class="o">=</span> <span class="s2">&quot;cls_tnoise_hm1xhm2&quot;</span>

            <span class="n">hm1_files</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;template_noise_files&quot;</span><span class="p">]</span>
            <span class="n">hm2_files</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;template_noise_files2&quot;</span><span class="p">]</span>

            <span class="n">nsim_tnoise</span> <span class="o">=</span> <span class="n">sims_attr</span><span class="p">[</span><span class="s2">&quot;num_template_noise&quot;</span><span class="p">]</span>

            <span class="n">cls_hm1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_hm2</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_hm1xhm2</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="n">hm1_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">hm2_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim_tnoise</span><span class="p">):</span>
                <span class="n">hm1_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="n">hm2_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Computing spectra </span><span class="si">{}</span><span class="s2"> for template noise sim </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">xname</span><span class="p">,</span> <span class="n">isim</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">hm1imap_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">hm1_files</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">hm1_cache</span><span class="p">)</span>
                    <span class="n">hm1jmap_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">hm1_files</span><span class="p">,</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">hm1_cache</span><span class="p">)</span>
                    <span class="n">hm2imap_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">hm2_files</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">hm2_cache</span><span class="p">)</span>
                    <span class="n">hm2jmap_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">hm2_files</span><span class="p">,</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">hm2_cache</span><span class="p">)</span>

                    <span class="n">cls1_hm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">hm1imap_alms</span><span class="p">,</span> <span class="n">hm1jmap_alms</span><span class="p">)</span>
                    <span class="n">cls1_hm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">hm2imap_alms</span><span class="p">,</span> <span class="n">hm2jmap_alms</span><span class="p">)</span>
                    <span class="n">cls1_hm1xhm2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">hm1imap_alms</span><span class="p">,</span> <span class="n">hm2jmap_alms</span><span class="p">)</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">hm2imap_alms</span><span class="p">,</span> <span class="n">hm1jmap_alms</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="n">quants</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">[</span><span class="n">cls_hm1</span><span class="p">,</span> <span class="n">cls1_hm1</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">cls_hm2</span><span class="p">,</span> <span class="n">cls1_hm2</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">cls_hm1xhm2</span><span class="p">,</span> <span class="n">cls1_hm1xhm2</span><span class="p">],</span>
                        <span class="p">]</span>
                        <span class="c1"># running average</span>
                        <span class="k">for</span> <span class="n">quant0</span><span class="p">,</span> <span class="n">quant1</span> <span class="ow">in</span> <span class="n">quants</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="n">quant0</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                <span class="n">xname</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">quant1</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                            <span class="p">)</span>
                            <span class="n">d</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">quant1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">isim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># in-place</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hm1_field</span><span class="p">,</span> <span class="n">cls_hm1</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hm2_field</span><span class="p">,</span> <span class="n">cls_hm2</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hm1xhm2_field</span><span class="p">,</span> <span class="n">cls_hm1xhm2</span><span class="p">)</span>

        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cls_tnoise_hm1&quot;</span><span class="p">,</span> <span class="s2">&quot;cls_tnoise_hm2&quot;</span><span class="p">,</span> <span class="s2">&quot;cls_tnoise_hm1xhm2&quot;</span><span class="p">]</span>

        <span class="c1">### this block is so sims with template type like</span>
        <span class="c1"># 353_100_gauss_003 can use ensemble in 353_100_gauss</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">template_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">ttype</span> <span class="o">=</span> <span class="n">template_type</span>
        <span class="k">if</span> <span class="n">tp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ttype</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;353_100&quot;</span><span class="p">,</span> <span class="s2">&quot;217_100&quot;</span><span class="p">]:</span>
                <span class="n">ttype</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;template_noise_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ttype</span><span class="p">)</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;template_noise&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="n">cp</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_tnoise_hm1&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># process template noise</span>
        <span class="n">process_files</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_kernels"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_kernels">[docs]</a>    <span class="k">def</span> <span class="nf">get_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute kernels using the mask cross-spectra.  This follows</span>
<span class="sd">        the polspice azimuthal approximation for the kernel computation.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        window_lmax : int</span>
<span class="sd">            The window within which the kernel is computed about</span>
<span class="sd">            each ell bin.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;kernels&#39; checkpoint and loads or saves</span>
<span class="sd">        the following data keys to disk:</span>

<span class="sd">            kern, pkern, mkern, xkern : (num_mask_corr, lmax+1, 2*lmax+1)</span>
<span class="sd">                Temperature and polarization kernels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">window_lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;kernels&quot;</span>
        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kern&quot;</span><span class="p">,</span> <span class="s2">&quot;pkern&quot;</span><span class="p">,</span> <span class="s2">&quot;mkern&quot;</span><span class="p">,</span> <span class="s2">&quot;xkern&quot;</span><span class="p">,</span> <span class="s2">&quot;window_lmax&quot;</span><span class="p">]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;kernels&quot;</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kern_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;kern&quot;</span><span class="p">,</span>
            <span class="n">value_ref</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;window_lmax&quot;</span><span class="p">:</span> <span class="n">window_lmax</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">kern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="n">pkern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">mkern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">xkern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pkern</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mkern</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xkern</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
        <span class="n">wls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wls</span>

        <span class="n">all_ells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
            <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_ells</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing kernels for ell </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">lmax</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># populate upper triangle</span>
            <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">all_ells</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">l2</span><span class="p">]:</span>
                <span class="n">j0</span><span class="p">,</span> <span class="n">j0_lmin</span><span class="p">,</span> <span class="n">j0_lmax</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">wigner3j</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">j2</span><span class="p">,</span> <span class="n">j2_lmin</span><span class="p">,</span> <span class="n">j2_lmax</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">wigner3j</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># only go up to window lmax</span>
                <span class="n">j0_lmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">j0_lmax</span><span class="p">,</span> <span class="n">window_lmax</span><span class="p">)</span>

                <span class="c1"># computed as in https://arxiv.org/abs/1909.09375</span>
                <span class="c1"># equations 128 - 136</span>
                <span class="n">l3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">j0_lmin</span><span class="p">,</span> <span class="n">j0_lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dl3</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">l3</span> <span class="o">+</span> <span class="mf">1.0</span>
                <span class="n">vk</span> <span class="o">=</span> <span class="n">j0</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dl3</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">ll</span> <span class="o">+</span> <span class="n">l3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">j2</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dl3</span>
                    <span class="n">vp</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">vm</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sign</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">vx</span> <span class="o">=</span> <span class="n">j2</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">*</span> <span class="n">j0</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">*</span> <span class="n">dl3</span>
                <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                    <span class="n">wls1</span> <span class="o">=</span> <span class="n">wls</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">l3</span><span class="p">]</span>
                    <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vk</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                        <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vp</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vm</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vx</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># apply symmetry relation</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_ells</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dll</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ll</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">sll</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="c1"># populate lower triangle (wigners are symmetric in l and ll)</span>
                <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                    <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                    <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                <span class="c1"># apply ell scaling along the axis that we bin over</span>
                <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>
                    <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>
                    <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>

        <span class="c1"># save and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kern</span> <span class="o">=</span> <span class="n">kern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pkern</span> <span class="o">=</span> <span class="n">pkern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mkern</span> <span class="o">=</span> <span class="n">mkern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xkern</span> <span class="o">=</span> <span class="n">xkern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_lmax</span> <span class="o">=</span> <span class="n">window_lmax</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_signal_shape"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_signal_shape">[docs]</a>    <span class="k">def</span> <span class="nf">get_signal_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">flat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">signal_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a shape spectrum for input to the Fisher iteration algorithm.</span>

<span class="sd">        If the spectrum is used as input to ``get_transfer``, it must match</span>
<span class="sd">        the spectrum used to generate the simulations, in order to compute</span>
<span class="sd">        the correct transfer function.</span>

<span class="sd">        Alternatively, the spectrum can be computed using CAMB for arbitrary</span>
<span class="sd">        values of ``r``, typically used to compute the ``r`` likelihood once</span>
<span class="sd">        the bandpowers have been computed.</span>

<span class="sd">        Finally, the spectrum can be flat in ell^2 Cl.  This is typically</span>
<span class="sd">        used as the input shape for computing bandpowers for a null test.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Filename for a spectrum on disk.  If None, and ``r`` is None and</span>
<span class="sd">            ``flat`` is False, this will search for a spectrum stored in</span>
<span class="sd">            ``signal_&lt;signal_type&gt;/spec_signal_&lt;signal_type&gt;.dat``.</span>
<span class="sd">            Otherwise, if the filename is a relative path and not found,</span>
<span class="sd">            the config directory is searched.</span>
<span class="sd">        r : float</span>
<span class="sd">            If supplied and ``flat`` is False, a spectrum is computed using</span>
<span class="sd">            CAMB for the given ``r`` value.  Overrides ``filename``.</span>
<span class="sd">        component : &#39;scalar&#39;, &#39;tensor&#39;, &#39;fg&#39;</span>
<span class="sd">            If &#39;scalar&#39;, and ``r`` is not None, return just the r=0 scalar terms</span>
<span class="sd">            in the signal model.  If &#39;tensor&#39;, return just the tensor component</span>
<span class="sd">            scaled by the input ``r`` value. If &#39;fg&#39;, return just fg term</span>
<span class="sd">        flat : float</span>
<span class="sd">            If given, a spectrum that is flat in ell^2 Cl is returned, with</span>
<span class="sd">            amplitude given by the supplied value. Overrides all other options.</span>
<span class="sd">        signal_mask: str array</span>
<span class="sd">            Include only these spectra, others set to zero.</span>
<span class="sd">            Options: TT, EE, BB, TE, EB, TB</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, this is a transfer function run. If ``filename`` is None</span>
<span class="sd">            and ``r`` is None and ``flat`` is False, will search for a spectrum</span>
<span class="sd">            stored in</span>
<span class="sd">            ``signal_&lt;signal_transfer_type&gt;/spec_signal_&lt;signal_transfer_type&gt;.dat``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls : OrderedDict</span>
<span class="sd">            Dictionary keyed by spectrum (cmb_tt, cmb_ee, ... , fg), each</span>
<span class="sd">            entry containing a vector of length 2 * lmax + 1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lmax_kern</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;eb&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;tb&quot;</span><span class="p">)</span>
        <span class="n">tbeb</span> <span class="o">=</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">specs</span> <span class="ow">and</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">specs</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="ow">and</span> <span class="s2">&quot;fg_tt&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
            <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;fg&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span>

        <span class="n">nspecs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nspecs</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;shape_transfer&quot;</span> <span class="k">if</span> <span class="n">transfer</span> <span class="k">else</span> <span class="s2">&quot;shape&quot;</span>

            <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span>
                <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span>
                <span class="n">signal_mask</span><span class="o">=</span><span class="n">signal_mask</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">save_name</span><span class="p">,</span> <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;r_model&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">]</span>

        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ellfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">cls_shape</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flat</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">flat</span> <span class="o">=</span> <span class="mf">2e-5</span>
            <span class="c1"># flat spectrum for null tests</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">cls_shape</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ell</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># cache model components</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;r_model&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># scalar CAMB spectrum</span>
                <span class="n">scal</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">get_camb_cl</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax_kern</span><span class="p">)</span>
                <span class="c1"># tensor CAMB spectrum for r=1, scales linearly with r</span>
                <span class="n">tens</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">get_camb_cl</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax_kern</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="s2">&quot;tensor&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;scalar&quot;</span><span class="p">:</span> <span class="n">scal</span><span class="p">,</span> <span class="s2">&quot;tensor&quot;</span><span class="p">:</span> <span class="n">tens</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                    <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;r_model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span>
            <span class="c1"># CAMB spectrum for given r value</span>
            <span class="n">component</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;scalar&quot;</span><span class="p">:</span>
                <span class="n">cls_camb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;tensor&quot;</span><span class="p">:</span>
                <span class="n">cls_camb</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;tensor&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls_camb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;tensor&quot;</span><span class="p">]</span>
            <span class="n">ns</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cls_camb</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">[:</span><span class="n">ns</span><span class="p">]):</span>
                <span class="n">cls_shape</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_camb</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;cmb&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">]):</span>
            <span class="c1"># signal sim model or custom filename</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">signal_root</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_root</span> <span class="k">if</span> <span class="n">transfer</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_root</span>
                <span class="p">)</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;spec_</span><span class="si">{}</span><span class="s2">.dat&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">signal_root</span><span class="p">))</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">signal_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing model file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">ltmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ltmp</span><span class="p">:</span>
                <span class="n">ltmp</span> <span class="o">=</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Require at least lmax=</span><span class="si">{}</span><span class="s2"> in model file, found </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">lmax_kern</span><span class="p">,</span> <span class="n">ltmp</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># camb starts at l=2, so set first 2 ells to be 0</span>
            <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_tt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span> <span class="n">ltmp</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span> <span class="n">ltmp</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># this is true if TE is the third index instead of EE</span>
                    <span class="c1"># (ell is 0th index for CAMB)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Old CAMB format in model file </span><span class="si">{}</span><span class="s2">. Re-indexing.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">filename</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">pol_specs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pol_specs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="n">pol_specs</span><span class="p">]):</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[:</span> <span class="n">ltmp</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>

        <span class="c1"># EB and TB flat l^2 * C_l</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="n">tbeb</span> <span class="ow">and</span> <span class="p">(</span><span class="n">flat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">flat</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">tbeb_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">][</span><span class="mi">100</span><span class="p">])</span> <span class="o">*</span> <span class="n">ellfac</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-4</span>
            <span class="n">tbeb_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">tbeb_flat</span>
            <span class="n">tbeb_flat</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tbeb_flat</span><span class="p">)</span>
            <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tbeb_flat</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
            <span class="c1"># From Planck LIV EE dust</span>
            <span class="n">cls_dust</span> <span class="o">=</span> <span class="mf">34.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mf">80.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.28</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cls_dust</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Added foreground to cls shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">)),</span> <span class="s2">&quot;debug&quot;</span>
            <span class="p">)</span>

        <span class="c1"># divide out l^2/2pi</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
            <span class="n">cls_shape</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span> <span class="o">/=</span> <span class="n">ellfac</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">cls_shape</span><span class="p">[</span><span class="n">spec</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">signal_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Masking </span><span class="si">{}</span><span class="s2"> spectra&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_mask</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">csk</span> <span class="ow">in</span> <span class="n">cls_shape</span><span class="p">:</span>
                <span class="n">masked</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">smk</span> <span class="ow">in</span> <span class="n">signal_mask</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">smk</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">csk</span><span class="p">:</span>
                        <span class="n">masked</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="n">csk</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0e-12</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span> <span class="o">=</span> <span class="n">cls_shape</span>
            <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls_shape</span></div>

<div class="viewcode-block" id="XFaster.get_beams"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_beams">[docs]</a>    <span class="k">def</span> <span class="nf">get_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixwin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return beam window functions for all input map tags.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        pixwin : bool</span>
<span class="sd">            If True, the pixel window function for the map ``nside`` is</span>
<span class="sd">            applied to the Gaussian beams.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        beam_windows : dict</span>
<span class="sd">            A dictionary of beam window function arrays</span>
<span class="sd">            (3 x lmax+1 if pol, 1 x lmax+1 if not) for each map tag</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;beams&#39; checkpoint and loads or saves</span>
<span class="sd">        a dictionary containing just the ``beam_windows`` key to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">lsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="mi">6</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">beam_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">*</span> <span class="n">nspec</span><span class="p">,</span> <span class="n">lsize</span><span class="p">)</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;beams&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;beams&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_windows&quot;</span><span class="p">],</span> <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">beam_shape</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;beam_windows&quot;</span><span class="p">]</span>

        <span class="n">beam_windows</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                <span class="n">beam_windows</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">pwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lsize</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">pixwin</span><span class="p">:</span>
            <span class="n">pwl</span> <span class="o">*=</span> <span class="mf">0.0</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pixwin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="n">pixT</span> <span class="o">=</span> <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pixP</span> <span class="o">=</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixT</span><span class="p">),</span> <span class="n">lsize</span><span class="p">)</span>
                <span class="n">pwl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixP</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">pwl</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pixT</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span> <span class="o">*</span> <span class="n">pixP</span><span class="p">[:</span><span class="n">end</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pixT</span> <span class="o">=</span> <span class="n">pix</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixT</span><span class="p">),</span> <span class="n">lsize</span><span class="p">)</span>
            <span class="n">pwl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixT</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">otag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">:</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">[</span><span class="n">otag</span><span class="p">])[:,</span> <span class="p">:</span><span class="n">lsize</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">:</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">gauss_beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">[</span><span class="n">otag</span><span class="p">],</span> <span class="n">lsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">bl</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No beam in config for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>

            <span class="n">blpw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bl</span> <span class="o">*</span> <span class="n">pwl</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">lsize</span><span class="p">]</span>
            <span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">blpw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_windows</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">blpw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_windows</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">blpw</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># save and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span> <span class="o">=</span> <span class="n">beam_windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_windows&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span></div>

<div class="viewcode-block" id="XFaster.get_beam_errors"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_beam_errors">[docs]</a>    <span class="k">def</span> <span class="nf">get_beam_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get error envelope to multiply beam by (so, to get beam + 2 sigma error,</span>
<span class="sd">        do beam * (1 + 2 * beam_error))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="mi">6</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">beam_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">*</span> <span class="n">nspec</span><span class="p">,</span> <span class="n">lsize</span><span class="p">)</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;beam_errors&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;beam_errors&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;beam_errors&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_errors</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_errors&quot;</span><span class="p">],</span> <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">beam_shape</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;beam_errors&quot;</span><span class="p">]</span>

        <span class="n">beam_errors</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">beam_errors</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                <span class="n">beam_errors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">otag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">:</span>
                <span class="n">be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">[</span><span class="n">otag</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">:</span>
                <span class="c1"># convert error on the FWHM to an envelope error on the beam window</span>
                <span class="n">fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">[</span><span class="n">otag</span><span class="p">]</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>
                <span class="n">blp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">gauss_beam</span><span class="p">(</span>
                    <span class="n">fwhm</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">[</span><span class="n">otag</span><span class="p">]),</span> <span class="n">lsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
                <span class="p">)</span>
                <span class="n">blm</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">gauss_beam</span><span class="p">(</span>
                    <span class="n">fwhm</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">[</span><span class="n">otag</span><span class="p">]),</span> <span class="n">lsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">bl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]]</span>
                    <span class="p">)</span>
                    <span class="n">blp</span> <span class="o">=</span> <span class="n">blp</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
                    <span class="n">blm</span> <span class="o">=</span> <span class="n">blm</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
                <span class="n">be</span> <span class="o">=</span> <span class="p">(</span><span class="n">blp</span> <span class="o">-</span> <span class="n">blm</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">bl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No beam in config for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">otag</span><span class="p">))</span>

            <span class="n">be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">be</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">lsize</span><span class="p">]</span>
            <span class="n">beam_errors</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">be</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_errors</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">be</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_errors</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">be</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># save and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_errors</span> <span class="o">=</span> <span class="n">beam_errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_errors&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_errors</span></div>

<div class="viewcode-block" id="XFaster.get_bin_def"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_bin_def">[docs]</a>    <span class="k">def</span> <span class="nf">get_bin_def</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bin_width</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">tbeb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">foreground_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bin_width_fg</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">residual_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">res_specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bin_width_res</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">weighted_bins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the bin definition array that defines the bins for each output</span>
<span class="sd">        spectrum.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        bin_width : int or list of ints</span>
<span class="sd">            Width of each spectrum bin.  If a scalar, the same width is applied</span>
<span class="sd">            to all cross spectra.  Otherwise, must be a list of up to six</span>
<span class="sd">            elements, listing bin widths for the spectra in the order (TT, EE,</span>
<span class="sd">            BB, TE, EB, TB).</span>
<span class="sd">        lmin : int</span>
<span class="sd">            Minimum ell for binned spectra</span>
<span class="sd">        tbeb : bool</span>
<span class="sd">            If True, EB and TB bins are constructed so that these spectra are</span>
<span class="sd">            computed by the estimator.  Otherwise, these spectra are fixed at</span>
<span class="sd">            zero.</span>
<span class="sd">        foreground_fit : bool</span>
<span class="sd">            If True, construct bin definitions for foreground components as</span>
<span class="sd">            well.</span>
<span class="sd">        bin_width_fg : int or list of ints</span>
<span class="sd">            Width of each foreground spectrum bin.  If a scalar, the same width</span>
<span class="sd">            is applied to all cross spectra.  Otherwise, must be a list of up to</span>
<span class="sd">            six elements, listing bin widths for the spectra in the order (TT,</span>
<span class="sd">            EE, BB, TE, EB, TB).</span>
<span class="sd">        residual_fit : bool</span>
<span class="sd">            If True, fit for (compute bandpower amplitudes for) several wide</span>
<span class="sd">            bins of excess noise.</span>
<span class="sd">        res_specs : list of strings</span>
<span class="sd">            List of spectra which are to be included in the residual fit.  Can</span>
<span class="sd">            be individual spectra (&#39;tt&#39;, &#39;ee&#39;, &#39;bb&#39;), or &#39;eebb&#39; to fit for EE</span>
<span class="sd">            and BB residuals simultaneously.  If not supplied, this defaults to</span>
<span class="sd">            [&#39;eebb&#39;] for polarized maps, and [&#39;tt&#39;] for unpolarized maps.</span>
<span class="sd">        bin_width_res : int or list of ints</span>
<span class="sd">            Width of each residual spectrum bin.  If a scalar, the same width</span>
<span class="sd">            is applied to all spectra for all cross spectra.  Otherwise, must</span>
<span class="sd">            be a list of up to nspec * nmaps elements, listing bin widths for</span>
<span class="sd">            each of the spectra in ``res_specs`` in order, then ordered by map.</span>
<span class="sd">        weighted_bins : bool</span>
<span class="sd">            If True, use an lfac-weighted binning operator to construct Cbls.</span>
<span class="sd">            By default, a flat binning operator is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bin_def : dict</span>
<span class="sd">            The bin definition dictionary.  Each key contains a Nx2 array</span>
<span class="sd">            that defines the left and right edges for each bin of the</span>
<span class="sd">            corresponding spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npol</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="k">if</span> <span class="n">tbeb</span> <span class="k">else</span> <span class="mi">4</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">,</span> <span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">][:</span><span class="n">npol</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_width</span><span class="p">):</span>
            <span class="n">bin_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_width</span><span class="p">]</span> <span class="o">*</span> <span class="n">npol</span>
        <span class="n">bin_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_width</span><span class="p">)[:</span><span class="n">npol</span><span class="p">]</span>

        <span class="n">bwerr</span> <span class="o">=</span> <span class="s2">&quot;EE and BB must have the same bin width (for mixing)&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="n">bin_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bin_width</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">bwerr</span><span class="p">)</span>

        <span class="c1"># Define bins</span>
        <span class="n">nbins_cmb</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bin_def</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">bw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">nbins_cmb</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Added </span><span class="si">{}</span><span class="s2"> CMB bins to bin_def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbins_cmb</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="c1"># Do the same for foreground bins</span>
        <span class="n">nbins_fg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">foreground_fit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_width_fg</span><span class="p">):</span>
                <span class="n">bin_width_fg</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_width_fg</span><span class="p">]</span> <span class="o">*</span> <span class="n">npol</span>
            <span class="n">bin_width_fg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_width_fg</span><span class="p">)[:</span><span class="n">npol</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="n">bin_width_fg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bin_width_fg</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Foreground </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bwerr</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">bw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">bin_width_fg</span><span class="p">):</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="n">nbins_fg</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Added </span><span class="si">{}</span><span class="s2"> foreground bins to bin_def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbins_fg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Do the same for residual bins</span>
        <span class="n">nbins_res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">residual_fit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res_specs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res_specs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;eebb&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">]</span>
            <span class="n">res_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res_specs</span><span class="p">]</span>
            <span class="n">nmap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">)</span>
            <span class="n">nspecr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_specs</span><span class="p">)</span> <span class="o">*</span> <span class="n">nmap</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">):</span>
                <span class="n">bin_width_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_width_res</span><span class="p">]</span> <span class="o">*</span> <span class="n">nspecr</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">)</span> <span class="o">==</span> <span class="n">nspecr</span> <span class="o">//</span> <span class="n">nmap</span><span class="p">:</span>
                <span class="n">bin_width_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bin_width_res</span><span class="p">]</span> <span class="o">*</span> <span class="n">nmap</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">bin_width_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">)[:</span><span class="n">nspecr</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">bws</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">bin_width_res</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="s2">&quot;ee&quot;</span> <span class="ow">in</span> <span class="n">res_specs</span> <span class="ow">and</span> <span class="s2">&quot;bb&quot;</span> <span class="ow">in</span> <span class="n">res_specs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bws</span><span class="p">[</span><span class="n">res_specs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ee&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">bws</span><span class="p">[</span><span class="n">res_specs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;bb&quot;</span><span class="p">)]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Residual </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">bwerr</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">bw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">res_specs</span><span class="p">,</span> <span class="n">bws</span><span class="p">):</span>
                    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">btag</span> <span class="o">=</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
                    <span class="n">bin_def</span><span class="p">[</span><span class="n">btag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                    <span class="n">nbins_res</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Added </span><span class="si">{}</span><span class="s2"> residual bins to bin_def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbins_res</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">lfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">bin_weights</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="n">bin_def</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">bin_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">bd</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weighted_bins</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">lfac</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lfac</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">bin_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="o">=</span> <span class="n">lmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_cmb</span> <span class="o">=</span> <span class="n">nbins_cmb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_fg</span> <span class="o">=</span> <span class="n">nbins_fg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">=</span> <span class="n">nbins_res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span> <span class="o">=</span> <span class="n">bin_def</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span> <span class="o">=</span> <span class="n">weighted_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span> <span class="o">=</span> <span class="n">bin_weights</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span></div>

<div class="viewcode-block" id="XFaster.kernel_precalc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.kernel_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">kernel_precalc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the mixing kernels M_ll&#39; = K_ll&#39; * F_l&#39; * B_l&#39;^2.  Called by</span>
<span class="sd">        ``bin_cl_template`` to pre-compute kernel terms.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If supplied, the kernels are computed only for the given map tag</span>
<span class="sd">            (or cross if map_tag is map_tag1:map_tag2).</span>
<span class="sd">            Otherwise, it is computed for all maps and crosses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mll : OrderedDict</span>
<span class="sd">            Dictionary of M_ll&#39; matrices, keyed by spec and xname.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="n">map_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="n">map_tag</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]}</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_tag</span><span class="p">]</span>
                <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
            <span class="n">map_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>  <span class="c1"># 2 * lmax</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="c1"># expand transfer function terms</span>
            <span class="n">transfer</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">transfer</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">map_tags</span><span class="p">:</span>
                    <span class="n">transfer</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">expand_qb</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">tag</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

        <span class="n">lk</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
            <span class="n">mll</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                <span class="n">mspec</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_mix&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="n">mll</span><span class="p">[</span><span class="n">mspec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># beams</span>
                <span class="n">fb2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">m0</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">m1</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span>

                <span class="c1"># transfer function</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
                    <span class="n">fb2</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">transfer</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">m0</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span> <span class="o">*</span> <span class="n">transfer</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">m1</span><span class="p">][</span><span class="n">lk</span><span class="p">])</span>

                <span class="c1"># kernels</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                    <span class="n">mk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;eb&quot;</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>

                <span class="c1"># store final product</span>
                <span class="n">mll</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">fb2</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">mll</span><span class="p">[</span><span class="n">mspec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mk</span> <span class="o">*</span> <span class="n">fb2</span>

        <span class="k">return</span> <span class="n">mll</span></div>

<div class="viewcode-block" id="XFaster.bin_cl_template"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.bin_cl_template">[docs]</a>    <span class="k">def</span> <span class="nf">bin_cl_template</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cls_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">beam_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_precalc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fg_ell_ind</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Cbl matrix from the input shape spectrum.</span>

<span class="sd">        This method requires beam windows, kernels and transfer functions</span>
<span class="sd">        (if ``transfer_run`` is False) to have been precomputed.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cls_shape : array_like</span>
<span class="sd">            The shape spectrum to use.  This can be computed using</span>
<span class="sd">            ``get_signal_shape`` or otherwise.</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If supplied, the Cbl is computed only for the given map tag</span>
<span class="sd">            (or cross if map_tag is map_tag1:map_tag2).</span>
<span class="sd">            Otherwise, it is computed for all maps and crosses.</span>
<span class="sd">        transfer_run : bool</span>
<span class="sd">            If True, this assumes a unity transfer function for all bins, and</span>
<span class="sd">            the output Cbl is used to compute the transfer functions that are</span>
<span class="sd">            then loaded when this method is called with ``transfer_run = False``.</span>
<span class="sd">        beam_error : bool</span>
<span class="sd">            If True, use beam error envelope instead of beam to get cbls that</span>
<span class="sd">            are 1 sigma beam error envelope offset of signal terms.</span>
<span class="sd">        use_precalc : bool</span>
<span class="sd">            If True, load pre-calculated terms stored from a previous iteration,</span>
<span class="sd">            and store for a future iteration.  Otherwise, all calculations are</span>
<span class="sd">            repeated.</span>
<span class="sd">        fg_ell_ind : float</span>
<span class="sd">            If binning foreground shape, offset the ell index from the reference</span>
<span class="sd">            by this amount.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cbl : dict of arrays (num_bins, 2, lmax + 1)</span>
<span class="sd">            The Cbl matrix, indexed by component and spectrum, then by map</span>
<span class="sd">            cross, e.g. ``cbl[&#39;cmb_tt&#39;][&#39;map1:map2&#39;]``.  E/B mixing terms are</span>
<span class="sd">            stored in elements ``cbl[&#39;cmb_ee_mix&#39;]`` and ``cbl[&#39;cmb_bb_mix&#39;]``,</span>
<span class="sd">            and unmixed terms are stored in elements ``cbl[&#39;cmb_ee&#39;]`` and</span>
<span class="sd">            ``cbl[&#39;cmb_bb&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cls_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cls_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="n">map_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="n">map_tag</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]}</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_tag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>

        <span class="k">if</span> <span class="n">map_pairs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;eb&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;tb&quot;</span><span class="p">)</span>

        <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
        <span class="n">lmax_kern</span> <span class="o">=</span> <span class="n">lmax</span>  <span class="c1"># 2 * self.lmax</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;mll&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_precalc</span><span class="p">:</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_precalc</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="n">transfer_run</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_precalc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mll</span>

        <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
            <span class="n">beam_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_beam_errors</span><span class="p">()</span>
            <span class="n">beam_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">,</span> <span class="s2">&quot;b2&quot;</span><span class="p">,</span> <span class="s2">&quot;b3&quot;</span><span class="p">]</span>

        <span class="n">ls</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">lk</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cbl</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s2">&quot;cmb_tt&quot;</span> <span class="ow">in</span> <span class="n">cls_shape</span> <span class="ow">or</span> <span class="s2">&quot;cmb_ee&quot;</span> <span class="ow">in</span> <span class="n">cls_shape</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">cls_shape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span>
            <span class="n">cls_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span>
            <span class="n">cls_noise0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise0_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise0</span>
            <span class="n">cls_noise1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise1_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise1</span>
            <span class="n">cls_sxn0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sxn0_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sxn0</span>
            <span class="n">cls_sxn1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sxn1_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sxn1</span>
            <span class="n">cls_nxs0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_nxs0_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_nxs0</span>
            <span class="n">cls_nxs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_nxs1_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_nxs1</span>

        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">binup</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">bin_things</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">md</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                <span class="n">cbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">stag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                <span class="n">mstag</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">mstag</span> <span class="o">=</span> <span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span>
                    <span class="n">cbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">mstag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">tag1</span><span class="p">,</span> <span class="n">tag2</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                        <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                            <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                            <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                                <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># integrate per bin</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">weights</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">:</span>
                                <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">binup</span><span class="p">(</span>
                                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">weights</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">binup</span><span class="p">(</span>
                                <span class="n">d</span><span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">weights</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">:</span>
                                    <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">binup</span><span class="p">(</span>
                                        <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">si</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">weights</span>
                                    <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">binup</span><span class="p">(</span>
                                    <span class="n">md</span><span class="p">[</span><span class="n">si</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">weights</span>
                                <span class="p">)</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="c1"># convert to matrices to do multiplication to speed things up,</span>
            <span class="c1"># except for res is weird so don&#39;t do it for that.</span>
            <span class="c1"># need n_xname x n_spec x ell</span>
            <span class="n">nspec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
            <span class="n">nxmap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">and</span> <span class="n">fg_ell_ind</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s_arr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ell</span> <span class="o">/</span> <span class="mf">80.0</span><span class="p">)</span> <span class="o">**</span> <span class="n">fg_ell_ind</span>
                <span class="n">s_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">beam_error</span><span class="p">:</span>
                    <span class="c1"># don&#39;t create a new object in memory each time</span>
                    <span class="c1"># use last one&#39;s space to save runtime</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_fg</span><span class="p">,</span> <span class="n">s_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">md</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">md_fg</span><span class="p">,</span> <span class="n">s_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;md&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">md</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_fg</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">s_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_fg</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">s_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">bin_things</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">kshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">nspec</span><span class="p">,</span> <span class="n">nxmap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">mkshape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">kshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kshape</span><span class="p">)</span>
                <span class="n">mk_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mkshape</span><span class="p">)</span>

                <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">nspec</span><span class="p">,</span> <span class="n">nxmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">s_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                    <span class="n">b_arr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">}</span>

                <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="n">mstag</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="o">!=</span> <span class="s2">&quot;res&quot;</span> <span class="ow">and</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="n">mstag</span> <span class="o">=</span> <span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span>

                    <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">tag1</span><span class="p">,</span> <span class="n">tag2</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                        <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                            <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">spec</span>
                            <span class="n">res_tags</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="s2">&quot;s0m0&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                                <span class="s2">&quot;s0m1&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                                <span class="s2">&quot;s1m0&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                                <span class="s2">&quot;s1m1&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                            <span class="p">}</span>
                            <span class="n">bd</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                            <span class="c1"># if any component of XY spec is in residual bin</span>
                            <span class="c1"># def, use that bin def</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res_tags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">spec0</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">spec0</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                                        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">spec0</span><span class="p">,</span> <span class="s2">&quot;eebb&quot;</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
                                            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">[</span>
                                <span class="p">(</span><span class="s2">&quot;res0_nxn&quot;</span><span class="p">,</span> <span class="n">cls_noise0</span><span class="p">),</span>
                                <span class="p">(</span><span class="s2">&quot;res1_nxn&quot;</span><span class="p">,</span> <span class="n">cls_noise1</span><span class="p">),</span>
                                <span class="p">(</span><span class="s2">&quot;res0_sxn&quot;</span><span class="p">,</span> <span class="n">cls_sxn0</span><span class="p">),</span>
                                <span class="p">(</span><span class="s2">&quot;res1_sxn&quot;</span><span class="p">,</span> <span class="n">cls_sxn1</span><span class="p">),</span>
                                <span class="p">(</span><span class="s2">&quot;res0_nxs&quot;</span><span class="p">,</span> <span class="n">cls_nxs0</span><span class="p">),</span>
                                <span class="p">(</span><span class="s2">&quot;res1_nxs&quot;</span><span class="p">,</span> <span class="n">cls_nxs1</span><span class="p">),</span>
                                <span class="p">(</span><span class="s2">&quot;res&quot;</span><span class="p">,</span> <span class="n">cls_noise</span><span class="p">),</span>
                            <span class="p">]:</span>
                                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                                <span class="n">cbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">stag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                                <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                                <span class="n">cl1</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
                                    <span class="n">lls</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                                    <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="n">lls</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cl1</span><span class="p">[</span><span class="n">lls</span><span class="p">])</span>

                            <span class="k">continue</span>

                        <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                            <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">beam_error</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">tag1</span><span class="p">]</span>
                            <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b2&quot;</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">beam_error</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">tag2</span><span class="p">]</span>
                            <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b3&quot;</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">*</span> <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b2&quot;</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span>
                            <span class="p">)</span>

                        <span class="c1"># use correct shape spectrum</span>
                        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
                            <span class="c1"># single foreground spectrum</span>
                            <span class="n">s_arr</span> <span class="o">=</span> <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">/</span> <span class="mf">80.0</span><span class="p">)</span> <span class="o">**</span> <span class="n">fg_ell_ind</span>
                            <span class="n">s_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">s_arr</span><span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">lk</span><span class="p">]</span>

                        <span class="c1"># get cross spectrum kernel terms</span>
                        <span class="n">k_arr</span><span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">ls</span><span class="p">,</span> <span class="n">lk</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">mspec</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span>
                            <span class="n">mk_arr</span><span class="p">[</span><span class="n">si</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="n">mspec</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">ls</span><span class="p">,</span> <span class="n">lk</span><span class="p">]</span>

                <span class="n">md</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">s_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">s_arr_md</span> <span class="o">=</span> <span class="n">s_arr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s_arr_md</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">k_arr</span> <span class="o">*</span> <span class="n">s_arr</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">md</span> <span class="o">=</span> <span class="n">mk_arr</span> <span class="o">*</span> <span class="n">s_arr_md</span>
                <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">b_arr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                        <span class="n">md</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">md</span> <span class="o">*</span> <span class="n">b_arr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">d_fg</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">md_fg</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>

                <span class="n">bin_things</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">md</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cbl</span></div>

<div class="viewcode-block" id="XFaster.get_model_spectra"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_model_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_model_spectra</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute unbinned model spectra from qb amplitudes and a Cbl matrix.</span>
<span class="sd">        Requires pre-loaded bin definitions using ``get_bin_def`` or</span>
<span class="sd">        ``get_transfer``.</span>

<span class="sd">        This method is used internally by ``fisher_calc``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : dict of arrays</span>
<span class="sd">            Array of bandpowers for every spectrum bin.</span>
<span class="sd">        cbl : dict</span>
<span class="sd">            Cbl dict as computed by ``bin_cl_template``.</span>
<span class="sd">        delta : bool</span>
<span class="sd">            If True, evaluate the foreground model at the spectral</span>
<span class="sd">            index offset by qb[&#39;delta_beta&#39;]</span>
<span class="sd">        res : bool</span>
<span class="sd">            If True, include the residual noise model terms.</span>
<span class="sd">        cls_noise : OrderedDict</span>
<span class="sd">            If supplied, the noise spectrum is applied to the model spectrum.</span>
<span class="sd">        cond_noise : float</span>
<span class="sd">            Conditioning noise amplitude to add to TT, EE and BB autospectra,</span>
<span class="sd">            to improve convergence of the fisher iterations.  The noise model</span>
<span class="sd">            is constant cond_noise for EE, BB and 10x that for TT.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls : dict of arrays</span>
<span class="sd">            Model spectra.  Keyed by spectrum type, e.g. &#39;total_xx&#39; for the</span>
<span class="sd">            total model spectrom, &#39;fg_xx&#39; for the foreground terms, &#39;res_xx&#39; for</span>
<span class="sd">            the residual (noise) terms, where &#39;xx&#39; is one of the six power</span>
<span class="sd">            spectrum components (tt, ee, bb, te, eb, tb).  Each entry in the</span>
<span class="sd">            dictionary is itself a dictionary keyed by map cross, e.g.</span>
<span class="sd">            &#39;map1:map1&#39; for an autospectrum term, &#39;map1:map2&#39; for a cross</span>
<span class="sd">            spectrum, etc, and the map names are the same as those in the</span>
<span class="sd">            ``map_tags`` attribute.  Each individual spectrum is an array of</span>
<span class="sd">            length ``lmax + 1``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;cmb_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">]):</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>

        <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
            <span class="c1"># Evaluate fg at spectral index pivot for derivative</span>
            <span class="c1"># in Fisher matrix, unless delta is True</span>
            <span class="k">if</span> <span class="n">delta</span><span class="p">:</span>
                <span class="n">delta_beta</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">res</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">]):</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;noise&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cond_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cls_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cond_noise</span>
            <span class="n">cls_cond</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">comps</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one model component&quot;</span><span class="p">)</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                <span class="c1"># Don&#39;t add entries that won&#39;t be filled in later</span>
                <span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                <span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">mstag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;noise&quot;</span><span class="p">:</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;cond&quot;</span><span class="p">:</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">)</span>  <span class="c1"># list(cbl[stag])</span>

                <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                    <span class="n">tag1</span><span class="p">,</span> <span class="n">tag2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>

                    <span class="c1"># extract qb&#39;s for the component spectrum</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;cmb&quot;</span><span class="p">:</span>
                        <span class="n">qbs</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">qbm</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="n">mstag</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
                        <span class="c1"># frequency scaling for foreground model</span>
                        <span class="c1"># I don&#39;t remember why delta beta was done this way.</span>
                        <span class="c1"># For likelihood, it makes sense to just use beta_ref+db</span>
                        <span class="n">freq_scale</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">scale_dust</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">[</span><span class="n">tag1</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">[</span><span class="n">tag2</span><span class="p">],</span>
                            <span class="n">ref_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_freq</span><span class="p">,</span>
                            <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
                            <span class="n">delta_beta</span><span class="o">=</span><span class="n">delta_beta</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">qbs</span> <span class="o">=</span> <span class="n">freq_scale</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">qbm</span> <span class="o">=</span> <span class="n">freq_scale</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="n">mstag</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span>
                        <span class="c1"># modify model by previously fit res, including</span>
                        <span class="c1"># off diagonals and SXN/NXS for nulls</span>
                        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">spec</span>  <span class="c1"># separate qbs for, eg, TE resTT and resEE</span>
                        <span class="n">res_tags</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;s0m0&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                            <span class="s2">&quot;s0m1&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                            <span class="s2">&quot;s1m0&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                            <span class="s2">&quot;s1m1&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                        <span class="p">}</span>
                        <span class="n">qbr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s0m0&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s0m1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s1m0&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s1m1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res_tags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">spec0</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">spec0</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                                    <span class="n">res_tags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">spec0</span><span class="p">,</span> <span class="s2">&quot;eebb&quot;</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">res_tags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                                        <span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="n">res_tags</span><span class="p">[</span><span class="n">k</span><span class="p">]])[:,</span> <span class="kc">None</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="n">v</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>

                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">])):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                    <span class="s2">&quot;Unphysical residuals fit, &quot;</span>
                                    <span class="s2">&quot;setting to zero </span><span class="si">{}</span><span class="s2"> bins </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">spec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="n">cl1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cl1</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span> <span class="ow">in</span> <span class="p">[</span>
                            <span class="p">(</span>
                                <span class="s2">&quot;s0m0&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;s1m1&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;res0_nxn_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span>
                            <span class="p">),</span>  <span class="c1"># N_s0m0 x N_s1m1</span>
                            <span class="p">(</span>
                                <span class="s2">&quot;s1m0&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;s0m1&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;res1_nxn_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span>
                            <span class="p">),</span>  <span class="c1"># N_s1m0 x N_s0m1</span>
                        <span class="p">]:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="n">qbr</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qbr</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="n">cl1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">cbl</span><span class="p">[</span><span class="n">k3</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k3</span> <span class="ow">in</span> <span class="p">[</span>
                                <span class="p">(</span><span class="s2">&quot;s1m1&quot;</span><span class="p">,</span> <span class="s2">&quot;res0_sxn_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)),</span>  <span class="c1"># S_s0m0 x N_s1m1</span>
                                <span class="p">(</span><span class="s2">&quot;s0m1&quot;</span><span class="p">,</span> <span class="s2">&quot;res1_sxn_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)),</span>  <span class="c1"># S_s1m0 x N_s0m1</span>
                                <span class="p">(</span><span class="s2">&quot;s0m0&quot;</span><span class="p">,</span> <span class="s2">&quot;res0_nxs_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)),</span>  <span class="c1"># N_s0m0 x S_s1m1</span>
                                <span class="p">(</span><span class="s2">&quot;s1m0&quot;</span><span class="p">,</span> <span class="s2">&quot;res1_nxs_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)),</span>  <span class="c1"># N_s1m0 x S_s0m1</span>
                            <span class="p">]:</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="n">qbr</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                                <span class="n">cl1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">cbl</span><span class="p">[</span><span class="n">k3</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># all of these were asymmetric specs, divide by 2 for mean</span>
                        <span class="n">cl1</span> <span class="o">/=</span> <span class="mf">2.0</span>

                    <span class="c1"># compute model spectra</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;fg&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="n">cbl1</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbl1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="c1"># has beam error terms. deal with them individually</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cbl1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">cl1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">qbs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="p">(</span><span class="n">qbs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">cbl1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="c1"># mixing terms, add in-place</span>
                            <span class="k">if</span> <span class="n">qbm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mstag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                                <span class="n">cbl1_mix</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbl1_mix</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cbl1_mix</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                        <span class="n">cl1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">qbm</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">cl1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">qbm</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">cbl1_mix</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;noise&quot;</span><span class="p">:</span>
                        <span class="n">cl1</span> <span class="o">=</span> <span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">][:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;cond&quot;</span><span class="p">:</span>
                        <span class="c1"># add conditioner along diagonal</span>
                        <span class="k">if</span> <span class="n">tag1</span> <span class="o">!=</span> <span class="n">tag2</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">cls_cond</span>
                        <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="n">cls_cond</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="c1"># store</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">stag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl1</span>

                    <span class="c1"># add to total model</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cl1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">ttag</span> <span class="o">=</span> <span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                        <span class="bp">cls</span><span class="p">[</span><span class="n">ttag</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cl1</span><span class="p">))</span>
                        <span class="bp">cls</span><span class="p">[</span><span class="n">ttag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cl1</span>

        <span class="k">return</span> <span class="bp">cls</span></div>

<div class="viewcode-block" id="XFaster.get_data_spectra"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_data_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_data_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data and noise spectra for the given map tag(s).  Data spectra</span>
<span class="sd">        and signal/noise sim spectra must have been precomputed or loaded from</span>
<span class="sd">        disk.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If None, all map-map cross-spectra are included in the outputs.</span>
<span class="sd">            Otherwise, only the autospectra of the given map are included.</span>
<span class="sd">        transfer_run : bool</span>
<span class="sd">            If True, the data cls are the average of the signal simulations, and</span>
<span class="sd">            noise cls are ignored.  If False, the data cls are either</span>
<span class="sd">            ``cls_data_null`` (for null tests) or ``cls_data``.  See</span>
<span class="sd">            ``get_masked_data`` for how these are computed.  The input noise is</span>
<span class="sd">            similarly either ``cls_noise_null`` or ``cls_noise``.</span>
<span class="sd">        do_noise : bool</span>
<span class="sd">            If True, return noise spectra along with data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obs : OrderedDict</span>
<span class="sd">            Dictionary of data cross spectra</span>
<span class="sd">        nell : OrderedDict</span>
<span class="sd">            Dictionary of noise cross spectra, or None if transfer_run is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># select map pairs</span>
        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_tag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>

        <span class="c1"># select spectra</span>
        <span class="n">tbeb</span> <span class="o">=</span> <span class="s2">&quot;cmb_tb&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span>
        <span class="k">if</span> <span class="n">transfer_run</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">tbeb</span><span class="p">:</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span>

        <span class="c1"># obs depends on what you&#39;re computing</span>
        <span class="k">if</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span><span class="p">:</span>
                <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_sub_null</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span><span class="p">:</span>
            <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_clean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span>

        <span class="c1"># in case we&#39;re excluding some spectra or maps, repopulate obs dict</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
            <span class="n">obs</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="p">:</span>
                <span class="n">obs</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_quant</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_noise</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obs</span>

        <span class="n">nell</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">debias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Nulls are debiased by average of S+N sims</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">debias</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">m0</span> <span class="o">!=</span> <span class="n">m1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span><span class="p">:</span>
                            <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">planck_sub</span><span class="p">:</span>
                            <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="p">)</span>

        <span class="c1"># Non-nulls are debiased by average of N sims</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">transfer_run</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">debias</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">m0</span> <span class="o">!=</span> <span class="n">m1</span><span class="p">:</span>
                        <span class="c1"># set non-auto noise to 0-- don&#39;t care to fit cross</span>
                        <span class="c1"># spectrum noise</span>
                        <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                    <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="n">nell</span><span class="p">,</span> <span class="n">debias</span></div>

<div class="viewcode-block" id="XFaster.do_qb2cb"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.do_qb2cb">[docs]</a>    <span class="k">def</span> <span class="nf">do_qb2cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qb</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">,</span> <span class="n">wbl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute binned output spectra and covariances by averaging</span>
<span class="sd">        the shape spectrum over each bin, and applying the appropriate</span>
<span class="sd">        ``qb`` bandpower amplitude.</span>

<span class="sd">        This method is used internally by ``fisher_calc``, and requires</span>
<span class="sd">        bin definitions to have been pre-loaded using ``get_bin_def``</span>
<span class="sd">        or ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : dict</span>
<span class="sd">            Bandpower amplitudes for each spectrum bin.</span>
<span class="sd">        inv_fish : array_like, (nbins, nbins)</span>
<span class="sd">            Inverse fisher matrix for computing the bin errors and covariance.</span>
<span class="sd">        wbl : dict</span>
<span class="sd">            Window functions for each qb</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cb : dict of arrays</span>
<span class="sd">            Binned spectrum</span>
<span class="sd">        dcb : dict of arrays</span>
<span class="sd">            Binned spectrum error</span>
<span class="sd">        ellb : dict of arrays</span>
<span class="sd">            Average bin center</span>
<span class="sd">        cov : array_like, (nbins, nbins)</span>
<span class="sd">            Binned spectrum covariance</span>
<span class="sd">        qb2cb : dict</span>
<span class="sd">            The conversion matrix from ``qb`` to ``cb`` for each spectrum</span>
<span class="sd">            component, computed from the qb window functions</span>
<span class="sd">        wbl_cb : dict</span>
<span class="sd">            Window functions for each cb</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qb2cb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">ellb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">wbl_cb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># truncate to only bins for which there are window functions</span>
        <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">bin_index</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">stag</span> <span class="ow">in</span> <span class="n">wbl</span><span class="p">])</span>
        <span class="n">inv_fish</span> <span class="o">=</span> <span class="n">inv_fish</span><span class="p">[:</span><span class="n">nbins</span><span class="p">,</span> <span class="p">:</span><span class="n">nbins</span><span class="p">]</span>
        <span class="n">qb2cb_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">)</span>

        <span class="c1"># window function normalization</span>
        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ell</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># normalization shape spectrum</span>
        <span class="n">model</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_cls</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">ell</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">ell</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">wbl1</span> <span class="ow">in</span> <span class="n">wbl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># compute conversion factors</span>
            <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">wbl1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">wbl1</span><span class="p">)))</span>
            <span class="n">cls_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span> <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">stag</span> <span class="k">else</span> <span class="n">stag</span><span class="p">][:</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell</span><span class="p">)]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="n">wbl1</span> <span class="o">*</span> <span class="n">cls_shape</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)):</span>
                <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">][:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># normalize for cb&#39;s or db&#39;s</span>
            <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">wbl1</span> <span class="o">*</span> <span class="n">model</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># construct conversion matrix for covariance</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">bin_index</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
            <span class="n">qb2cb_mat</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>

            <span class="c1"># compute wbls for cb&#39;s</span>
            <span class="n">wbl_cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,jl-&gt;il&quot;</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">wbl1</span><span class="p">)</span>

            <span class="c1"># check normalization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> cb window function normalization: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">stag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">wbl_cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">*</span> <span class="n">model</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># compute bin centers</span>
            <span class="n">ellb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">wbl_cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">ell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># compute cb&#39;s</span>
            <span class="n">cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">])</span>

        <span class="c1"># compute covariance and errors</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ik,jl,kl-&gt;ij&quot;</span><span class="p">,</span> <span class="n">qb2cb_mat</span><span class="p">,</span> <span class="n">qb2cb_mat</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">)</span>
        <span class="n">dcb</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">)),</span> <span class="n">qb2cb</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cb</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="n">ellb</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">,</span> <span class="n">wbl_cb</span></div>

<div class="viewcode-block" id="XFaster.fisher_precalc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.fisher_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">fisher_precalc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cbl</span><span class="p">,</span>
        <span class="n">cls_input</span><span class="p">,</span>
        <span class="n">cls_debias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">likelihood</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-compute the D_ell and signal derivative matrices necessary for</span>
<span class="sd">        ``fisher_calc`` from the input data spectra.  This method requires bin</span>
<span class="sd">        definitions precomputed by ``get_bin_def`` or ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cbl : OrderedDict</span>
<span class="sd">            Cbl dict computed by ``bin_cl_template`` for a given</span>
<span class="sd">            shape spectrum.</span>
<span class="sd">        cls_input : OrderedDict</span>
<span class="sd">            Input spectra.  If computing a transfer function, this is the</span>
<span class="sd">            average ``cls_signal``.  If computing a null test, this is</span>
<span class="sd">            ``cls_data_null``, and otherwise it is ``cls_data``, for a single map or</span>
<span class="sd">            several input maps.</span>
<span class="sd">        cls_debias : OrderedDict</span>
<span class="sd">            If supplied, the debias spectrum is subtracted from the input.</span>
<span class="sd">        likelihood : bool</span>
<span class="sd">            If True, compute just Dmat_obs_b.  Otherwise, Dmat_obs and</span>
<span class="sd">            dSdqb_mat1 are also computed.</span>
<span class="sd">        windows : bool</span>
<span class="sd">            If True, compute dSdqb and Mll for constructing window functions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dmat_obs : OrderedDict</span>
<span class="sd">            De-biased D_ell matrix from ``cls_input``</span>
<span class="sd">        Dmat_obs_b : OrderedDict</span>
<span class="sd">            Biased D_ell matrix from ``cls_input`` (for likelihood)</span>
<span class="sd">        dSdqb_mat1 : OrderedDict</span>
<span class="sd">            Signal derivative matrix from Cbl</span>
<span class="sd">        Mmat : OrderedDict</span>
<span class="sd">            Mode mixing matrix (Kll&#39; * Fl * Bl^2) for constructing</span>
<span class="sd">            window functions.</span>
<span class="sd">        Mmat_mix : OrderedDict</span>
<span class="sd">            EB mixing terms for the mode mixxing matrix</span>

<span class="sd">        .. note:: the output arrays are also stored as attributes of the</span>
<span class="sd">        parent object to avoid repeating the computation in ``fisher_calc``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="n">pol_dim</span> <span class="o">*</span> <span class="n">num_maps</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;fg_tt&quot;</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;res_tt&quot;</span> <span class="ow">in</span> <span class="n">cbl</span> <span class="ow">or</span> <span class="s2">&quot;res_ee&quot;</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls_input</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dSdqb</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Mmat</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">Mmat</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">mll</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;mll&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mll</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_precalc</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">Mmat</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dSdqb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># transfer function doesn&#39;t have all the crosses</span>
            <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_input</span><span class="p">[</span><span class="n">specs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="n">Dmat_obs_b</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Mmat</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">Mmat_mix</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dmat_obs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                    <span class="c1"># without bias subtraction for likelihood</span>
                    <span class="n">Dmat_obs_b</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_input</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">windows</span><span class="p">:</span>
                    <span class="n">Mmat</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="n">mspec</span> <span class="o">=</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span>
                        <span class="n">Mmat_mix</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_mix&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mspec</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cls_debias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">Dmat_obs</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">cls_input</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">-</span> <span class="n">cls_debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Dmat_obs</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_input</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">dSdqb</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                        <span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">dSdqb</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">mspec</span> <span class="o">=</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span>
                        <span class="n">mix_cbl</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="n">dSdqb</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">mspec</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_cbl</span>

                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
                    <span class="c1"># add delta beta bin for spectral index</span>
                    <span class="n">dSdqb</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                        <span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                        <span class="c1"># this will be filled in in fisher_calc</span>
                        <span class="n">dSdqb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Dmat_obs</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">,</span> <span class="n">dSdqb</span><span class="p">,</span> <span class="n">Mmat</span><span class="p">,</span> <span class="n">Mmat_mix</span></div>

<div class="viewcode-block" id="XFaster.clear_precalc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.clear_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">clear_precalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear variables pre-computed with ``fisher_precalc``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Mmat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Mmat_mix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mll</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="XFaster.fisher_calc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.fisher_calc">[docs]</a>    <span class="k">def</span> <span class="nf">fisher_calc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qb</span><span class="p">,</span>
        <span class="n">cbl</span><span class="p">,</span>
        <span class="n">cls_input</span><span class="p">,</span>
        <span class="n">cls_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_debias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">likelihood</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">like_lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_precalc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inv_fish</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-compute the Fisher matrix and qb amplitudes based on</span>
<span class="sd">        input data spectra.  This method is called iteratively</span>
<span class="sd">        by ``fisher_iterate``, and requires bin definitions precomputed</span>
<span class="sd">        by ``get_bin_def`` or ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : OrderedDict</span>
<span class="sd">            Bandpower amplitudes, typically computed in a previous call</span>
<span class="sd">            to this method.</span>
<span class="sd">        cbl : OrderedDict</span>
<span class="sd">            Cbl matrix computed by ``bin_cl_template`` for a given</span>
<span class="sd">            shape spectrum.</span>
<span class="sd">        cls_input : OrderedDict</span>
<span class="sd">            Input spectra.  If computing a transfer function,</span>
<span class="sd">            this is the average ``cls_signal``.  If computing a null</span>
<span class="sd">            test, this is ``cls_data_null``, and otherwise it is</span>
<span class="sd">            ``cls_data``, for a single map or several input maps.</span>
<span class="sd">        cls_noise : OrderedDict</span>
<span class="sd">            If supplied, the noise spectrum is applied to the model spectrum.</span>
<span class="sd">        cls_debias : OrderedDict</span>
<span class="sd">            If supplied, the debias spectrum is subtracted from the input.</span>
<span class="sd">        cond_criteria : float</span>
<span class="sd">            The maximum condition number allowed for Dmat1 to be acceptable</span>
<span class="sd">            for taking its inverse.</span>
<span class="sd">        likelihood : bool</span>
<span class="sd">            If True, return the likelihood for the given input bandpowers, shapes</span>
<span class="sd">            and data spectra.  Otherwise, computes output bandpowers and the fisher</span>
<span class="sd">            covariance for a NR iteration.</span>
<span class="sd">        use_precalc : bool</span>
<span class="sd">            If True, load pre-calculated terms stored from a previous iteration,</span>
<span class="sd">            and store for a future iteration.  Otherwise, all calculations are</span>
<span class="sd">            repeated.</span>
<span class="sd">        windows : bool</span>
<span class="sd">            If True, return W_bl window functions for each CMB qb.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qb : OrderedDict</span>
<span class="sd">            New bandpower amplitudes</span>
<span class="sd">        inv_fish : array_like</span>
<span class="sd">            Inverse Fisher correlation matrix over all bins</span>
<span class="sd">        -- or --</span>
<span class="sd">        likelihood : scalar</span>
<span class="sd">            Likelihood of the given input parameters.</span>
<span class="sd">        -- or --</span>
<span class="sd">        windows : OrderedDict</span>
<span class="sd">            qb window functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cond_criteria</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cond_criteria</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">well_cond</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">do_fg</span> <span class="o">=</span> <span class="s2">&quot;fg_tt&quot;</span> <span class="ow">in</span> <span class="n">cbl</span>

        <span class="n">dkey</span> <span class="o">=</span> <span class="s2">&quot;Dmat_obs_b&quot;</span> <span class="k">if</span> <span class="n">likelihood</span> <span class="k">else</span> <span class="s2">&quot;Mmat&quot;</span> <span class="k">if</span> <span class="n">windows</span> <span class="k">else</span> <span class="s2">&quot;Dmat_obs&quot;</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dkey</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_precalc</span><span class="p">:</span>
            <span class="n">Dmat_obs</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">,</span> <span class="n">dSdqb_mat1</span><span class="p">,</span> <span class="n">Mmat</span><span class="p">,</span> <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_precalc</span><span class="p">(</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">cls_input</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">cls_debias</span><span class="p">,</span>
                <span class="n">likelihood</span><span class="o">=</span><span class="n">likelihood</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">use_precalc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">Dmat_obs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">Dmat_obs_b</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="n">dSdqb_mat1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Mmat</span> <span class="o">=</span> <span class="n">Mmat</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Mmat_mix</span> <span class="o">=</span> <span class="n">Mmat_mix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs_b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
                    <span class="n">Mmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mmat</span>
                    <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mmat_mix</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span>
                <span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dSdqb_mat1</span>

        <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
            <span class="n">delta_beta</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">dSdqb_mat1_freq</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dSdqb_mat1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">likelihood</span> <span class="ow">or</span> <span class="n">windows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cond_noise</span><span class="p">:</span>
            <span class="n">well_cond</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">cond_noise</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">gmat_ell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">Dmat1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">cls_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span>
            <span class="p">)</span>

        <span class="n">mkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls_model</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># transfer function does not have crosses</span>
            <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">mkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="k">continue</span>
            <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">well_cond</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="c1"># transfer function doesn&#39;t have eb/tb</span>
                    <span class="k">if</span> <span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">Dmat1</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">Dmat1</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_model</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">well_cond</span><span class="p">:</span>
            <span class="n">Dmat1_mat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat1</span><span class="p">)</span>

        <span class="c1"># Set up dSdqb frequency dependence</span>
        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># transfer function does not have crosses</span>
            <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">mkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">do_fg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="c1"># Add spectral index dependence</span>
                <span class="c1"># dSdqb now depends on qb (spec index) because</span>
                <span class="c1"># model is non-linear so cannot be precomputed.</span>

                <span class="c1"># get foreground at pivot point spectral index</span>
                <span class="c1"># and first derivative</span>
                <span class="n">freq_scale0</span><span class="p">,</span> <span class="n">freq_scale_deriv</span> <span class="o">=</span> <span class="n">xft</span><span class="o">.</span><span class="n">scale_dust</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">[</span><span class="n">m0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">[</span><span class="n">m1</span><span class="p">],</span>
                    <span class="n">ref_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_freq</span><span class="p">,</span>
                    <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
                    <span class="n">deriv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">freq_scale</span> <span class="o">=</span> <span class="n">freq_scale0</span> <span class="o">+</span> <span class="n">delta_beta</span> <span class="o">*</span> <span class="n">freq_scale_deriv</span>
                <span class="n">freq_scale_ratio</span> <span class="o">=</span> <span class="n">freq_scale_deriv</span> <span class="o">/</span> <span class="n">freq_scale</span>

                <span class="c1"># scale foreground model by frequency scaling adjusted for beta</span>
                <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">sdat</span> <span class="ow">in</span> <span class="n">dSdqb_mat1_freq</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">s2</span><span class="p">,</span> <span class="n">sdat2</span> <span class="ow">in</span> <span class="n">sdat</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dSdqb_mat1_freq</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">s1</span><span class="p">][</span><span class="n">s2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">freq_scale</span>

                <span class="c1"># build delta_beta term from frequency scaled model,</span>
                <span class="c1"># divide out frequeny scaling and apply derivative term</span>
                <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">sdat</span> <span class="ow">in</span> <span class="n">dSdqb_mat1_freq</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">sdat</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_model</span><span class="p">[</span><span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span> <span class="o">*</span> <span class="n">freq_scale_ratio</span>

        <span class="c1"># Set up Dmat -- if it&#39;s not well conditioned, add noise to the</span>
        <span class="c1"># diagonal until it is.</span>
        <span class="n">cond_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">well_cond</span><span class="p">:</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># transfer function does not have crosses</span>
                <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">mkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="c1"># transfer function doesn&#39;t have eb/tb</span>
                    <span class="k">if</span> <span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">Dmat1</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">Dmat1</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_model</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span>

            <span class="n">Dmat1_mat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat1</span><span class="p">)</span>

            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">Dmat1_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="p">:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">cond</span> <span class="o">&gt;</span> <span class="n">cond_criteria</span> <span class="ow">and</span> <span class="n">cond_noise</span><span class="p">:</span>
                <span class="n">cond_iter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># cond_noise iteration factor found through trial and error</span>
                <span class="n">cond_noise</span> <span class="o">*=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">cond_iter</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cond_iter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Condition criteria not met. &quot;</span>
                        <span class="s2">&quot;Max Cond=</span><span class="si">{:.0f}</span><span class="s2">, Thresh=</span><span class="si">{:.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="p">),</span>
                        <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">well_cond</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Condition criteria met. &quot;</span>
                    <span class="s2">&quot;Max Cond=</span><span class="si">{:.0f}</span><span class="s2">, Thresh=</span><span class="si">{:.0f}</span><span class="s2">, Iter=</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">cond</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="p">,</span> <span class="n">cond_iter</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">cond_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Cond_noise = </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond_noise</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="c1"># construct arrays from dictionaries</span>
        <span class="n">Dmat1</span> <span class="o">=</span> <span class="n">Dmat1_mat</span>
        <span class="n">gmat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">gmat_ell</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat_obs_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Mmat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Mmat</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Mmat_mix</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat_obs</span><span class="p">)</span>
            <span class="n">dSdqb_mat1_freq</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dsdqb_mat</span><span class="p">(</span><span class="n">dSdqb_mat1_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>

        <span class="c1"># apply ell limits</span>
        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="k">if</span> <span class="n">like_lmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">like_lmin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">like_lmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">like_lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Dmat1</span> <span class="o">=</span> <span class="n">Dmat1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">Dmat_obs_b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Mmat</span> <span class="o">=</span> <span class="n">Mmat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">Mmat_mix</span> <span class="o">=</span> <span class="n">Mmat_mix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">Dmat_obs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
            <span class="n">dSdqb_mat1_freq</span> <span class="o">=</span> <span class="n">dSdqb_mat1_freq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
        <span class="n">gmat</span> <span class="o">=</span> <span class="n">gmat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Dmat1</span> <span class="o">=</span> <span class="n">Dmat1</span>

        <span class="n">lam</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Dmat1</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">lam</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bad</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="c1"># exclude any ell&#39;s with ill-conditioned D matrix</span>
            <span class="c1"># this should happen only far from max like</span>
            <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bad</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">bad_ells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ell</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ell</span><span class="o">.</span><span class="n">stop</span><span class="p">)[</span><span class="n">bad_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Found negative eigenvalues at ells </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bad_ells</span><span class="p">),</span> <span class="s2">&quot;warning&quot;</span>
            <span class="p">)</span>
            <span class="n">gmat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inv_lam</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lam</span>
        <span class="n">Dinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,...j,...kj-&gt;...ik&quot;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">inv_lam</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="c1"># log(det(D)) = tr(log(D)), latter is numerically stable</span>
            <span class="c1"># compute log(D) by eigenvalue decomposition per ell</span>
            <span class="n">log_lam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
            <span class="n">Dlog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,...j,...kj-&gt;...ik&quot;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">log_lam</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># compute ell-by-ell inverse</span>
            <span class="c1"># Dinv = np.linalg.inv(Dmat1.swapaxes(0, -1)).swapaxes(0, -1)</span>

            <span class="c1"># optimized matrix multiplication</span>
            <span class="c1"># there is something super weird about this whole matrix operation</span>
            <span class="c1"># that causes the computation of mats to take four times as long</span>
            <span class="c1"># if mat1 is not computed.</span>
            <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gmat</span><span class="p">))</span>
            <span class="n">mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij...,jk...-&gt;ik...&quot;</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">)</span>
            <span class="n">mat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;klm...,ln...-&gt;knm...&quot;</span><span class="p">,</span> <span class="n">dSdqb_mat1_freq</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">)</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ik...,knm...-&gt;inm...&quot;</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="c1"># compute log likelihood as tr(g * (D^-1 * Dobs + log(D)))</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij...,jk...-&gt;ik...&quot;</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dlog</span>
            <span class="n">like</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iij,iij-&gt;&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="c1"># include priors in likelihood</span>
            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span> <span class="ow">and</span> <span class="n">delta_beta_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta_beta_prior</span>
                <span class="n">like</span> <span class="o">-=</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">if</span> <span class="n">null_first_cmb</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span>
                    <span class="n">like</span> <span class="o">-=</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">return</span> <span class="n">like</span>

        <span class="c1"># construct matrices for the qb and fisher terms,</span>
        <span class="c1"># and take the trace and sum over ell simultaneously</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">windows</span><span class="p">:</span>
            <span class="n">qb_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jil-&gt;k&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">Dmat_obs</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">windows</span> <span class="ow">or</span> <span class="p">(</span><span class="n">windows</span> <span class="ow">and</span> <span class="n">inv_fish</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jiml-&gt;km&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">dSdqb_mat1_freq</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inv_fish</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inv_fish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fisher</span><span class="p">)))</span>

            <span class="c1"># compute prefactors</span>
            <span class="n">ells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ells</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># compute binning term</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,kljm-&gt;klim&quot;</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
            <span class="n">wbl</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="n">spec_mask</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">spec_mask</span><span class="p">(</span><span class="n">nmaps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span><span class="p">)</span>

            <span class="c1"># compute window functions for each spectrum</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bin_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;fg&quot;</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># select bins for corresponding spectrum</span>
                <span class="n">sarg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>

                <span class="c1"># select the spectrum terms from the kernel matrix</span>
                <span class="n">smat</span> <span class="o">=</span> <span class="n">spec_mask</span><span class="p">[</span><span class="n">spec</span><span class="p">][:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">Mmat</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="c1"># add mixing terms</span>
                    <span class="n">mspec</span> <span class="o">=</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span>
                    <span class="n">smat</span> <span class="o">+=</span> <span class="n">spec_mask</span><span class="p">[</span><span class="n">mspec</span><span class="p">][:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">Mmat_mix</span>

                <span class="c1"># qb window function</span>
                <span class="n">wbl1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jilm-&gt;km&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">sarg</span><span class="p">,</span> <span class="n">smat</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">norm</span>

                <span class="c1"># bin weighting, allowing for overlapping bin edges</span>
                <span class="n">chi_bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="n">chi_bl</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span>

                <span class="c1"># check normalization</span>
                <span class="n">cls_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span> <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span> <span class="k">else</span> <span class="n">k</span><span class="p">][:</span> <span class="nb">len</span><span class="p">(</span><span class="n">norm</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> qb window function normalization: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wbl1</span> <span class="o">*</span> <span class="n">norm</span> <span class="o">*</span> <span class="n">chi_bl</span> <span class="o">*</span> <span class="n">cls_shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">wbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">wbl1</span>

            <span class="k">return</span> <span class="n">wbl</span>

        <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span> <span class="ow">and</span> <span class="n">delta_beta_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># XXX need documentation for what happens here</span>
            <span class="c1"># for imposing the delta_beta prior</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">bin_index</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">delta_beta_prior</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">qb_vec</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span>

        <span class="k">if</span> <span class="n">null_first_cmb</span><span class="p">:</span>
            <span class="c1"># blow up the fisher matrix for first bin</span>
            <span class="c1"># by implementing a tight prior</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stag</span> <span class="ow">in</span> <span class="n">bin_index</span><span class="p">:</span>  <span class="c1"># check for transfer function</span>
                    <span class="n">b0</span> <span class="o">=</span> <span class="n">bin_index</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">fisher</span><span class="p">[</span><span class="n">b0</span><span class="p">,</span> <span class="n">b0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e10</span>
                    <span class="n">qb_vec</span><span class="p">[</span><span class="n">b0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e10</span>

        <span class="c1"># invert</span>
        <span class="n">qb_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">qb_vec</span><span class="p">)</span>
        <span class="n">inv_fish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qb_vec</span><span class="p">)))</span>
        <span class="n">qb_vec</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">qb_vec</span><span class="p">,</span> <span class="n">qb</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">qb_vec</span><span class="p">,</span> <span class="n">inv_fish</span></div>

<div class="viewcode-block" id="XFaster.fisher_iterate"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.fisher_iterate">[docs]</a>    <span class="k">def</span> <span class="nf">fisher_iterate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cbl</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
        <span class="n">qb_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_iters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_profiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_profile_sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">like_profile_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">file_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the Fisher calculation to compute bandpower estimates</span>
<span class="sd">        assuming an input shape spectrum.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cbl : OrderedDict</span>
<span class="sd">            Cbl matrix computed from an input shape spectrum</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If not None, then iteration is performed over the spectra</span>
<span class="sd">            corresponding to the given map, rather over all possible</span>
<span class="sd">            combinations of map-map cross-spectra. In this case, the first</span>
<span class="sd">            dimension of the input cbl must be of size 1 (this is done</span>
<span class="sd">            automatically by calling ``bin_cl_template(..., map_tag=&lt;map_tag&gt;)``.</span>
<span class="sd">        iter_max : int</span>
<span class="sd">            Maximum number of iterations to perform.  if this limit is</span>
<span class="sd">            reached, a warning is issued.</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Maximum fractional change in qb that indicates convergence and</span>
<span class="sd">            stops iteration.</span>
<span class="sd">        qb_start : OrderedDict</span>
<span class="sd">            Initial guess at ``qb`` bandpower amplitudes.  If None, unity is</span>
<span class="sd">            assumed for all bins.</span>
<span class="sd">        transfer_run : bool</span>
<span class="sd">            If True, the input Cls passed to ``fisher_calc`` are the average</span>
<span class="sd">            of the signal simulations, and noise cls are ignored.</span>
<span class="sd">            If False, the input Cls are either ``cls_data_null``</span>
<span class="sd">            (for null tests) or ``cls_data``.  See ``get_masked_data`` for</span>
<span class="sd">            how these are computed.  The input noise is similarly either</span>
<span class="sd">            ``cls_noise_null`` or ``cls_noise``.</span>
<span class="sd">        save_iters : bool</span>
<span class="sd">            If True, the output data from each Fisher iteration are stored</span>
<span class="sd">            in an individual npz file.</span>
<span class="sd">        cond_criteria : float</span>
<span class="sd">            The maximum condition number allowed for Dmat1 to be acceptable</span>
<span class="sd">            for taking its inverse.</span>
<span class="sd">        like_profiles : bool</span>
<span class="sd">            If True, compute profile likelihoods for each qb, leaving all</span>
<span class="sd">            others fixed at their maximum likelihood values.  Profiles are</span>
<span class="sd">            computed over a range +/--sigma as estimated from the diagonals</span>
<span class="sd">            of the inverse Fisher matrix.</span>
<span class="sd">        like_profile_sigma : float</span>
<span class="sd">            Range in units of 1sigma over which to compute profile likelihoods</span>
<span class="sd">        like_profile_points : int</span>
<span class="sd">            Number of points to sample along the likelihood profile</span>
<span class="sd">        file_tag : string</span>
<span class="sd">            If supplied, appended to the bandpowers filename.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            The results of the Fisher iteration process.  This dictionary</span>
<span class="sd">            contains the fields::</span>

<span class="sd">                qb : converged bandpower amplitudes</span>
<span class="sd">                cb : output binned spectrum</span>
<span class="sd">                dcb : binned spectrum errors</span>
<span class="sd">                ellb : bin centers</span>
<span class="sd">                cov : spectrum covariance</span>
<span class="sd">                inv_fish : inverse fisher matrix</span>
<span class="sd">                fqb : fractional change in qb for the last iteration</span>
<span class="sd">                qb2cb : conversion factor</span>
<span class="sd">                cbl : Cbl matrix</span>
<span class="sd">                cls_model : unbinned model spectrum computed from Cbl</span>
<span class="sd">                bin_def : bin definition array</span>
<span class="sd">                cls_obs : observed input spectra</span>
<span class="sd">                cls_noise : noise spectra</span>
<span class="sd">                cls_shape : shape spectrum</span>
<span class="sd">                iters : number of iterations completed</span>

<span class="sd">            If ``transfer_run`` is False, this dictionary also contains::</span>

<span class="sd">                qb_transfer : transfer function amplitudes</span>
<span class="sd">                nbins_res : number of residual bins</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method stores outputs to files with name &#39;transfer&#39; for transfer</span>
<span class="sd">        function runs (if ``transfer_run = True``), otherwise with name</span>
<span class="sd">        &#39;bandpowers&#39;.  Outputs from each individual iteration, containing</span>
<span class="sd">        only the quantities that change with each step, are stored in</span>
<span class="sd">        separate files with the same name (and different index).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;transfer&quot;</span> <span class="k">if</span> <span class="n">transfer_run</span> <span class="k">else</span> <span class="s2">&quot;bandpowers&quot;</span>

        <span class="k">if</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="n">null_first_cmb</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># previous fqb iterations to monitor convergence and adjust conditioning</span>
        <span class="n">prev_fqb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cond_adjusted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">qb_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">transfer_run</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;cmb&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">or</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">or</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;delta_beta&quot;</span><span class="p">:</span>
                    <span class="c1"># qb_delta beta is a coefficient on the change from beta,</span>
                    <span class="c1"># so expect that it should be small if beta_ref is close</span>
                    <span class="c1"># (zeroes cause singular matrix problems)</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;fg_&quot;</span><span class="p">):</span>
                    <span class="c1"># res qb=0 means noise model is 100% accurate.</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># start by assuming model is 100% accurate</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">qb_start</span>

        <span class="n">obs</span><span class="p">,</span> <span class="n">nell</span><span class="p">,</span> <span class="n">debias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_spectra</span><span class="p">(</span>
            <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="n">transfer_run</span>
        <span class="p">)</span>

        <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">iter_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iter_max</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Doing Fisher step </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iter_max</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
            <span class="p">)</span>

            <span class="n">qb_new</span><span class="p">,</span> <span class="n">inv_fish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">debias</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">qb_arr</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">qb_new_arr</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">qb_new</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dqb</span> <span class="o">=</span> <span class="n">qb_new_arr</span> <span class="o">-</span> <span class="n">qb_arr</span>
            <span class="n">fqb</span> <span class="o">=</span> <span class="n">dqb</span> <span class="o">/</span> <span class="n">qb_arr</span>
            <span class="n">max_fqb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fqb</span><span class="p">))</span>

            <span class="n">prev_fqb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_fqb</span><span class="p">)</span>

            <span class="n">fnan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fqb</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fnan</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="p">(</span><span class="n">nanidx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fnan</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Ignoring </span><span class="si">{}</span><span class="s2"> bins with fqb=nan: bins=</span><span class="si">{}</span><span class="s2">, qb_new=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;qb=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">iter_idx</span><span class="p">,</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">nanidx</span><span class="p">),</span>
                        <span class="n">nanidx</span><span class="p">,</span>
                        <span class="n">qb_new_arr</span><span class="p">[</span><span class="n">nanidx</span><span class="p">],</span>
                        <span class="n">qb_arr</span><span class="p">[</span><span class="n">nanidx</span><span class="p">],</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Max fractional change in qb: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_fqb</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>

            <span class="c1"># put qb_new in original dict</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb_new</span><span class="p">)</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                <span class="c1"># get beta fit and beta error</span>
                <span class="n">beta_fit</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span>
                <span class="n">db_idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">bin_index</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">])</span>
                <span class="n">beta_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">[</span><span class="n">db_idx</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beta_fit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">beta_err</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">save_iters</span><span class="p">:</span>
                <span class="c1"># save only the quantities that change with each iteration</span>
                <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span>
                    <span class="n">map_tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span>
                    <span class="n">iter_index</span><span class="o">=</span><span class="n">iter_idx</span><span class="p">,</span>
                    <span class="n">bin_def</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">,</span>
                    <span class="n">bin_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">,</span>
                    <span class="n">cls_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">,</span>
                    <span class="n">cls_obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
                    <span class="n">qb</span><span class="o">=</span><span class="n">qb</span><span class="p">,</span>
                    <span class="n">fqb</span><span class="o">=</span><span class="n">fqb</span><span class="p">,</span>
                    <span class="n">inv_fish</span><span class="o">=</span><span class="n">inv_fish</span><span class="p">,</span>
                    <span class="n">cls_model</span><span class="o">=</span><span class="n">cls_model</span><span class="p">,</span>
                    <span class="n">cbl</span><span class="o">=</span><span class="n">cbl</span><span class="p">,</span>
                    <span class="n">map_freqs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">,</span>
                    <span class="n">cls_signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span><span class="p">,</span>
                    <span class="n">cls_noise</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">,</span>
                    <span class="n">Dmat_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span><span class="p">,</span>
                    <span class="n">gmat_ell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gmat_ell</span><span class="p">,</span>
                    <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;fg_tt&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="n">beta_fit</span><span class="o">=</span><span class="n">beta_fit</span><span class="p">,</span>
                        <span class="n">beta_err</span><span class="o">=</span><span class="n">beta_err</span><span class="p">,</span>
                        <span class="n">ref_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_freq</span><span class="p">,</span>
                        <span class="n">beta_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="ow">not</span> <span class="n">transfer_run</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span><span class="p">)</span>

            <span class="p">(</span><span class="n">nans</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qb_new_arr</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nans</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Found NaN values in qb bins </span><span class="si">{}</span><span class="s2"> at iter </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nans</span><span class="p">,</span> <span class="n">iter_idx</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">fnan</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;All bins have fqb=NaN at iter </span><span class="si">{}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;something has gone horribly wrong.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="n">negs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">negs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Found negatives in inv_fish diagonal at locations &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="n">negs</span><span class="p">),</span>
                    <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fqb</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">converge_criteria</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
                    <span class="c1"># Calculate final fisher matrix without conditioning</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating final Fisher matrix.&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">inv_fish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                        <span class="n">qb</span><span class="p">,</span>
                        <span class="n">cbl</span><span class="p">,</span>
                        <span class="n">obs</span><span class="p">,</span>
                        <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                        <span class="n">cls_debias</span><span class="o">=</span><span class="n">debias</span><span class="p">,</span>
                        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                        <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># If any diagonals of inv_fisher are negative, something went wrong</span>
                <span class="n">negs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">negs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Found negatives in inv_fish diagonal at locations &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">negs</span><span class="p">),</span>
                        <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> did not converge in </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;Multi-map&quot;</span> <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_tag</span><span class="p">),</span>
                    <span class="s2">&quot;transfer function&quot;</span> <span class="k">if</span> <span class="n">transfer_run</span> <span class="k">else</span> <span class="s2">&quot;spectrum&quot;</span><span class="p">,</span>
                    <span class="n">iter_max</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Check the slope of the last ten fqb_maxpoints.</span>
                <span class="c1"># If there&#39;s not a downward trend, adjust conditioning</span>
                <span class="c1"># criteria to help convergence.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_fqb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="ow">or</span> <span class="n">transfer_run</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">prev_fqb</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Not converging</span>
                    <span class="c1"># First, start from very little conditioning</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">cond_adjusted</span><span class="p">:</span>
                        <span class="n">cond_criteria</span> <span class="o">=</span> <span class="mf">5e3</span>
                        <span class="n">cond_adjusted</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Not converging. Setting cond_criteria=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">iter_idx</span><span class="p">,</span> <span class="n">cond_criteria</span>
                            <span class="p">),</span>
                            <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">elif</span> <span class="n">cond_criteria</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                        <span class="n">cond_criteria</span> <span class="o">/=</span> <span class="mf">2.0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Tightening condition criteria to help convergence. &quot;</span>
                            <span class="s2">&quot;cond_criteria=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="p">),</span>
                            <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Can&#39;t reduce cond_criteria any more.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">iter_idx</span>
                            <span class="p">),</span>
                            <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="c1"># give it ten tries to start converging</span>
                    <span class="n">prev_fqb</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># save and return</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">qb</span><span class="o">=</span><span class="n">qb</span><span class="p">,</span>
            <span class="n">inv_fish</span><span class="o">=</span><span class="n">inv_fish</span><span class="p">,</span>
            <span class="n">fqb</span><span class="o">=</span><span class="n">fqb</span><span class="p">,</span>
            <span class="n">bin_def</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">,</span>
            <span class="n">bin_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">,</span>
            <span class="n">iters</span><span class="o">=</span><span class="n">iter_idx</span><span class="p">,</span>
            <span class="n">success</span><span class="o">=</span><span class="n">success</span><span class="p">,</span>
            <span class="n">map_tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span>
            <span class="n">map_freqs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">,</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
            <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;fg_tt&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                <span class="n">beta_fit</span><span class="o">=</span><span class="n">beta_fit</span><span class="p">,</span>
                <span class="n">beta_err</span><span class="o">=</span><span class="n">beta_err</span><span class="p">,</span>
                <span class="n">ref_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_freq</span><span class="p">,</span>
                <span class="n">beta_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">cbl</span><span class="o">=</span><span class="n">cbl</span><span class="p">,</span>
                <span class="n">cls_obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">,</span>
                <span class="n">cls_model</span><span class="o">=</span><span class="n">cls_model</span><span class="p">,</span>
                <span class="n">cls_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
                <span class="n">Dmat_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">qb_transfer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">template_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer_run</span><span class="p">:</span>
            <span class="c1"># do one more fisher calc that doesn&#39;t include sample variance</span>
            <span class="c1"># set qb=very close to 0. 0 causes singular matrix problems.</span>
            <span class="c1"># don&#39;t do this for noise residual bins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating final Fisher matrix without sample variance.&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">qb_zeroed</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="n">qb_new_ns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;fg&quot;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb_zeroed</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">qb_zeroed</span><span class="p">[</span><span class="n">stag</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1e-20</span>
                    <span class="n">qb_new_ns</span><span class="p">[</span><span class="n">stag</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                <span class="n">qb_zeroed</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1e-20</span>
                <span class="n">qb_new_ns</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">inv_fish_ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb_zeroed</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">debias</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">invfish_nosampvar</span><span class="o">=</span><span class="n">inv_fish_ns</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># compute window functions for CMB bins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating window functions for CMB bins&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">wbl_qb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">inv_fish</span><span class="o">=</span><span class="n">inv_fish</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">wbl_qb</span><span class="o">=</span><span class="n">wbl_qb</span><span class="p">)</span>

            <span class="c1"># compute bandpowers and covariances</span>
            <span class="n">cb</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="n">ellb</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">,</span> <span class="n">wbl_cb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_qb2cb</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">,</span> <span class="n">wbl_qb</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dcb_ns</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cov_ns</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_qb2cb</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">inv_fish_ns</span><span class="p">,</span> <span class="n">wbl_qb</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">cb</span><span class="o">=</span><span class="n">cb</span><span class="p">,</span>
                <span class="n">dcb</span><span class="o">=</span><span class="n">dcb</span><span class="p">,</span>
                <span class="n">ellb</span><span class="o">=</span><span class="n">ellb</span><span class="p">,</span>
                <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span>
                <span class="n">qb2cb</span><span class="o">=</span><span class="n">qb2cb</span><span class="p">,</span>
                <span class="n">wbl_cb</span><span class="o">=</span><span class="n">wbl_cb</span><span class="p">,</span>
                <span class="n">dcb_nosampvar</span><span class="o">=</span><span class="n">dcb_ns</span><span class="p">,</span>
                <span class="n">cov_nosampvar</span><span class="o">=</span><span class="n">cov_ns</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">like_profiles</span><span class="p">:</span>
                <span class="c1"># compute bandpower likelihoods</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating bandpower profile likelihoods&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
                <span class="n">max_like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                    <span class="n">qb</span><span class="p">,</span>
                    <span class="n">cbl</span><span class="p">,</span>
                    <span class="n">obs</span><span class="p">,</span>
                    <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                    <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                    <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                    <span class="n">likelihood</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">dqb</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">))),</span> <span class="n">qb</span><span class="p">)</span>
                <span class="n">qb_like</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">qbs</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">qb_like</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qbs</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">like_profile_points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                    <span class="p">)</span>

                    <span class="k">for</span> <span class="n">ibin</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qbs</span><span class="p">):</span>
                        <span class="n">qb1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
                        <span class="n">dq</span> <span class="o">=</span> <span class="n">dqb</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">*</span> <span class="n">like_profile_sigma</span>
                        <span class="n">q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">dq</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="n">dq</span><span class="p">,</span> <span class="n">like_profile_points</span><span class="p">)</span>
                        <span class="n">like_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q_arr</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">q1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q_arr</span><span class="p">):</span>
                            <span class="n">qb1</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">=</span> <span class="n">q1</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                                    <span class="n">qb1</span><span class="p">,</span>
                                    <span class="n">cbl</span><span class="p">,</span>
                                    <span class="n">obs</span><span class="p">,</span>
                                    <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                                    <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                                    <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                                    <span class="n">likelihood</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                                <span class="n">like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                            <span class="n">like_arr</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">like</span>

                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> bin </span><span class="si">{}</span><span class="s2"> delta qb </span><span class="si">{}</span><span class="s2"> delta like: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">stag</span><span class="p">,</span> <span class="n">ibin</span><span class="p">,</span> <span class="n">q1</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">like</span> <span class="o">-</span> <span class="n">max_like</span>
                                <span class="p">),</span>
                                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                            <span class="p">)</span>

                        <span class="n">qb_like</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">q_arr</span><span class="p">,</span> <span class="n">like_arr</span><span class="p">])</span>

                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">max_like</span><span class="o">=</span><span class="n">max_like</span><span class="p">,</span> <span class="n">qb_like</span><span class="o">=</span><span class="n">qb_like</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;ERROR_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;error&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_transfer"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_transfer">[docs]</a>    <span class="k">def</span> <span class="nf">get_transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
        <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">save_iters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fix_bb_xfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transfer function from signal simulations created using</span>
<span class="sd">        the same spectrum as the input shape.</span>

<span class="sd">        This raises a ValueError if a negative transfer function amplitude</span>
<span class="sd">        is found.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Maximum fractional change in qb that indicates convergence and</span>
<span class="sd">            stops iteration.</span>
<span class="sd">        iter_max : int</span>
<span class="sd">            Maximum number of iterations to perform.  if this limit is</span>
<span class="sd">            reached, a warning is issued.</span>
<span class="sd">        save_iters : bool</span>
<span class="sd">            If True, the output data from each Fisher iteration are stored</span>
<span class="sd">            in an individual npz file.</span>
<span class="sd">        fix_bb_xfer : bool</span>
<span class="sd">            If True, after transfer functions have been calculated, impose</span>
<span class="sd">            the BB xfer is exactly equal to the EE transfer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qb_transfer : OrderedDict</span>
<span class="sd">            Binned transfer function for each map</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;transfer&#39; checkpoint, and loads or saves</span>
<span class="sd">        a data dictionary named &#39;transfer_all&#39; with the following entries:</span>

<span class="sd">            nbins : int</span>
<span class="sd">                number of bins</span>
<span class="sd">            bin_def : (nbins, 3)</span>
<span class="sd">                bin definition array (see ``get_bin_def``)</span>
<span class="sd">            qb_transfer : (num_maps, nbins)</span>
<span class="sd">                binned transfer function for each map</span>

<span class="sd">        Additionally the final output of ``fisher_iterate`` is stored</span>
<span class="sd">        in a dictionary called ``transfer_map&lt;idx&gt;`` for each map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transfer_shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbins_cmb</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">fix_bb_xfer</span><span class="o">=</span><span class="n">fix_bb_xfer</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;transfer_all&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_wbins&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;transfer&quot;</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;qb_transfer&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">transfer_shape</span><span class="p">,</span>
            <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb_transfer&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb_transfer&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="s2">&quot;cmb_&quot;</span> <span class="o">+</span> <span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">im0</span><span class="p">,</span> <span class="n">m0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">[</span><span class="n">im0</span><span class="p">]]:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_cmb</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Setting map </span><span class="si">{}</span><span class="s2"> transfer to unity&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Computing transfer function for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">im0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
                <span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>
            <span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">m0</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_iterate</span><span class="p">(</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">m0</span><span class="p">,</span>
                <span class="n">transfer_run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">iter_max</span><span class="o">=</span><span class="n">iter_max</span><span class="p">,</span>
                <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
                <span class="n">save_iters</span><span class="o">=</span><span class="n">save_iters</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">]</span>

            <span class="n">success</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error in fisher_iterate for map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>

            <span class="c1"># fix negative amplitude bins</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="p">(</span><span class="n">negbin</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Transfer function amplitude </span><span class="si">{}</span><span class="s2"> &lt; 0&quot;</span>
                        <span class="s2">&quot;for </span><span class="si">{}</span><span class="s2"> bin </span><span class="si">{}</span><span class="s2"> of map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">negbin</span><span class="p">,</span> <span class="n">m0</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># XXX cludge</span>
                    <span class="c1"># This happens in first bin</span>
                    <span class="c1"># try linear interp between zero and next value</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">negbin</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">negbin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;Setting Transfer function in negative bin to small &quot;</span>
                            <span class="s2">&quot;positive. This is probably due to choice of bins or &quot;</span>
                            <span class="s2">&quot;insufficient number of signal sims&quot;</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unable to adjust negative bins for map </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">m0</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># fix the BB transfer to EE, if desired</span>
            <span class="k">if</span> <span class="n">fix_bb_xfer</span><span class="p">:</span>
                <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_ee&quot;</span><span class="p">]</span>

            <span class="c1"># fix TB/EB transfer functions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_ee&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">]))</span>
                <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_tt&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">qbdat</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qbdat</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">success</span> <span class="k">else</span> <span class="s2">&quot;ERROR_&quot;</span><span class="p">,</span> <span class="n">save_name</span><span class="p">),</span>
            <span class="n">from_attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nbins&quot;</span><span class="p">,</span> <span class="s2">&quot;bin_def&quot;</span><span class="p">,</span> <span class="s2">&quot;qb_transfer&quot;</span><span class="p">,</span> <span class="s2">&quot;map_tags&quot;</span><span class="p">],</span>
            <span class="n">cls_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">,</span>
            <span class="n">success</span><span class="o">=</span><span class="n">success</span><span class="p">,</span>
            <span class="o">**</span><span class="n">opts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error computing transfer function: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span></div>

<div class="viewcode-block" id="XFaster.get_bandpowers"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_bandpowers">[docs]</a>    <span class="k">def</span> <span class="nf">get_bandpowers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
        <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">return_qb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_iters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_cls</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_profiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_profile_sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">like_profile_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">file_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the maximum likelihood bandpowers of the data, assuming</span>
<span class="sd">        a given input spectrum shape.  Requires the transfer function to</span>
<span class="sd">        have been computed and loaded using ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        map_tag : string</span>
<span class="sd">            If not None, then iteration is performed over the spectra</span>
<span class="sd">            corresponding to the given map, rather over all possible</span>
<span class="sd">            combinations of map-map cross-spectra. In this case, the first</span>
<span class="sd">            dimension of the input cbl must be of size 1 (this is done</span>
<span class="sd">            automatically by calling ``bin_cl_template(..., map_tag=&lt;map_tag&gt;)``.</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Maximum fractional change in qb that indicates convergence and</span>
<span class="sd">            stops iteration.</span>
<span class="sd">        iter_max : int</span>
<span class="sd">            Maximum number of iterations to perform.  if this limit is</span>
<span class="sd">            reached, a warning is issued.</span>
<span class="sd">        return_qb : bool</span>
<span class="sd">            If True, only the maximum likelihood ``qb`` values are returned.</span>
<span class="sd">            Otherwise, the complete output dictionary is returned.</span>
<span class="sd">        save_iters : bool</span>
<span class="sd">            If True, the output data from each Fisher iteration are stored</span>
<span class="sd">            in an individual npz file.</span>
<span class="sd">        return_cls : bool</span>
<span class="sd">            If True, return C_ls rather than D_ls</span>
<span class="sd">        cond_criteria : float</span>
<span class="sd">            The maximum condition number allowed for Dmat1 to be acceptable</span>
<span class="sd">            for taking its inverse.</span>
<span class="sd">        like_profiles : bool</span>
<span class="sd">            If True, compute profile likelihoods for each qb, leaving all</span>
<span class="sd">            others fixed at their maximum likelihood values.  Profiles are</span>
<span class="sd">            computed over a range +/--sigma as estimated from the diagonals</span>
<span class="sd">            of the inverse Fisher matrix.</span>
<span class="sd">        like_profile_sigma : float</span>
<span class="sd">            Range in units of 1sigma over which to compute profile likelihoods</span>
<span class="sd">        like_profile_points : int</span>
<span class="sd">            Number of points to sample along the likelihood profile</span>
<span class="sd">        file_tag : string</span>
<span class="sd">            If supplied, appended to the bandpowers filename.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            Dictionary of maximum likelihood quantities, as output by</span>
<span class="sd">            ``fisher_iterate``.</span>
<span class="sd">        -- or --</span>
<span class="sd">        qb, inv_fish : array_like</span>
<span class="sd">            Maximum likelihood bandpower amplitudes and fisher covariance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;bandpowers&#39; checkpoint, and loads or</span>
<span class="sd">        saves a data dictionary named &#39;bandpowers&#39; with the quantities</span>
<span class="sd">        returned by ``fisher_iterate``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;bandpowers&quot;</span>

        <span class="n">fish_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)),)</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># check all options that require rerunning fisher iterations</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
            <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;fg_tt&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                <span class="n">ref_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_freq</span><span class="p">,</span>
                <span class="n">beta_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span><span class="p">:</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">template_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_cls</span> <span class="o">=</span> <span class="n">return_cls</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;bandpowers&quot;</span><span class="p">,</span>
            <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">fish_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;inv_fish&quot;</span><span class="p">,</span>
            <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span>
            <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
            <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_qb</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;inv_fish&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>

        <span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_iterate</span><span class="p">(</span>
            <span class="n">cbl</span><span class="p">,</span>
            <span class="n">map_tag</span><span class="p">,</span>
            <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">iter_max</span><span class="o">=</span><span class="n">iter_max</span><span class="p">,</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">save_iters</span><span class="o">=</span><span class="n">save_iters</span><span class="p">,</span>
            <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
            <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
            <span class="n">like_profiles</span><span class="o">=</span><span class="n">like_profiles</span><span class="p">,</span>
            <span class="n">like_profile_sigma</span><span class="o">=</span><span class="n">like_profile_sigma</span><span class="p">,</span>
            <span class="n">like_profile_points</span><span class="o">=</span><span class="n">like_profile_points</span><span class="p">,</span>
            <span class="n">file_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error computing bandpowers&quot;</span><span class="p">)</span>

        <span class="c1"># return</span>
        <span class="k">if</span> <span class="n">return_qb</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;inv_fish&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="XFaster.get_likelihood"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_likelihood">[docs]</a>    <span class="k">def</span> <span class="nf">get_likelihood</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qb</span><span class="p">,</span>
        <span class="n">inv_fish</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lmin</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span>
        <span class="n">lmax</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span>
        <span class="n">mcmc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">alpha_tags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;95&quot;</span><span class="p">,</span> <span class="s2">&quot;150&quot;</span><span class="p">],</span>
        <span class="n">beam_tags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;95&quot;</span><span class="p">,</span> <span class="s2">&quot;150&quot;</span><span class="p">],</span>
        <span class="n">r_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
        <span class="n">alpha_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
        <span class="n">res_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">beam_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">betad_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">dust_amp_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
        <span class="n">dust_ellind_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">num_walkers</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">num_steps</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reset_backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">file_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Explore the likelihood, optionally with an MCMC sampler.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : OrderedDict</span>
<span class="sd">            Bandpower parameters previously computed by Fisher iteration.</span>
<span class="sd">        inv_fish : array_like</span>
<span class="sd">            Inverse Fisher matrix computed with the input qb&#39;s.</span>
<span class="sd">        map_tag : string</span>
<span class="sd">            If not None, then the likelihood is sampled using the spectra</span>
<span class="sd">            corresponding to the given map, rather over all possible</span>
<span class="sd">            combinations of map-map cross-spectra.  The input qb&#39;s and inv_fish</span>
<span class="sd">            must have been computed with the same option.</span>
<span class="sd">        mcmc : bool</span>
<span class="sd">            If True, sample the likelihood using an MCMC sampler.  Remaining options</span>
<span class="sd">            determine parameter space and sampler configuration.</span>
<span class="sd">        r_prior : 2-list or None</span>
<span class="sd">            Prior upper and lower bound on tensor to scalar ratio.  If None, the</span>
<span class="sd">            fiducial shape spectrum is assumed, and the r parameter space is not</span>
<span class="sd">            varied.</span>
<span class="sd">        alpha_prior : 2-list or None</span>
<span class="sd">            Prior upper and lower bound on template coefficients.  If None, the</span>
<span class="sd">            alpha parameter space is not varied.</span>
<span class="sd">        res_prior : 2-list or none</span>
<span class="sd">            Prior upper and lower bound on residual qbs.  If None, the</span>
<span class="sd">            res parameter space is not varied.</span>
<span class="sd">        beam_prior : 2-list or none</span>
<span class="sd">            Prior mean and width of gaussian width on beam error (when</span>
<span class="sd">            multiplied by beam error envelope).  If None, the</span>
<span class="sd">            beam parameter space is not varied.</span>
<span class="sd">        betad_prior : 2-list or none</span>
<span class="sd">            Prior mean and width of gaussian width on dust spectral index.</span>
<span class="sd">            If None, the dust index parameter space is not varied.</span>
<span class="sd">        dust_amp_prior : 2-list or none</span>
<span class="sd">            Prior upper and lower bound on dust amplitude.</span>
<span class="sd">            If None, the dust amp parameter space is not varied.</span>
<span class="sd">        dust_ellind_prior : 2-list or none</span>
<span class="sd">            Prior mean and width of Gaussian prior on difference in dust ell</span>
<span class="sd">            power law index. If None, don&#39;t vary from reference if fitting dust</span>
<span class="sd">            power spectrum model.</span>
<span class="sd">        num_walkers : int</span>
<span class="sd">            Number of unique walkers with which to sample the parameter space.</span>
<span class="sd">        num_steps : int</span>
<span class="sd">            Number of steps each walker should take in sampling the parameter space.</span>
<span class="sd">        reset_backend : bool</span>
<span class="sd">            If True, clear the backend buffer before sampling.  If False,</span>
<span class="sd">            samples are appended to the existing buffer.  If not supplied,</span>
<span class="sd">            set to True if the checkpoint has been forced to be rerun.</span>
<span class="sd">        file_tag : string</span>
<span class="sd">            If supplied, appended to the likelihood filename.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">r_prior</span><span class="p">,</span>
            <span class="n">alpha_prior</span><span class="p">,</span>
            <span class="n">res_prior</span><span class="p">,</span>
            <span class="n">beam_prior</span><span class="p">,</span>
            <span class="n">betad_prior</span><span class="p">,</span>
            <span class="n">dust_amp_prior</span><span class="p">,</span>
            <span class="n">dust_ellind_prior</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;like_mcmc&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mcmc</span><span class="p">:</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">res_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">beam_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">betad_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dust_amp_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dust_ellind_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># no template cleaning if there aren&#39;t any templates specified</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># null out unused priors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_alpha&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="p">):</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># count alpha parameters to fit</span>
        <span class="n">alpha_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">alpha_tags</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha_tags</span><span class="p">):</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">num_alpha</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">alpha_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_alpha</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha_tags</span><span class="p">)</span>

        <span class="c1"># count beam parameters to fit</span>
        <span class="n">beam_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">beam_tags</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">):</span>
            <span class="n">beam_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">num_beam</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_beam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">]):</span>
            <span class="n">res_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">betad_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">dust_amp_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">dust_ellind_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="n">dust_ell_fit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dust_ell_fit</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># bookkeeping: ordered priors</span>
        <span class="n">priors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;r_prior&quot;</span><span class="p">:</span> <span class="n">r_prior</span><span class="p">,</span>
            <span class="s2">&quot;alpha_prior&quot;</span><span class="p">:</span> <span class="n">alpha_prior</span><span class="p">,</span>
            <span class="s2">&quot;res_prior&quot;</span><span class="p">:</span> <span class="n">res_prior</span><span class="p">,</span>
            <span class="s2">&quot;beam_prior&quot;</span><span class="p">:</span> <span class="n">beam_prior</span><span class="p">,</span>
            <span class="s2">&quot;betad_prior&quot;</span><span class="p">:</span> <span class="n">betad_prior</span><span class="p">,</span>
            <span class="s2">&quot;dust_amp_prior&quot;</span><span class="p">:</span> <span class="n">dust_amp_prior</span><span class="p">,</span>
            <span class="s2">&quot;dust_ellind_prior&quot;</span><span class="p">:</span> <span class="n">dust_ellind_prior</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># priors on quantities that affect Dmat_obs or gmat (precalculated)</span>
        <span class="n">obs_priors</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha_prior</span><span class="p">]</span>

        <span class="c1"># check parameter space</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Empty parameter space&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">r_prior</span><span class="o">=</span><span class="n">r_prior</span><span class="p">,</span>
            <span class="n">alpha_prior</span><span class="o">=</span><span class="n">alpha_prior</span><span class="p">,</span>
            <span class="n">res_prior</span><span class="o">=</span><span class="n">res_prior</span><span class="p">,</span>
            <span class="n">beam_prior</span><span class="o">=</span><span class="n">beam_prior</span><span class="p">,</span>
            <span class="n">betad_prior</span><span class="o">=</span><span class="n">betad_prior</span><span class="p">,</span>
            <span class="n">dust_amp_prior</span><span class="o">=</span><span class="n">dust_amp_prior</span><span class="p">,</span>
            <span class="n">dust_ellind_prior</span><span class="o">=</span><span class="n">dust_ellind_prior</span><span class="p">,</span>
            <span class="n">alpha_tags</span><span class="o">=</span><span class="n">alpha_tags</span><span class="p">,</span>
            <span class="n">num_walkers</span><span class="o">=</span><span class="n">num_walkers</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
            <span class="n">lmin</span><span class="o">=</span><span class="n">lmin</span><span class="p">,</span>
            <span class="n">lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mcmc</span> <span class="ow">and</span> <span class="n">reset_backend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span>
                <span class="s2">&quot;likelihood&quot;</span><span class="p">,</span>
                <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span>
                <span class="n">value_ref</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;converged&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">converge_criteria</span> <span class="o">&gt;=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;converge_criteria&quot;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">ret</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pval</span> <span class="o">!=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># clear chain cache if rerunning, otherwise append to chain by default</span>
            <span class="n">reset_backend</span> <span class="o">=</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">)</span>

        <span class="c1"># save state</span>
        <span class="k">if</span> <span class="n">mcmc</span> <span class="ow">and</span> <span class="n">reset_backend</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span>
            <span class="p">)</span>

        <span class="c1"># clear pre-computed quantities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>
        <span class="n">use_precalc</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obs_priors</span><span class="p">])</span>

        <span class="n">cls_input</span><span class="p">,</span> <span class="n">cls_noise</span><span class="p">,</span> <span class="n">cls_debias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_spectra</span><span class="p">()</span>

        <span class="c1"># extract residual bins, ignoring bins outside of lmin/lmax</span>
        <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_def_orig</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>
            <span class="n">nbins_res_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span>
            <span class="n">qb_res</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">num_res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">qb</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">):</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">bd</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bd</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lmax</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># use all qb res in range lmin, lmax</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bd</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="n">good</span><span class="p">]</span>
                    <span class="n">num_res</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                    <span class="c1"># use average qb res in good range per map</span>
                    <span class="c1"># self.bin_def[k] = np.array([[lmin, lmax + 1]])</span>
                    <span class="c1"># v = np.array([(qb.pop(k)[good]).mean()])</span>
                    <span class="c1"># num_res += 1</span>
                    <span class="n">qb_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">=</span> <span class="n">num_res</span>

        <span class="c1"># set CMB model bandpowers to unity, since we are computing</span>
        <span class="c1"># the likelihood of this model given the data</span>
        <span class="k">if</span> <span class="n">r_prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing model spectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Beam variation not implemented for case of no r fit&quot;</span><span class="p">)</span>
            <span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">)</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">stags</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">stag</span> <span class="ow">in</span> <span class="n">stags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing r model spectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="n">cls_shape_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_shape</span><span class="p">(</span>
                <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;scalar&quot;</span>
            <span class="p">)</span>

            <span class="n">cls_shape_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_shape</span><span class="p">(</span>
                <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;tensor&quot;</span>
            <span class="p">)</span>

            <span class="c1"># load tensor and scalar terms separately</span>
            <span class="n">cbl_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">cls_shape_scalar</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">)</span>
            <span class="n">cls_model_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_scalar</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span>
            <span class="p">)</span>
            <span class="n">cbl_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">cls_shape_tensor</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">)</span>
            <span class="n">cls_model_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_tensor</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># load beam error term for tensor and scalar</span>
                <span class="n">cbl_scalar_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                    <span class="n">cls_shape_scalar</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">,</span> <span class="n">beam_error</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">cls_mod_scal_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                    <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_scalar_beam</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">cbl_tensor_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                    <span class="n">cls_shape_tensor</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">,</span> <span class="n">beam_error</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">cls_mod_tens_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                    <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_tensor_beam</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

            <span class="c1"># load foreground shape</span>
            <span class="k">if</span> <span class="n">dust_ell_fit</span><span class="p">:</span>
                <span class="n">cls_shape_dust</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_shape</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;fg&quot;</span><span class="p">)</span>
                <span class="c1"># if dust_ellind_prior is None:</span>
                <span class="c1">#    # can preload shape since not varying ell index</span>
                <span class="n">cbl_fg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">cls_shape_dust</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cbl_fg_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                        <span class="n">cls_shape_dust</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">,</span> <span class="n">beam_error</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

            <span class="n">cbl</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cbl_scalar</span><span class="p">)</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cls_model_scalar</span><span class="p">)</span>

        <span class="c1"># XXX TODO</span>
        <span class="c1"># how to marginalize over the garbage bin?</span>

        <span class="k">def</span> <span class="nf">parse_params</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Parse array of parameters into a dict</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">r_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">alpha_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="n">num_alpha</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">num_alpha</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="n">num_res</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">num_res</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;beam&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="n">num_beam</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">num_beam</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">betad_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;betad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">dust_amp_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># param for ee and bb</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;dust_amp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">dust_ellind_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;dust_ellind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many parameters to parse&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">params</span>

        <span class="k">def</span> <span class="nf">log_prior</span><span class="p">(</span>
            <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">beam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">betad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dust_amp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dust_ellind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log prior function constructed from input options</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;r_prior&quot;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span>
                <span class="s2">&quot;alpha_prior&quot;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span>
                <span class="s2">&quot;res_prior&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span>
                <span class="s2">&quot;dust_amp_prior&quot;</span><span class="p">:</span> <span class="n">dust_amp</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pval</span> <span class="o">&lt;</span> <span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pval</span> <span class="o">&gt;</span> <span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="n">values_gauss</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;beam_prior&quot;</span><span class="p">:</span> <span class="n">beam</span><span class="p">,</span>
                <span class="s2">&quot;betad_prior&quot;</span><span class="p">:</span> <span class="n">betad</span><span class="p">,</span>
                <span class="s2">&quot;dust_ellind_prior&quot;</span><span class="p">:</span> <span class="n">dust_ellind</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="c1"># for beam and betad, use gaussian prior</span>
            <span class="n">log_prob</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">values_gauss</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
                    <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">pval</span> <span class="o">-</span> <span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">log_prob</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">-</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">log_prob</span>

        <span class="k">def</span> <span class="nf">log_like</span><span class="p">(</span>
            <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">beam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">betad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dust_amp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dust_ellind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log likelihood function constructed from input options</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">cls_model0</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cls_model</span><span class="p">)</span>

            <span class="c1"># compute new template subtracted data spectra</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clsi</span> <span class="o">=</span> <span class="n">cls_input</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_masked_data</span><span class="p">(</span><span class="n">template_alpha</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">alpha_tags</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)))</span>
                <span class="n">clsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_spectra</span><span class="p">(</span><span class="n">do_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">beam</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">,</span> <span class="n">beam</span><span class="p">))</span>
                <span class="n">beam_coeffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs_orig</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">b0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b0</span>
                    <span class="k">if</span> <span class="n">b1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;b2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span>
                        <span class="k">if</span> <span class="n">b0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;b3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">b1</span>
                    <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

            <span class="c1"># compute new signal shape by scaling tensor component by r</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_model0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ctag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dd</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">cls_model_scalar</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cls_model_tensor</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="p">)</span>

                        <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">beam_term</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">beam_term</span> <span class="o">+=</span> <span class="n">bc</span> <span class="o">*</span> <span class="p">(</span>
                                <span class="n">cls_mod_scal_beam</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                                <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cls_mod_tens_beam</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="n">dd</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">beam_term</span>

            <span class="k">elif</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_model0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ctag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">beam_term</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">beam_term</span> <span class="o">+=</span> <span class="n">bc</span> <span class="o">*</span> <span class="n">cls_mod_scal_beam</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                        <span class="n">dd</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cls_model_scalar</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+</span> <span class="n">beam_term</span>

            <span class="c1"># fg term, including beam modifications. Because mix terms are</span>
            <span class="c1"># dependent on dust amp, get model specs here.</span>
            <span class="k">if</span> <span class="n">dust_ell_fit</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dust_amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;fg_ee&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;fg_bb&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;fg_ee&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">dust_amp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;fg_bb&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">dust_amp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">betad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">betad</span>
                <span class="k">if</span> <span class="n">dust_ellind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cbl_fg0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                        <span class="n">cls_shape_dust</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">fg_ell_ind</span><span class="o">=</span><span class="n">dust_ellind</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">cbl_fg_beam0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                            <span class="n">cls_shape_dust</span><span class="p">,</span>
                            <span class="n">map_tag</span><span class="p">,</span>
                            <span class="n">fg_ell_ind</span><span class="o">=</span><span class="n">dust_ellind</span><span class="p">,</span>
                            <span class="n">beam_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cbl_fg0</span> <span class="o">=</span> <span class="n">cbl_fg</span>
                    <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">cbl_fg_beam0</span> <span class="o">=</span> <span class="n">cbl_fg_beam</span>

                <span class="n">cls_model_fg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                    <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_fg0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cls_mod_fg_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                        <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_fg_beam0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                <span class="c1"># add fg field to model, and add fg to total model</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_model_fg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ftag</span> <span class="o">=</span> <span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model0</span><span class="p">:</span>
                        <span class="n">cls_model0</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model0</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                            <span class="n">cls_model0</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_model_fg</span><span class="p">[</span><span class="n">ftag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cls_model0</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cls_model_fg</span><span class="p">[</span><span class="n">ftag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

                        <span class="c1"># add beam terms to fg and total fields</span>
                        <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">beam_term</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">beam_term</span> <span class="o">+=</span> <span class="n">bc</span> <span class="o">*</span> <span class="n">cls_mod_fg_beam</span><span class="p">[</span><span class="n">ftag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                            <span class="n">cls_model0</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+=</span> <span class="n">beam_term</span>

            <span class="c1"># compute noise model terms</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clsm</span> <span class="o">=</span> <span class="n">cls_model0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">qb_res</span><span class="p">)</span>
                <span class="n">clsm</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cls_model0</span><span class="p">)</span>
                <span class="n">cls_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">cbl</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_res</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clsm</span><span class="p">:</span>
                        <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                            <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">dd</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dd</span>

            <span class="c1"># compute likelihood</span>
            <span class="n">like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">clsi</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">cls_debias</span><span class="p">,</span>
                <span class="n">cls_model</span><span class="o">=</span><span class="n">clsm</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                <span class="n">likelihood</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">use_precalc</span><span class="o">=</span><span class="n">use_precalc</span><span class="p">,</span>
                <span class="n">like_lmin</span><span class="o">=</span><span class="n">lmin</span><span class="p">,</span>
                <span class="n">like_lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">like</span>

        <span class="k">def</span> <span class="nf">log_prob</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log posterior probability from prior and likelihood</span>

<span class="sd">            Returns log_prior with each step</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">parse_params</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">prior</span> <span class="o">=</span> <span class="n">log_prior</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">prior</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">like</span> <span class="o">=</span> <span class="n">log_like</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">prior</span>
            <span class="k">return</span> <span class="n">prior</span> <span class="o">+</span> <span class="n">like</span><span class="p">,</span> <span class="n">prior</span>

        <span class="c1"># initial values</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">mcmc</span> <span class="k">else</span> <span class="kc">False</span>  <span class="c1"># only vary r</span>
        <span class="k">if</span> <span class="n">r_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">alpha_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">alpha_tags</span><span class="p">]</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alphas</span><span class="p">]</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">qb_res</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># add a beam term for each frequency</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">)</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">betad_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">]</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">dust_amp_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">dust_ellind_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">]</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">num_walkers</span><span class="p">:</span>
            <span class="n">num_walkers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ndim</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">))</span> <span class="o">*</span> <span class="n">num_walkers</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> parameters, increasing number of MCMC walkers to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">ndim</span><span class="p">,</span> <span class="n">num_walkers</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">brute_force</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing brute-force r profile likelihood&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">likefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.txt&quot;</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
            <span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rs</span><span class="p">):</span>
                <span class="n">like</span> <span class="o">=</span> <span class="n">log_like</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;r = </span><span class="si">{:.3f}</span><span class="s2">, loglike = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">like</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                <span class="n">likes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">like</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> r likelihood</span><span class="se">\n</span><span class="s2">Columns: r, loglike&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s2">&quot;Multi-map&quot;</span> <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_tag</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">likefile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">rs</span><span class="p">,</span> <span class="n">likes</span><span class="p">)),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mcmc</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">rs</span><span class="p">,</span> <span class="n">likes</span><span class="p">]</span>

        <span class="c1"># run chains!</span>
        <span class="kn">import</span> <span class="nn">emcee</span>

        <span class="c1"># setup sampler output file</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">backend_exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">HDFBackend</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">backend_exists</span> <span class="ow">and</span> <span class="n">backend</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Expected backend of shape (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), found </span><span class="si">{}</span><span class="s2">. Resetting&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">backend</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">reset_backend</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">reset_backend</span><span class="p">:</span>
            <span class="n">backend</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>

        <span class="c1"># initialize sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Initializing sampler&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">log_prob</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reset_backend</span> <span class="ow">and</span> <span class="n">backend_exists</span><span class="p">:</span>
            <span class="c1"># grab the last sample if appending to an existing run</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># track autocorrelation time</span>
        <span class="n">old_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;Starting </span><span class="si">{}</span><span class="s2"> iterations with </span><span class="si">{}</span><span class="s2"> parameters&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">ndim</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;MCMC iteration </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="c1"># check convergence every 100 steps</span>
            <span class="k">if</span> <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># compute autocorrelation time</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_autocorr_time</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># check convergence</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">tau</span> <span class="o">/</span> <span class="n">converge_criteria</span> <span class="o">&lt;</span> <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>
            <span class="n">converged</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">old_tau</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">/</span> <span class="n">tau</span> <span class="o">&lt;</span> <span class="n">converge_criteria</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;MCMC iteration </span><span class="si">{}</span><span class="s2"> autocorr time: mean </span><span class="si">{:.1f}</span><span class="s2"> min </span><span class="si">{:.1f}</span><span class="s2"> max </span><span class="si">{:.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">converged</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">old_tau</span> <span class="o">=</span> <span class="n">tau</span>

        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converged</span><span class="o">=</span><span class="n">converged</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># converged posterior distribution</span>
        <span class="k">if</span> <span class="n">converged</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;MCMC converged in </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
            <span class="p">)</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_autocorr_time</span><span class="p">()</span>
            <span class="n">burnin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
            <span class="n">thin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_chain</span><span class="p">(</span><span class="n">discard</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;MCMC not converged in </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_steps</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span> <span class="o">=</span> <span class="n">bin_def_orig</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">=</span> <span class="n">nbins_res_orig</span>

        <span class="c1"># save and return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span>
        <span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, A. Gambrel, A. Rahlin, C. Contaldi.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
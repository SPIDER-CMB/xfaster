

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Tutorial &mdash; xfaster 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="API Reference" href="../api.html" />
    <link rel="prev" title="Algorithm" href="../algorithm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> xfaster
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../algorithm.html">Algorithm</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#The-main-ingredients-of-the-XFaster-code">The main ingredients of the XFaster code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Specifying-what-data-to-use">Specifying what data to use</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Maps">Maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Other-inputs">Other inputs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Step-by-step-through-the-functions-called-in-xfaster_exec">Step by step through the functions called in xfaster_exec</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Setup-and-checkpoints">Setup and checkpoints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_files">get_files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_bin_def">get_bin_def</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_mask_weights">get_mask_weights</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_kernels">get_kernels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_masked_sims">get_masked_sims</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_beams">get_beams</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_signal_shape">get_signal_shape</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_transfer">get_transfer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_masked_data">get_masked_data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_masked_sims-(for-replacing-data)">get_masked_sims (for replacing data)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_masked_fake_data">get_masked_fake_data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get_bandpowers">get_bandpowers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Constructing-the-model-spectrum">Constructing the model spectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Computing-the-Fisher-matrix">Computing the Fisher matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Constructing-final-bandpowers">Constructing final bandpowers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Looking-at-results">Looking at results</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#get_likelihood">get_likelihood</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">xfaster</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/notebooks/XFaster_Tutorial.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Tutorial">
<h1>Tutorial<a class="headerlink" href="#Tutorial" title="Permalink to this headline">¶</a></h1>
<p>This tutorial is also a Jupyter notebook, which can be found in <a class="reference external" href="https://github.com/annegambrel/xfaster/tree/main/example/notebooks">the example notebooks directory</a>. If you’re running the notebook, rather than looking at the documentation produced from it, the links will not work. <a class="reference external" href="https://annegambrel.github.io/xfaster/notebooks/XFaster_Tutorial.html">Look at the docs for working links</a>.</p>
<p>The notebook reads intermediate output npz files from disk. To instead run the pieces starting from maps, first generate the example maps by running the script <code class="docutils literal notranslate"><span class="pre">xfaster/example/make_example_maps.py</span></code>, and set the checkpoint to something other than None.</p>
<div class="section" id="The-main-ingredients-of-the-XFaster-code">
<h2>The main ingredients of the XFaster code<a class="headerlink" href="#The-main-ingredients-of-the-XFaster-code" title="Permalink to this headline">¶</a></h2>
<p>Before we get into the functions that produce each of the components that gets fed into the equations for bandpower deviations, <span class="math notranslate nohighlight">\(q_b\)</span> and the Fisher matrix (Equations 17 and 18 in the <a class="reference internal" href="../algorithm.html"><span class="doc">Algorithm section</span></a>), let’s first talk about how XFaster is structured and what it expects as inputs.</p>
<p>There are two main python modules in XFaster: <a class="reference internal" href="../api.html#module-xfaster.xfaster_exec"><span class="std std-ref">xfaster_exec.py</span></a> and <a class="reference internal" href="../api.html#module-xfaster.xfaster_class"><span class="std std-ref">xfaster_class.py</span></a>. <a class="reference internal" href="../api.html#module-xfaster.xfaster_exec"><span class="std std-ref">xfaster_exec.py</span></a> contains two main functions: <a class="reference internal" href="../api.html#xfaster.xfaster_exec.xfaster_run"><span class="std std-ref">xfaster_run</span></a> and <a class="reference internal" href="../api.html#xfaster.xfaster_exec.xfaster_submit"><span class="std std-ref">xfaster_submit</span></a>. <a class="reference internal" href="../api.html#xfaster.xfaster_exec.xfaster_run"><span class="std std-ref">xfaster_run</span></a> calls all of the functions to make
XFaster happen (all located in <a class="reference internal" href="../api.html#module-xfaster.xfaster_class"><span class="std std-ref">xfaster_class.py</span></a>) in the order they need to happen. <a class="reference internal" href="../api.html#xfaster.xfaster_exec.xfaster_submit"><span class="std std-ref">xfaster_submit</span></a> takes arguments for submitting the job to a queue. XFaster is not highly parallelized. However, significant speed-up is gained from using more cores in the simulation pseudo-spectrum calculation through under-the-hood use of OMP. Therefore, if you’re starting from a checkpoint after “sims”, no
significant speed-up will be gained when using more cores.</p>
<p>There are a few other modules you might interact with:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api.html#module-xfaster.parse_tools"><span class="std std-ref">parse_tools.py</span></a>: contains a bunch of tools for converting between data structures, especially between dictionaries and matrices</p></li>
<li><p><a class="reference internal" href="../api.html#module-xfaster.xfaster_tools"><span class="std std-ref">xfaster_tools.py</span></a>: contains small functions used in xfaster_class</p></li>
</ul>
</div>
<div class="section" id="Specifying-what-data-to-use">
<h2>Specifying what data to use<a class="headerlink" href="#Specifying-what-data-to-use" title="Permalink to this headline">¶</a></h2>
<p>The top level module you interact with is <a class="reference internal" href="../api.html#module-xfaster.xfaster_exec"><span class="std std-ref">xfaster_exec.py</span></a>, which takes your arguments, and has some reasonable defaults for any you don’t provide. In addition to arguments, you must point the code to the inputs you want to run on. The first of these inputs is maps.</p>
<div class="section" id="Maps">
<h3>Maps<a class="headerlink" href="#Maps" title="Permalink to this headline">¶</a></h3>
<p>The main inputs to the code are maps– data maps, signal and noise simulations, and masks. Rather than pointing to each map individually, there is a directory structure that the code expects. Its contents look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;data_root&gt;/
├── data_&lt;data_type&gt;
│   ├── &lt;data_subset1&gt;
│   │   ├── map_&lt;tag1&gt;.fits
│   │   ├── ...
│   │   ├── map_&lt;tagN&gt;.fits
│   ├── &lt;data_subset2&gt; (same filenames as &lt;data_subset1&gt;)
│   ├── ....
│   ├── &lt;data_subsetM&gt;
├── signal_&lt;signal_type&gt;
│   ├── spec_signal_&lt;signal_type&gt;.dat
│   ├── &lt;data_subset1&gt;
│   │   ├── map_&lt;tag1&gt;_0000.fits
│   │   ├── ...
│   │   ├── map_&lt;tag1&gt;_####.fits
│   │   ├── ...
│   │   ├── map_&lt;tagN&gt;_0000.fits
│   │   ├── ...
│   │   ├── map_&lt;tagN&gt;_####.fits
│   ├── ....
│   ├── &lt;data_subsetM&gt; (same filenames as &lt;data_subset1&gt;)
├── noise_&lt;noise_type&gt; (same filenames as signal_&lt;signal_type&gt;)
├── masks_&lt;mask_type&gt;
│   ├── mask_map_&lt;tag1&gt;.fits
│   ├── ...
│   ├── mask_map_&lt;tagN&gt;.fits
[[optional:]]
├── foreground_&lt;foreground_type&gt; (same filenames as signal_&lt;signal_type&gt;
├── templates_&lt;template_type&gt;
│   ├── halfmission-1 (same filenames as data_&lt;data_type&gt;)
│   ├── halfmission-2 (same filenames as data_&lt;data_type&gt;)
└── reobs_planck (same filenames as templates_&lt;template_type&gt;, used if sub_planck=True for null tests)
</pre></div>
</div>
<p>Each of <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">signal</span></code>, <code class="docutils literal notranslate"><span class="pre">noise</span></code>, and <code class="docutils literal notranslate"><span class="pre">mask</span></code> has a top level directory with a preordained, fixed prefix (<code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">signal</span></code>, <code class="docutils literal notranslate"><span class="pre">noise</span></code>, <code class="docutils literal notranslate"><span class="pre">mask</span></code>) and then some suffix specified by the user which is appended with an underscore. So, for example, to run XFaster on the example set of maps, I need to specify in my arguments: <code class="docutils literal notranslate"><span class="pre">data_type=raw</span></code>, <code class="docutils literal notranslate"><span class="pre">signal_type=synfast</span></code>, <code class="docutils literal notranslate"><span class="pre">noise_type=gaussian</span></code>, <code class="docutils literal notranslate"><span class="pre">mask_type=rectangle</span></code>.</p>
<p>All maps must be HEALPIX fits files. Data maps must be named <code class="docutils literal notranslate"><span class="pre">map_&lt;tag&gt;.fits</span></code>; simulated signal and noise maps must be named <code class="docutils literal notranslate"><span class="pre">map_&lt;tag&gt;_####.fits</span></code>, where #### is any length numerical tag indicating a sim realization; and masks are labeled <code class="docutils literal notranslate"><span class="pre">mask_map_&lt;tag&gt;.fits</span></code>.</p>
<p>If using <code class="docutils literal notranslate"><span class="pre">pol=True</span></code>, masks must be 3 x Npix I,Q,U maps. You can use a different mask for intensity and polarization, in which case your mask must be 2 x Npix, where the first row is used for T and the second for P.</p>
<p>To indicate which maps you want, pass the argument <code class="docutils literal notranslate"><span class="pre">data_subset</span></code> a glob-parseable path relative to the top level data directory– in this case, <code class="docutils literal notranslate"><span class="pre">data_raw</span></code>. <a class="reference external" href="https://docs.python.org/3/library/glob.html">Glob</a> works just like the unix shell does for matching file paths, so it is easy to test in advance which maps you’re going to get. Just do <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">&lt;path_to_data_maps&gt;/full/*150*</span></code> and check that all the maps you want to use are listed. Then, you should set <code class="docutils literal notranslate"><span class="pre">data_subset</span></code> to <code class="docutils literal notranslate"><span class="pre">full/*150*</span></code>,
for example.</p>
<p>This is all implemented in <code class="docutils literal notranslate"><span class="pre">_get_files()</span></code> (called by <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_files"><span class="std std-ref">get_files()</span></a>) like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># find all map files</span>
<span class="n">map_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;data_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_type</span><span class="p">))</span>
<span class="n">map_files</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data_subset</span> <span class="o">=</span> <span class="n">data_subset</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">data_subset</span><span class="p">):</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing files in data subset </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="n">map_files</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
<span class="n">data_subset</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_subset</span><span class="p">)</span>
<span class="n">map_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">map_files</span><span class="p">)</span>
<span class="n">map_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;map_&quot;</span><span class="p">)]</span>
<span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span>
<span class="p">]</span>
</pre></div>
</div>
<p>So you’ve specified which data maps you want to compute power spectra for. To get the corresponding sim maps, the code takes whatever data maps were found matching data_subset, and tries to match those to maps in the sims directory, with the only difference the sim index tag. Here’s what that looks like for signal sims, in the same function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># find all corresponding signal sims</span>
<span class="n">signal_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;signal_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_type</span><span class="p">))</span>
<span class="n">num_signal</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">signal_files</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
    <span class="n">sfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
            <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="n">signal_root</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_subset</span><span class="p">))))</span>
    <span class="n">nsims1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sfiles</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nsims1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing signal sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="o">...</span>
    <span class="n">signal_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sfiles</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s easy to get errors at the reading files step. XFaster requires that all your maps have the same number of sims, though you are allowed to have a different from of signal and noise sims. If you do not want to use the full set of signal and noise maps in a directory, if you can set the <code class="docutils literal notranslate"><span class="pre">signal_subset</span></code> and <code class="docutils literal notranslate"><span class="pre">noise_subset</span></code> arguments, which default to <code class="docutils literal notranslate"><span class="pre">'*'</span></code>. This glob-parseable tag is applied to the <code class="docutils literal notranslate"><span class="pre">####</span></code> sim index tag. So, if I have a set of sims, eg,
<code class="docutils literal notranslate"><span class="pre">map_95_0000.fits</span></code>-<code class="docutils literal notranslate"><span class="pre">map_95_0099.fits</span></code>, as in the example, but for some reason I only want to use the first 50, I can set <code class="docutils literal notranslate"><span class="pre">signal_subset='00[0-4]*</span></code>.</p>
</div>
<div class="section" id="Other-inputs">
<h3>Other inputs<a class="headerlink" href="#Other-inputs" title="Permalink to this headline">¶</a></h3>
<p>In addition to maps, the code also requires a config file. This tells the code everything else it needs to know about your data. Here’s the config file for the example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Band centers in GHz (needed for foreground fitting) for each map tag.</span>
<span class="c1"># Tags listed here should be a superset of tags that may be included in a run.</span>
<span class="p">[</span><span class="n">frequencies</span><span class="p">]</span>
<span class="mi">95</span> <span class="o">=</span> <span class="mf">94.7</span>
<span class="mi">150</span> <span class="o">=</span> <span class="mf">151.0</span>

<span class="c1"># A numpy dictionary containing Bl for each map tag.</span>
<span class="c1"># Keys should match those in freqs.</span>
<span class="c1"># Missing keys should have a fwhm listed below.</span>
<span class="c1"># The value for each key should be a numpy array of dimensions (3, lmax + 1),</span>
<span class="c1"># for TT, TP and PP beam windows.</span>
<span class="p">[</span><span class="n">beam</span><span class="p">]</span>
<span class="n">beam_product</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">beam_error_product</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># FHWM in arcmin for each map tag, if using Gaussian beam model.</span>
<span class="c1"># Keys should match those in freqs.</span>
<span class="c1"># Missing keys should be in the beam product file.</span>
<span class="p">[</span><span class="n">fwhm</span><span class="p">]</span>
<span class="mi">95</span> <span class="o">=</span> <span class="mi">41</span>
<span class="mi">150</span> <span class="o">=</span> <span class="mi">29</span>

<span class="c1"># Fractional error on the FWHM for each map tag, if using a Gaussian beam model.</span>
<span class="c1"># Keys should match those in freqs.</span>
<span class="c1"># Missing keys should be in the beam product file.</span>
<span class="p">[</span><span class="n">fwhm_err</span><span class="p">]</span>
<span class="mi">95</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="mi">150</span> <span class="o">=</span> <span class="mf">0.001</span>

<span class="c1"># Whether to compute transfer function qb parameters for each map tag.</span>
<span class="c1"># Keys should match those in freqs.</span>
<span class="p">[</span><span class="n">transfer</span><span class="p">]</span>
<span class="mi">95</span> <span class="o">=</span> <span class="n">true</span>
<span class="mi">150</span> <span class="o">=</span> <span class="n">true</span>
</pre></div>
</div>
<p>This is the full list of options that can be specified in the config file.</p>
</div>
</div>
<div class="section" id="Step-by-step-through-the-functions-called-in-xfaster_exec">
<h2>Step by step through the functions called in xfaster_exec<a class="headerlink" href="#Step-by-step-through-the-functions-called-in-xfaster_exec" title="Permalink to this headline">¶</a></h2>
<div class="section" id="Setup-and-checkpoints">
<h3>Setup and checkpoints<a class="headerlink" href="#Setup-and-checkpoints" title="Permalink to this headline">¶</a></h3>
<p>Now we’ll proceed to stepping through each function in <a class="reference internal" href="../api.html#module-xfaster.xfaster_exec"><span class="std std-ref">xfaster_exec</span></a>. You’ll never run the code this way–you’ll just call <a class="reference internal" href="../api.html#xfaster.xfaster_exec.xfaster_run"><span class="std std-ref">xfaster_run</span></a> or <a class="reference internal" href="../api.html#xfaster.xfaster_exec.xfaster_submit"><span class="std std-ref">xfaster_submit</span></a> with the arguments that then get passed to these functions. But we’ll do it this way so we can illustrate some of the intermediate data products as we go.</p>
<p>This tutorial will follow the example script in <a class="reference external" href="https://github.com/annegambrel/xfaster/tree/main/example">xfaster/example</a>. Note however that becasue maps are not stored in the repository, this notebook is instead reading from the intermediate files written to disk.</p>
<p>First, we’ll import XFaster and initialize our XFaster class with some arguments.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">xfaster</span> <span class="k">as</span> <span class="nn">xf</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">X</span> <span class="o">=</span> <span class="n">xf</span><span class="o">.</span><span class="n">XFaster</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="s2">&quot;../../example/config_example.ini&quot;</span><span class="p">,</span> <span class="n">output_root</span><span class="o">=</span><span class="s2">&quot;../../example/outputs_example&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="s2">&quot;info&quot;</span><span class="p">,</span>
              <span class="n">output_tag</span><span class="o">=</span><span class="s2">&quot;95x150&quot;</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">checkpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>At the start of an XFaster run, you can specify at what checkpoint to start. The checkpoints are:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">checkpoints</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;files&quot;</span><span class="p">,</span> <span class="c1"># find all the map files</span>
    <span class="s2">&quot;masks&quot;</span><span class="p">,</span> <span class="c1"># load in masks and compute their pseudo-spectra</span>
    <span class="s2">&quot;kernels&quot;</span><span class="p">,</span> <span class="c1"># compute mask mode-coupling kernels</span>
    <span class="s2">&quot;sims_transfer&quot;</span><span class="p">,</span> <span class="c1"># compute pseudo-spectra for signal sims used for computing the transfer function</span>
    <span class="s2">&quot;shape_transfer&quot;</span><span class="p">,</span> <span class="c1"># load in the model spectrum for the transfer function</span>
    <span class="s2">&quot;transfer&quot;</span><span class="p">,</span> <span class="c1"># compute the transfer function</span>
    <span class="s2">&quot;sims&quot;</span><span class="p">,</span> <span class="c1"># compute pseudo-spectra for noise sims and signal sims if they&#39;re different from those used for the transfer function</span>
    <span class="s2">&quot;beams&quot;</span><span class="p">,</span> <span class="c1"># load in the beam window functions, and apply a pixel window function if pixwin=True</span>
    <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="c1"># compute the pseudo-spectra of the data maps</span>
    <span class="s2">&quot;template_noise&quot;</span><span class="p">,</span> <span class="c1"># compute the pseudo-spectra of template noise simulations, if using Planck dust templates</span>
    <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="c1"># load in the model spectrum for bandpower computation</span>
    <span class="s2">&quot;bandpowers&quot;</span><span class="p">,</span> <span class="c1"># do the Fisher iteration to compute bandpowers</span>
    <span class="s2">&quot;beam_errors&quot;</span><span class="p">,</span> <span class="c1"># start the likelihood over including beam error parameterization</span>
    <span class="s2">&quot;likelihood&quot;</span><span class="p">,</span> <span class="c1"># compute the parameter likelihoods</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Note that there are options to use different signal simulations for computing the transfer function and for computing other signal terms. This is mainly useful for null tests, as that’s the only mode in which signal sims are used for anything other than transfer functions (to compute the expected signal residual that is subtracted from the data pseudo-spectra). If the signal simulations lack sufficient power (eg., for BB), the transfer function may not converge due to lack of measurable power.
This is not a problem unique to XFaster, and this option allows the user more flexibility in the choice of sims used for different parts of the algorithm.</p>
<p>Most of the time, <code class="docutils literal notranslate"><span class="pre">checkpoint</span></code> can be set to None, which starts the code from the last checkpoint completed (ie, it successfully wrote its intermediate data to disk). However, if you’ve made changes to the code or inputs, you may wish to force the code to start from an earlier checkpoint. It will then run that checkpoint and every one after it in the checkpoint tree (given near the top of <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster"><span class="std std-ref">the XFaster class</span></a>).</p>
</div>
<div class="section" id="get_files">
<h3>get_files<a class="headerlink" href="#get_files" title="Permalink to this headline">¶</a></h3>
<p>The first function called after initializing the XFaster class is <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_files"><span class="std std-ref">get_files()</span></a>. This takes all your arguments specifying what maps to use and finds them all on disk/checks that they’re there.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_opts</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;data_root&quot;</span><span class="p">:</span> <span class="s2">&quot;../../example/maps_example&quot;</span><span class="p">,</span>
    <span class="s2">&quot;data_subset&quot;</span><span class="p">:</span> <span class="s2">&quot;full/*95,full/*150&quot;</span><span class="p">,</span>
    <span class="s2">&quot;data_type&quot;</span><span class="p">:</span> <span class="s2">&quot;raw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;noise_type&quot;</span><span class="p">:</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mask_type&quot;</span><span class="p">:</span> <span class="s2">&quot;rectangle&quot;</span><span class="p">,</span>
    <span class="s2">&quot;signal_type&quot;</span><span class="p">:</span> <span class="s2">&quot;synfast&quot;</span><span class="p">,</span>
<span class="p">}</span>

</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_vars</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_files</span><span class="p">(</span><span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dict_keys([&#39;data_root&#39;, &#39;data_subset&#39;, &#39;map_root&#39;, &#39;map_files&#39;, &#39;map_tags&#39;, &#39;map_pairs&#39;, &#39;map_tags_orig&#39;, &#39;map_pairs_orig&#39;, &#39;map_freqs&#39;, &#39;raw_root&#39;, &#39;raw_files&#39;, &#39;signal_root&#39;, &#39;signal_files&#39;, &#39;signal_root_sim&#39;, &#39;signal_files_sim&#39;, &#39;signal_transfer_root&#39;, &#39;signal_transfer_files&#39;, &#39;noise_root&#39;, &#39;noise_files&#39;, &#39;noise_root_sim&#39;, &#39;noise_files_sim&#39;, &#39;mask_root&#39;, &#39;mask_files&#39;, &#39;foreground_root&#39;, &#39;foreground_files&#39;, &#39;data_type&#39;, &#39;noise_type&#39;, &#39;noise_type_sim&#39;, &#39;mask_type&#39;, &#39;signal_type&#39;, &#39;signal_type_sim&#39;, &#39;signal_transfer_type&#39;, &#39;signal_subset&#39;, &#39;noise_subset&#39;, &#39;foreground_type_sim&#39;, &#39;num_maps&#39;, &#39;num_signal&#39;, &#39;num_signal_transfer&#39;, &#39;num_noise&#39;, &#39;num_noise_sim&#39;, &#39;num_signal_sim&#39;, &#39;num_foreground&#39;, &#39;num_corr&#39;, &#39;num_spec&#39;, &#39;num_spec_mask&#39;, &#39;num_kern&#39;, &#39;data_shape&#39;, &#39;mask_shape&#39;, &#39;kern_shape&#39;, &#39;null_run&#39;, &#39;template_type&#39;, &#39;template_root&#39;, &#39;template_root2&#39;, &#39;template_files&#39;, &#39;template_files2&#39;, &#39;template_noise_root&#39;, &#39;template_noise_root2&#39;, &#39;template_noise_files&#39;, &#39;template_noise_files2&#39;, &#39;num_template&#39;, &#39;num_template_noise&#39;, &#39;planck_root1_hm1&#39;, &#39;planck_root2_hm1&#39;, &#39;planck_root1_hm2&#39;, &#39;planck_root2_hm2&#39;, &#39;planck_files1_hm1&#39;, &#39;planck_files2_hm1&#39;, &#39;planck_files1_hm2&#39;, &#39;planck_files2_hm2&#39;, &#39;num_planck&#39;, &#39;data_version&#39;, &#39;output_file&#39;])
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">file_vars</span></code> is a dictionary returned by <code class="docutils literal notranslate"><span class="pre">get_files</span></code> that is also written to disk to finish the checkpoint. There are a lot of things stored in this dictionary that are mainly used internally by the code and aren’t useful to an end user. For example, <code class="docutils literal notranslate"><span class="pre">num_corr</span></code> is the number of crosss-correlations of maps, which is used as a dimension to set up data structures later on. But, some of these things might be useful for debuggin. For example, all of the files found using your glob-parseable file
tags are stored here, so you can see exactly what maps are being used for data:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_vars</span><span class="p">[</span><span class="s1">&#39;map_files&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([&#39;../../example/maps_example/data_raw/full/map_150.fits&#39;,
       &#39;../../example/maps_example/data_raw/full/map_95.fits&#39;],
      dtype=&#39;&lt;U53&#39;)
</pre></div></div>
</div>
<p>Other options you might use here are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">template_type</span></code>, which points to files stored in <code class="docutils literal notranslate"><span class="pre">template_&lt;template_type&gt;</span></code> for foreground template subtraction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data_root2</span></code>, which is used for null tests. This points to a second full map directory (data, signal and noise sims) for a set of data to be subtracted from the maps in data_root1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">signal_type_sim</span></code>/<code class="docutils literal notranslate"><span class="pre">noise_type_sim</span></code>/<code class="docutils literal notranslate"><span class="pre">foreground_type_sim</span></code>– these are tags corresponding to directories <code class="docutils literal notranslate"><span class="pre">signal_&lt;signal_type_sim&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">noise_&lt;noise_type_sim&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">foreground_&lt;foreground_type_sim&gt;</span></code> that are used when the <code class="docutils literal notranslate"><span class="pre">sim_index</span></code> argument is set in the <code class="docutils literal notranslate"><span class="pre">bandpowers</span></code> checkpoint. This mode uses sim maps in place of data maps. It adds the signal, noise, and/or foreground sims in alm-space if <code class="docutils literal notranslate"><span class="pre">sims_add_alms=True</span></code>, which is the default, or in Cls, if it is False. These options are
not needed to run in <code class="docutils literal notranslate"><span class="pre">sim_index</span></code> mode– if they are not set, they default to <code class="docutils literal notranslate"><span class="pre">signal_type_sim=signal_type</span></code>, <code class="docutils literal notranslate"><span class="pre">noise_type_sim=noise_type</span></code>, and <code class="docutils literal notranslate"><span class="pre">foreground_type_sim=None</span></code>.</p></li>
</ul>
</div>
<div class="section" id="get_bin_def">
<h3>get_bin_def<a class="headerlink" href="#get_bin_def" title="Permalink to this headline">¶</a></h3>
<p>Now we run <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_bin_def"><span class="std std-ref">get_bin_def()</span></a> set up a dictionary that tells where the edges of the CMB bins are for each spectrum. We can also choose whether to fit for noise residuals or foregrounds, which we can set to have different bin widths than the CMB bins.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">bd</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_bin_def</span><span class="p">(</span><span class="n">bin_width</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tbeb</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">foreground_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">residual_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bin_width_res</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
odict_keys([&#39;cmb_tt&#39;, &#39;cmb_ee&#39;, &#39;cmb_bb&#39;, &#39;cmb_te&#39;, &#39;cmb_eb&#39;, &#39;cmb_tb&#39;, &#39;res_eebb_150&#39;, &#39;res_eebb_95&#39;])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">bd</span><span class="p">[</span><span class="s1">&#39;cmb_tt&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[  2,  27],
       [ 27,  52],
       [ 52,  77],
       [ 77, 102],
       [102, 127],
       [127, 152],
       [152, 177],
       [177, 202],
       [202, 227],
       [227, 252],
       [252, 277],
       [277, 302],
       [302, 327],
       [327, 352],
       [352, 377],
       [377, 402],
       [402, 427],
       [427, 452],
       [452, 477],
       [477, 501]])
</pre></div></div>
</div>
<p>This dictionary has a key for each type of spectrum that will be fit, each of which stores the bin edges used for that spectrum fit. Each of these bin edge pairs represents a separate bandpower deviation (<span class="math notranslate nohighlight">\(q_b\)</span>) that will be fit.</p>
<p>Residuals are fit per map, and by default are fit only for EE and BB, which are constrained to have the same fit parameter. To change this, use the option <code class="docutils literal notranslate"><span class="pre">res_specs</span></code>, which takes a list of the spectra you want to fit residuals for, ie. <code class="docutils literal notranslate"><span class="pre">[&quot;TT&quot;,</span> <span class="pre">&quot;EE&quot;,</span> <span class="pre">&quot;BB&quot;]</span></code> if you’d like to fit all of the spectra separately.</p>
<p>The last option you might wish to use is <code class="docutils literal notranslate"><span class="pre">weighted_bins</span></code>, which changes the default <span class="math notranslate nohighlight">\(\chi_b(\ell)\)</span> binning operator from a tophat to one that weights by <span class="math notranslate nohighlight">\(\ell(\ell+1)\)</span>.</p>
</div>
<div class="section" id="get_mask_weights">
<h3>get_mask_weights<a class="headerlink" href="#get_mask_weights" title="Permalink to this headline">¶</a></h3>
<p>We have now finished all the set-up. Now it’s time to start calculating things. First, we compute the cross spectra of our masks–which will be needed for computing the <span class="math notranslate nohighlight">\(K_{\ell \ell^{\prime}}\)</span> mode-coupling matrix–and the <span class="math notranslate nohighlight">\(g_\ell\)</span> mode-counting factor. This is done with <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_mask_weights"><span class="std std-ref">get_mask_weights()</span></a>.</p>
<p>For the example, we will not apply an empirical correction to <span class="math notranslate nohighlight">\(g_\ell\)</span>, the calibration of which is discussed in Section 2.3.2 of the <a class="reference external" href="https://arxiv.org/abs/2104.01172">XFaster paper</a>. Otherwise, we would set <code class="docutils literal notranslate"><span class="pre">apply_gcorr=True</span></code>, and the code would look in the masks directory for this correction file for each map. The <code class="docutils literal notranslate"><span class="pre">reload_gcorr</span></code> option is only useful when doing the empirical calibration; it reloads the file, while by-passing the checkpoint tree that is usually performed after
<code class="docutils literal notranslate"><span class="pre">get_mask_weights</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">w_stuff</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_mask_weights</span><span class="p">(</span><span class="n">apply_gcorr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reload_gcorr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">w_stuff</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dict_keys([&#39;wls&#39;, &#39;fsky&#39;, &#39;w1&#39;, &#39;w2&#39;, &#39;w4&#39;, &#39;gmat&#39;, &#39;nside&#39;, &#39;npix&#39;, &#39;gcorr&#39;, &#39;output_file&#39;])
</pre></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">w1</span></code>, <code class="docutils literal notranslate"><span class="pre">w2</span></code>, and <code class="docutils literal notranslate"><span class="pre">w4</span></code> are the first, second, and fourth moments of the mask. <code class="docutils literal notranslate"><span class="pre">fsky</span></code> is the fraction of sky the mask covers. These are needed for computing the <span class="math notranslate nohighlight">\(g_\ell\)</span> mode-counting term, labeled <code class="docutils literal notranslate"><span class="pre">gmat</span></code> in the outputs. <code class="docutils literal notranslate"><span class="pre">gmat</span></code> includes the <span class="math notranslate nohighlight">\(2\ell+1\)</span> factor and a correction factor, if desired.</p>
<p><code class="docutils literal notranslate"><span class="pre">wls</span></code>, contains the cross spectra of all the masks. For this and all other pseudo-spectra, the spectrum is computed just as <code class="docutils literal notranslate"><span class="pre">map2alm</span></code>, and then <code class="docutils literal notranslate"><span class="pre">alm2cl</span></code> healpy routines on the maps. If you’re doing a polarized spectrum, you’ll get three elements, (intensity, pol, intensity x pol). Since our intensity and pol masks are the same, all three elements are the same, and look like this (plotted as <span class="math notranslate nohighlight">\(D_\ell\)</span>):</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">501</span><span class="p">)</span>
<span class="n">lfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">w_stuff</span><span class="p">[</span><span class="s1">&#39;wls&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\frac{\ell(\ell+1)}{2\pi}w_\ell$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0, &#39;$\\ell$&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_36_1.png" src="../_images/notebooks_XFaster_Tutorial_36_1.png" />
</div>
</div>
<p><strong>Note:</strong> most of the quantities in XFaster are ordered dictionaries with the following nested structure: 1. Spectra (either plain [‘tt’, ‘ee’], etc, or [‘cmb_tt’, ‘cmb_ee’, …, ‘fg_tt’, ‘fg_ee’, …, ‘res_tt’, …] 2. Map/map cross. Crosses are indicated with a colon and are in alphabetical order (so 95 comes after 150, for example): [‘150:150’, ‘150:95’, ‘95:95’] 3. Stuff. Typically an array, though depending on the data structure, it could be a more deeply nested dictionary.</p>
</div>
<div class="section" id="get_kernels">
<h3>get_kernels<a class="headerlink" href="#get_kernels" title="Permalink to this headline">¶</a></h3>
<p>The next step is to compute the kernels for each mask auto and cross spectrum using the function <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_kernels"><span class="std std-ref">get_kernels()</span></a>. In the MASTER formalism, the kernel couples modes to each other on the sky due to the finite dimensions of the mask that is applied to each map that goes into computing a cross spectrum. That is to say, the measured power at a particular <span class="math notranslate nohighlight">\(\ell\)</span> is a weighted average over several other neighboring modes
<span class="math notranslate nohighlight">\(\ell^\prime\)</span>, and <span class="math notranslate nohighlight">\(K_{\ell\ell^\prime}\)</span> is the matrix that applies this weighting.</p>
<p>The kernels are computed from the power spectrum of the mask, computed in the previous step.</p>
<p>Let’s plot some of these up. Because we are using the same mask for all maps, the kernels for each map pair will look identical.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">k</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_kernels</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dict_keys([&#39;kern&#39;, &#39;pkern&#39;, &#39;mkern&#39;, &#39;xkern&#39;, &#39;window_lmax&#39;, &#39;output_file&#39;])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mf">5.5</span><span class="p">))</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="s1">&#39;kern&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;kern&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="s1">&#39;pkern&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;pkern&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="s1">&#39;mkern&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;mkern&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell^\prime$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="s1">&#39;xkern&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">]),</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(</span><span class="n">vmax</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;xkern&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell^\prime$&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_41_0.png" src="../_images/notebooks_XFaster_Tutorial_41_0.png" />
</div>
</div>
<p>Note that the shorter dimension (<span class="math notranslate nohighlight">\(\ell\)</span>) of each kernel goes up to <span class="math notranslate nohighlight">\(\ell_{max}\)</span>, and the longer dimension (<span class="math notranslate nohighlight">\(\ell^\prime\)</span>) extends to <span class="math notranslate nohighlight">\(2 \ell_{max} + 1\)</span>. The kernels are apodized, so that for any row <span class="math notranslate nohighlight">\(\ell\)</span>, the kernels are zero for values <span class="math notranslate nohighlight">\(\ell^\prime &gt; \ell + \ell_{max}\)</span>. The longer dimension is summed over in computing the <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}\)</span> terms.</p>
</div>
<div class="section" id="get_masked_sims">
<h3>get_masked_sims<a class="headerlink" href="#get_masked_sims" title="Permalink to this headline">¶</a></h3>
<p>Now we want to get the ensemble average of all of our signal and noise simulations, which we’re going to use to calculate the filter transfer function and the noise shape, respectively. This is done with <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_masked_sims"><span class="std std-ref">get_masked_sims()</span></a>. The method will also compute the signal cross noise terms, which are used for null tests, where they can contribute significantly to the expected residuals that are subtracted from the data.</p>
<p>This function is doing a very simple thing. For each pair of maps of a given sim index, it</p>
<ol class="arabic simple">
<li><p>Applies the mask.</p></li>
<li><p>Transforms the maps into <span class="math notranslate nohighlight">\(a_{\ell m}\)</span>s using the healpy routine <code class="docutils literal notranslate"><span class="pre">map2alm</span></code>.</p></li>
<li><p>Transforms those into <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_\ell\)</span>s for that pair using the healpy routine <code class="docutils literal notranslate"><span class="pre">alm2cl</span></code>.</p></li>
<li><p>Adds the <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_\ell\)</span>s to a running average for that particular map cross and spectrum.</p></li>
</ol>
<p>It only does <code class="docutils literal notranslate"><span class="pre">map2alm</span></code> once per map and caches the result for use in other cross spectra since this is the slowest step in the function.</p>
<p>Below, we call the function with <code class="docutils literal notranslate"><span class="pre">transfer=True</span></code>– this tells the code to use the sims specified in <code class="docutils literal notranslate"><span class="pre">signal_type_transfer</span></code>, which defaults to being <code class="docutils literal notranslate"><span class="pre">signal_type</span></code> if the former is not specified.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">sims</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_masked_sims</span><span class="p">(</span><span class="n">transfer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sims</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dict_keys([&#39;cls_signal&#39;, &#39;cls_noise&#39;, &#39;cls_sim&#39;, &#39;cls_med&#39;, &#39;cls_noise0&#39;, &#39;cls_noise1&#39;, &#39;cls_sxn0&#39;, &#39;cls_sxn1&#39;, &#39;cls_nxs0&#39;, &#39;cls_nxs1&#39;, &#39;output_file&#39;])
</pre></div></div>
</div>
<p>The resulting outputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cls_signal</span></code>: the average of the signal-only cross spectra, used to compute the transfer function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_noise</span></code>: the average of the noise-only cross spectra, used as the noise model, <span class="math notranslate nohighlight">\(N_\ell\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_sim</span></code>: the average of the signal+noise spectra, where signal and noise maps are added in <span class="math notranslate nohighlight">\(a_{\ell m}\)</span>s and thus the spectra include SxN terms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_med</span></code>: the median of the signal+noise spectra– this is mainly used for debugging potential biases seen in the pipeline</p></li>
</ul>
<p>The rest of the spectra are not symmetrized. For all previously listed spectra, the result is the average of map i x map j and map j x map i, which matters for off-diagonal spectra: TE, TB, EB. Below, we preserve the individual cross spectra as they are needed for the null test model. In this model, at each Fisher iteration, the noise residual fit (per map and per residual spectrum type) is then used to adjust the expectation spectrum subtracted from the data. The expectation spectrum subtracted
from, eg, map 1 T x map 2 E is <span class="math notranslate nohighlight">\(S_1^T\times S_2^E + S_1^T \times N_2^E + N_1^T \times S_2^E + N_1^T \times N_2^E\)</span>. Each of the last three terms is subject to misestimation of <span class="math notranslate nohighlight">\(N\)</span>, so we account for that by scaling the following terms by the appropriate noise residual fit.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cls_noise0</span></code>: the average spectrum for noise i x noise j</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_noise1</span></code>: the average spectrum for noise j x noise i</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_sxn0</span></code>: the average spectrum of signal i x noise j</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_sxn1</span></code>: the average spectrum of noise j x signal i</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_nxs0</span></code>: the average spectrum of noise i x signal j</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cls_nxs1</span></code>: the average spectrum of signal j x noise i</p></li>
</ul>
<p>These spectra have all the effects of the masking, filtering, and beam (for signal sims) included. Let’s compare a couple of them to get a sense for what they look like.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;95:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;150 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 x 150&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$D_\ell [\mu \mathrm</span><span class="si">{K}</span><span class="s1">^2]$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;TT&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;95:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;150 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 x 150&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;EE&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;cls_signal&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0.98, &#39;cls_signal&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_48_1.png" src="../_images/notebooks_XFaster_Tutorial_48_1.png" />
</div>
</div>
<p>In this example, we use the same idealized transfer function to make both 95 and 150 GHz maps, so their low-<span class="math notranslate nohighlight">\(\ell\)</span> signal is similar. However, for 150 GHz we use a 29 arcmin beam, and for 95 GHz, we use a broader 41 arcmin beam. The difference is evident at high <span class="math notranslate nohighlight">\(\ell\)</span>, where the 150 GHz signal spectra recover more power.</p>
<p>Similarly, we can plot up the noise averages:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;95:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;150 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 x 150&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$D_\ell [\mu \mathrm</span><span class="si">{K}</span><span class="s1">^2]$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;TT&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;95:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;150 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">sims</span><span class="p">[</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 x 150&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;EE&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;cls_noise&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0.98, &#39;cls_noise&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_50_1.png" src="../_images/notebooks_XFaster_Tutorial_50_1.png" />
</div>
</div>
<p>In making the example maps, we have set the noise amplitude to be a bit higher for 95 GHz, which is evident in the noise auto-spectra. As expected, the cross-spectra is uncorrelated and mean-zero.</p>
</div>
<div class="section" id="get_beams">
<h3>get_beams<a class="headerlink" href="#get_beams" title="Permalink to this headline">¶</a></h3>
<p>The next component we need for our equations is the beam window function, <span class="math notranslate nohighlight">\(B_\ell\)</span>, done with <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_beams"><span class="std std-ref">get_beams()</span></a>. XFaster does not solve for this– you have to tell it what it is. You do this in your config.ini file. You can either specify Gaussian FWHM values (in arcmin) for each map tag, or specify a <code class="docutils literal notranslate"><span class="pre">.npz</span></code> file that contains a dictionary of <span class="math notranslate nohighlight">\(B_\ell\)</span> vectors per map tag. You can mix and match these as well– the code will first look
for the tags in the dictionary file, and if it doesn’t find the tag there, it will look for a FWHM field for that tag.</p>
<p>The only additional option available is <code class="docutils literal notranslate"><span class="pre">pixwin</span></code>, which is default True. This applies an additional pixel window function to your beam window function, corresponding to the <span class="math notranslate nohighlight">\(N_{side}\)</span> of the input maps.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">beams</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_beams</span><span class="p">(</span><span class="n">pixwin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">beams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
odict_keys([&#39;tt&#39;, &#39;ee&#39;, &#39;bb&#39;, &#39;te&#39;, &#39;eb&#39;, &#39;tb&#39;])
</pre></div></div>
</div>
<p>We could have a different beam for intensity and polarization. For this example, we don’t, so each of the spectrum fields for beam is the same. Let’s plot them for each map.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">map_tags</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">beams</span><span class="p">[</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="n">freq</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B_\ell$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0, &#39;$\\ell$&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_56_1.png" src="../_images/notebooks_XFaster_Tutorial_56_1.png" />
</div>
</div>
</div>
<div class="section" id="get_signal_shape">
<h3>get_signal_shape<a class="headerlink" href="#get_signal_shape" title="Permalink to this headline">¶</a></h3>
<p>Let’s check in on our progress of components we’ve computed. We’re trying to build everything to make up our <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}^{XY}_{b\ell}\)</span>s, which as a reminder are the following quantity (for TT):</p>
<p><span class="math">\begin{equation}
\tilde{\mathcal{C}}^{XY}_{b\ell} = \sum_{\ell^{\prime}} K_{\ell \ell^{\prime}}^{X Y} F_{\ell^{\prime}}^{X Y} B_{\ell^{\prime}}^{2} \mathcal{C}_{\ell^{\prime}}^{X Y (S)} \chi_{b}\left(\ell^{\prime}\right)
\end{equation}</span></p>
<p>We have <span class="math notranslate nohighlight">\(K_{\ell, \ell'}\)</span> and <span class="math notranslate nohighlight">\(B_{\ell}\)</span>. For the transfer function calculation, we’re going to set <span class="math notranslate nohighlight">\(F_\ell\)</span> to 1 so that we measure <span class="math notranslate nohighlight">\(q_b\)</span>s as the deviation from a uniform transfer function for our simulations. Binning, <span class="math notranslate nohighlight">\(\chi_b\)</span> has been chosen. All that’s left is the full sky signal shape, <span class="math notranslate nohighlight">\(\mathcal{C}_{\ell'}^{XY (S)}\)</span>, loaded with <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_signal_shape"><span class="std std-ref">get_signal_shape()</span></a>.</p>
<p>For calculating the transfer function, this is just the shape spectrum that went into making our simulations. This spectrum can be specified by setting the argument <code class="docutils literal notranslate"><span class="pre">signal_transfer_spec</span></code> to a file containing the spectrum. If not provided, the code will look in the maps directory for the signal sims for a file labeled <code class="docutils literal notranslate"><span class="pre">spec_signal_&lt;signal_type&gt;.dat</span></code>. The file is expected to look like a CAMB output file, as demonstrated in <code class="docutils literal notranslate"><span class="pre">make_example_maps.py</span></code>, which writes such a file to the proper
location in the signal sims directory.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">signal_shape</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_signal_shape</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">signal_shape</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
odict_keys([&#39;cmb_tt&#39;, &#39;cmb_ee&#39;, &#39;cmb_bb&#39;, &#39;cmb_te&#39;, &#39;cmb_eb&#39;, &#39;cmb_tb&#39;])
</pre></div></div>
</div>
<p>These will look familiar to you. Note that they are as long as the long dimension of the <span class="math notranslate nohighlight">\(K_{\ell\ell'}\)</span>, which is 2<span class="math notranslate nohighlight">\(\ell_{max}\)</span> + 1. Also note that EB and TB, expected to be zero, are set to a small flat value.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">ell2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1001</span><span class="p">)</span>
<span class="n">lfac2</span> <span class="o">=</span> <span class="n">ell2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">signal_shape</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac2</span> <span class="o">*</span> <span class="n">spec</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$D_\ell [\mu\mathrm</span><span class="si">{K}</span><span class="s1">^2]$&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]:</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_61_0.png" src="../_images/notebooks_XFaster_Tutorial_61_0.png" />
</div>
</div>
</div>
<div class="section" id="get_transfer">
<h3>get_transfer<a class="headerlink" href="#get_transfer" title="Permalink to this headline">¶</a></h3>
<p>We now have everything we need to compute the transfer function, which is computed per map per spectrum per CMB bin in <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_transfer"><span class="std std-ref">get_transfer()</span></a>. As a refresher, we’re trying to get <span class="math notranslate nohighlight">\(q_b^{transfer}\)</span>, which is the same as our original expression for <span class="math notranslate nohighlight">\(q_b\)</span> in <a class="reference external" href="https://annegambrel.github.io/xfaster/algorithm.html#equation-qb">Equation 17 of the Algorithm page</a>, except now we set noise=0, transfer function=1, and instead of using data
for our observed signal, we use the ensemble average of our signal sims:</p>
<p><span class="math">\begin{equation}
q_{b}^{transfer}=\frac{1}{2} \sum_{b^{\prime}} \mathcal{F}_{b b^{\prime}}^{-1} \sum_{\ell} (2 \ell+1) g_\ell^k\left[ \left(\tilde{\mathbf{C}}_{\ell}^{-1} \frac{\partial \tilde{\mathbf{S}}_{\ell}}{\partial q_{b^{\prime}}} \tilde{\mathbf{C}}_{\ell}^{-1}\right)\tilde{\mathbf{C}}_{\ell}^{signal}\right]_{kk}
\label{eq:qb_transfer}
\end{equation}</span></p>
<p>The expression for the Fisher matrix does not change, other than the fact that its constituents are the same as detailed above for the transfer function.</p>
<p>Within the code, <code class="docutils literal notranslate"><span class="pre">get_transfer</span></code> basically has two steps within the function itself, which it performs per map.</p>
<ol class="arabic simple">
<li><p>Load up the <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}\)</span>:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">m0</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This uses the signal_shape internally that we calculated earlier, <code class="docutils literal notranslate"><span class="pre">m0</span></code> is the map, which is used to select the beam and kernel, and <code class="docutils literal notranslate"><span class="pre">transfer_run=True</span></code> sets the <span class="math notranslate nohighlight">\(F_\ell\)</span> term to 1.</p>
<ol class="arabic simple" start="2">
<li><p>Run <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.fisher_iterate"><span class="std std-ref">fisher_iterate()</span></a>.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_iterate</span><span class="p">(</span><span class="n">cbl</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">iter_max</span><span class="o">=</span><span class="n">iter_max</span><span class="p">,</span> <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
                          <span class="n">save_iters</span><span class="o">=</span><span class="n">save_iters</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>We’ll talk more in the <code class="docutils literal notranslate"><span class="pre">get_bandpowers</span></code> section about the details that happen from here, but broadly, XFaster takes all the inputs we’ve calculated and a starting <span class="math notranslate nohighlight">\(q_b\)</span> guess (1 for all bins), computes the Fisher matrix, plugs that into the <span class="math notranslate nohighlight">\(q_b\)</span> equation to get a new <span class="math notranslate nohighlight">\(q_b\)</span>, and repeats. Once the maximum of |(qb_new-qb)/qb| &lt; converge_criteria, it stops iterating and saves the result.</p>
<p>One additional check that <code class="docutils literal notranslate"><span class="pre">get_transfer</span></code> does is to look for transfer function values that are negative. If it finds any, it changes that bin value to the average of the orignal value and the next bin’s value. This typically happens due to poor choices of binning or too small a number of signal simulations.</p>
<p>Also, Only TT, EE, BB, and TE transfer functions are calculated. EB and TB are computed as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qb</span><span class="p">[</span><span class="s1">&#39;cmb_eb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s1">&#39;cmb_ee&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="s1">&#39;cmb_bb&#39;</span><span class="p">]))</span>
<span class="n">qb</span><span class="p">[</span><span class="s1">&#39;cmb_tb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s1">&#39;cmb_tt&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="s1">&#39;cmb_bb&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">transfer</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_transfer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">transfer</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
odict_keys([&#39;cmb_tt&#39;, &#39;cmb_ee&#39;, &#39;cmb_bb&#39;, &#39;cmb_te&#39;, &#39;cmb_eb&#39;, &#39;cmb_tb&#39;])
</pre></div></div>
</div>
<p>Let’s look at a couple transfer functions.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">plot_inds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;95&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;150&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">transfer</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">plot_inds</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;tt&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">plot_inds</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;bin&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(0.0, 1.2)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_66_1.png" src="../_images/notebooks_XFaster_Tutorial_66_1.png" />
</div>
</div>
<p>Note that the BB transfer function (and the EB/TB terms computed from it) start to diverge at high multipole. This is due to the lack of signal power in our input spectrum combined with the reduction in power of the beam. For this reason, you might choose to use a model spectrum with more BB power in computing your BB transfer functions.</p>
</div>
<div class="section" id="get_masked_data">
<h3>get_masked_data<a class="headerlink" href="#get_masked_data" title="Permalink to this headline">¶</a></h3>
<p>Now comes the step where we compute the data term using <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_masked_data"><span class="std std-ref">get_masked_data()</span></a>. This is once again done just by taking all the pseudo-cross-spectra of all the data maps, using <code class="docutils literal notranslate"><span class="pre">healpy.map2alm</span></code> and <code class="docutils literal notranslate"><span class="pre">healpy.alm2cls</span></code>. This is also the step where the cross spectra of foreground templates is performed, if <code class="docutils literal notranslate"><span class="pre">template_type</span></code> is specified.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">cls_data</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_masked_data</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cls_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dict_keys([&#39;cls_data&#39;, &#39;nside&#39;, &#39;output_file&#39;])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">cls_data</span><span class="p">[</span><span class="s1">&#39;cls_data&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;95:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">cls_data</span><span class="p">[</span><span class="s1">&#39;cls_data&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;150 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">cls_data</span><span class="p">[</span><span class="s1">&#39;cls_data&#39;</span><span class="p">][</span><span class="s1">&#39;tt&#39;</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 x 150&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$D_\ell [\mu \mathrm</span><span class="si">{K}</span><span class="s1">^2]$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;TT&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">cls_data</span><span class="p">[</span><span class="s1">&#39;cls_data&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;95:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">cls_data</span><span class="p">[</span><span class="s1">&#39;cls_data&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;150 auto&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">cls_data</span><span class="p">[</span><span class="s1">&#39;cls_data&#39;</span><span class="p">][</span><span class="s1">&#39;ee&#39;</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95 x 150&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;EE&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;cls_data&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0.98, &#39;cls_data&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_71_1.png" src="../_images/notebooks_XFaster_Tutorial_71_1.png" />
</div>
</div>
<p>Now, computing things for data is typically the final thing you’ll be wanting to do. The first way you’ll probably run the code is on simulations to make sure things make sense. There are two ways you can do this that will replace whatever <code class="docutils literal notranslate"><span class="pre">get_masked_data</span></code> computes with your new simulated data. They are: 1. a second round of <code class="docutils literal notranslate"><span class="pre">get_masked_sims</span></code>, or, 2. <code class="docutils literal notranslate"><span class="pre">get_masked_fake_data</span></code>. Both are explained below.</p>
</div>
<div class="section" id="get_masked_sims-(for-replacing-data)">
<h3>get_masked_sims (for replacing data)<a class="headerlink" href="#get_masked_sims-(for-replacing-data)" title="Permalink to this headline">¶</a></h3>
<p>There are several options that dictate what the data is replaced by here. We’ll go through them:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ensemble_mean</span></code>: use <code class="docutils literal notranslate"><span class="pre">cls_sim</span></code> in place of the data spectra. This quantity, computed in <a class="reference external" href="#get_masked_sims">the previous sims step</a> is the average of the signal+noise sims.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ensemble_median</span></code>: use <code class="docutils literal notranslate"><span class="pre">cls_med</span></code>, the median of the signal+noise sims, in place of the data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sim_index</span></code>: use the signal and noise sim maps with this index in place of the data</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">sims_add_alms</span></code>: add the signal and noise maps corresponding to sim index in alms. Otherwise, compute their spectra first, and then add them (which would not include signal and noise correlations).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qb_file</span></code>: a bandpowers.npz file where noise residuals have been fit. Use these noise residuals to scale the noise map specified by sim_index before adding it to the signal map.</p></li>
<li><p>Note also that using the <code class="docutils literal notranslate"><span class="pre">sim_index</span></code> option allows you to specify different signal or noise sims from what you used in your original <code class="docutils literal notranslate"><span class="pre">get_masked_sims</span></code> call (for constructing the transfer function and noise model). This is done by setting <code class="docutils literal notranslate"><span class="pre">signal_type_sim</span></code> and <code class="docutils literal notranslate"><span class="pre">noise_type_sim</span></code>, and, optionally, <code class="docutils literal notranslate"><span class="pre">foreground_type_sim</span></code>.</p></li>
</ul>
</li>
</ul>
<p>For the example case, we won’t use any of these options. They can be super useful for forming expectations for your data outputs, though!</p>
</div>
<div class="section" id="get_masked_fake_data">
<h3>get_masked_fake_data<a class="headerlink" href="#get_masked_fake_data" title="Permalink to this headline">¶</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">get_masked_sims</span></code> and its various options for replacing data is going to be the main way you’ll want to run sims. We implemented an additional option, <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_masked_fake_data"><span class="std std-ref">get_masked_fake_data()</span></a>, for the special case where you want to construct your sim maps from a very specific ensemble: scalar-only signal sim maps, <span class="math notranslate nohighlight">\(r\)</span>=1 tensor-only signal sim maps, noise maps, and an <span class="math notranslate nohighlight">\(\alpha\)</span>-scaled foreground template map. This is used for
SPIDER to run the ensemble of simulations needed for the Feldman-Cousins analysis, and was written to allow for constructing many different <span class="math notranslate nohighlight">\(r\)</span>-input maps in memory. However, it might be useful for a more generic case of simply wanting to run many simulations that include template-based foregrounds. Scalar maps must be in the directory <code class="docutils literal notranslate"><span class="pre">signal_r0</span></code>, and tensor must be in <code class="docutils literal notranslate"><span class="pre">signal_r1tens</span></code> in your data root. Here are the options available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fake_data_r</span></code>: the r value (total signal map = scalar + sqrt(r) * tensor(r=1))</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fake_data_template</span></code>: the tag for the templates directory. The “fake foreground” is taken as the halfmission-1 template and added to the simulated data scaled by the given alpha.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sim_index</span></code>: which sim index to use for the signal and noise sims</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">template_alpha</span></code>: the values by which to scale the template to make it the “fake foreground”</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noise_type</span></code>: tag for noise subdirectory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">do_fake_signal</span></code>: if True, use sim_index for picking which signal map to use. Else, use 0 sim index (there is still signal in the fake data map). This is useful for running a bunch of sims where only the noise seed varies, eg, to determine the relative contribution of noise to the error bars.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">do_fake_noise</span></code>: same as above, but for noise</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">save_fake_data</span></code>: if true, save the data_xcorr.npz file to disk. If running a lot of sims, can save on disk space by just doing this all in memory and not saving to disk.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub_hm_noise</span></code>: if true, subtract the average of the HM1xHM2 FFP10 noise sims from the cleaned spectra computed from the fake data map.</p></li>
</ul>
</div>
<div class="section" id="get_bandpowers">
<h3>get_bandpowers<a class="headerlink" href="#get_bandpowers" title="Permalink to this headline">¶</a></h3>
<p>Now we put it all together! The function <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_bandpowers"><span class="std std-ref">get_bandpowers()</span></a> works just like <code class="docutils literal notranslate"><span class="pre">get_transfer</span></code>, with the transfer function terms no longer set to unity, and instead constructed from the <span class="math notranslate nohighlight">\(q_b\)</span>s computed by <code class="docutils literal notranslate"><span class="pre">get_transfer</span></code>.</p>
<div class="section" id="Constructing-the-model-spectrum">
<h4>Constructing the model spectrum<a class="headerlink" href="#Constructing-the-model-spectrum" title="Permalink to this headline">¶</a></h4>
<p>The first step is to construct the <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}\)</span>’s including all of the additional components in the model. This is done with <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.bin_cl_template"><span class="std std-ref">bin_cl_template()</span></a>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">cbl</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transfer_run</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Let’s plot up each set of components individually. First, the CMB component, which should look familiar. Each color represents the <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}\)</span> for a single bin. The black lines show the total shape of each component in <span class="math notranslate nohighlight">\(\ell\)</span> if the <span class="math notranslate nohighlight">\(q_b\)</span> applied to each bin is set to 1 (ie, our signal model is perfectly correct). This is what we call the <em>model spectrum</em> that we are fitting to. Notice that the EE and BB mixing terms have very broad bins and are very low
amplitude. This is due to the shape of the <span class="math notranslate nohighlight">\(_{-}K_{\ell\ell^\prime}\)</span> kernel as a function of <span class="math notranslate nohighlight">\(\ell\)</span>. These shapes will look different for each map cross, due to differences in each transfer function and beam.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">axs</span> <span class="o">=</span> <span class="n">axs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">501</span><span class="p">)</span>
<span class="n">ellfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cmb_tt&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_te&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_ee&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_ee_mix&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_eb&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_tb&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_bb&#39;</span><span class="p">,</span> <span class="s1">&#39;cmb_bb_mix&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="n">comps</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;150 x 150 </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
    <span class="n">cbl1</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">cbl1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">ellfac</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cbl1</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">ellfac</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$D_\ell$&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_81_0.png" src="../_images/notebooks_XFaster_Tutorial_81_0.png" />
</div>
</div>
<p>The next model component that we include accounts for residual noise in the auto-spectra. These <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}\)</span> terms do not include any transfer functions, beams or mode mixing kernels. They are derived from the <em>simulated</em> noise spectra <span class="math notranslate nohighlight">\(\tilde{N}_\ell\)</span>. These terms act as corrections to the noise model by adjusting the auto-spectrum noise components to agree with the cross terms.</p>
<p>For the example, we fit only for the EE and BB components, and we require them to be the same. That is, each <span class="math notranslate nohighlight">\(q_b^{res,EEBB}\)</span> applies to both <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}^{EE}\)</span> and <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}^{BB}\)</span> here.</p>
<p>The residual signal model is thus:</p>
<p><span class="math">\begin{equation}
\tilde{\mathbf{S}}_\ell^{res,ij} = \delta_{ij}\,
\begin{bmatrix}
0 & 0 & 0 \\
0 & \sum_b q_b^{EEBB} \tilde{\mathcal{C}}_{b\ell}^{EE} & 0 \\
0 & 0 & \sum_b q_b^{EEBB} \tilde{\mathcal{C}}_{b\ell}^{BB} \\
\end{bmatrix}_{\,res,ij}
\label{eq:signal_res}
\end{equation}</span></p>
<p>and the derivatives are</p>
<p><span class="math">\begin{equation}
\frac{\partial \tilde{\mathbf{S}}_\ell}{\partial q_b^{res,ij,EEBB}} = \delta_{ij}\,
\begin{bmatrix}
0 & 0 & 0 \\
0 & \tilde{\mathcal{C}}_{b\ell}^{EE} & 0 \\
0 & 0 & \tilde{\mathcal{C}}_{b\ell}^{BB} \\
\end{bmatrix}_{\,res,ij}
\label{eq:signal_res_deriv}
\end{equation}</span></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mf">3.5</span><span class="p">))</span>
<span class="n">axs</span> <span class="o">=</span> <span class="n">axs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">501</span><span class="p">)</span>
<span class="n">ellfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;res_ee&#39;</span><span class="p">,</span> <span class="s1">&#39;res_bb&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="n">comps</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;150 x 150 </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
    <span class="n">cbl1</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="s1">&#39;150:150&#39;</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">cbl1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">ellfac</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cbl1</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">ellfac</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$D_\ell$&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_83_0.png" src="../_images/notebooks_XFaster_Tutorial_83_0.png" />
</div>
</div>
<p>Next we add our actual noise simulations to the model. The residual noise terms discussed above are designed to account for inaccuracies in this model. For both the fiducial noise model and the noise residuals, we assume 0 average noise in cross-spectra, and so only add them to the auto-terms of the model.</p>
<p>We often find that the Fisher iterations have trouble converging due to numerical errors that cause the covariance to become singular. To prevent this from happening, we also include a term we call “conditioning noise” along the TT/EE/BB diagonals as well. The conditioning noise is modeled as constant in <span class="math notranslate nohighlight">\(\ell\)</span>, where the EE and BB diagonals are set to be <code class="docutils literal notranslate"><span class="pre">cond_noise</span></code> and TT is set to be 10*<code class="docutils literal notranslate"><span class="pre">cond_noise</span></code>. The typical conditioning noise is very small (1e-5 or so), and it is
automatically adjusted to be the lowest level possible while still having the algorithm converge. In the final Fisher iteration, the conditioning noise is dropped.</p>
<p>To plot up both of these model components, along with all of the terms discussed above, let’s call an internal function that computes the model spectrum for us, given the <span class="math notranslate nohighlight">\(\tilde{\mathcal{C}}_{b\ell}\)</span> terms and some model parameters <span class="math notranslate nohighlight">\(q_b\)</span>: <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_model_spectra"><span class="std std-ref">get_model_spectra()</span></a>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="c1"># construct a dummy qb array to compute input model</span>
<span class="n">qb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">bin_def</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
<span class="n">cls_model</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="n">axs</span> <span class="o">=</span> <span class="n">axs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">501</span><span class="p">)</span>
<span class="n">ellfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">xname</span> <span class="o">=</span> <span class="s1">&#39;150:150&#39;</span>
<span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cmb&#39;</span><span class="p">,</span> <span class="s1">&#39;noise&#39;</span><span class="p">,</span> <span class="s1">&#39;res&#39;</span><span class="p">,</span> <span class="s1">&#39;cond&#39;</span><span class="p">,</span> <span class="s1">&#39;total&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;tt&#39;</span><span class="p">,</span> <span class="s1">&#39;ee&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">,</span> <span class="s1">&#39;te&#39;</span><span class="p">,</span> <span class="s1">&#39;eb&#39;</span><span class="p">,</span> <span class="s1">&#39;tb&#39;</span><span class="p">]):</span>
        <span class="n">stag</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;res&#39;</span><span class="p">,</span> <span class="s1">&#39;total&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ellfac</span> <span class="o">*</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ellfac</span> <span class="o">*</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;150 x 150 </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ee&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.175</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$D_\ell$&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_85_0.png" src="../_images/notebooks_XFaster_Tutorial_85_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="n">axs</span> <span class="o">=</span> <span class="n">axs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">501</span><span class="p">)</span>
<span class="n">ellfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">xname</span> <span class="o">=</span> <span class="s1">&#39;150:95&#39;</span>
<span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cmb&#39;</span><span class="p">,</span> <span class="s1">&#39;noise&#39;</span><span class="p">,</span> <span class="s1">&#39;res&#39;</span><span class="p">,</span> <span class="s1">&#39;cond&#39;</span><span class="p">,</span> <span class="s1">&#39;total&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;tt&#39;</span><span class="p">,</span> <span class="s1">&#39;ee&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">,</span> <span class="s1">&#39;te&#39;</span><span class="p">,</span> <span class="s1">&#39;eb&#39;</span><span class="p">,</span> <span class="s1">&#39;tb&#39;</span><span class="p">]):</span>
        <span class="n">stag</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span> <span class="ow">or</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ellfac</span> <span class="o">*</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;150 x 95 </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$D_\ell$&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_86_0.png" src="../_images/notebooks_XFaster_Tutorial_86_0.png" />
</div>
</div>
<p>Note that neither conditioning noise nor residual terms are present in the cross-spectra.</p>
</div>
<div class="section" id="Computing-the-Fisher-matrix">
<h4>Computing the Fisher matrix<a class="headerlink" href="#Computing-the-Fisher-matrix" title="Permalink to this headline">¶</a></h4>
<p>Ok! Now that we have all the pieces in place, all that’s left is to do some matrix math and iterate over the equations for <a class="reference external" href="https://annegambrel.github.io/xfaster/algorithm.html#equation-qb">q_b</a> and the [Fisher matrix](<a class="reference external" href="https://annegambrel.github.io/xfaster/algorithm.html#equation-qb">qb</a> until the results converge. The two equations are constructed in the function <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.fisher_calc"><span class="std std-ref">fisher_calc()</span></a>, which is called iteratively by
<a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.fisher_iterate"><span class="std std-ref">fisher_iterate()</span></a> until convergence is reached.</p>
<p>In order to make all the quantities we’ve computed look like matrices, we have two utility functions, <a class="reference internal" href="../api.html#xfaster.parse_tools.dict_to_dmat"><span class="std std-ref">dict_to_dmat()</span></a> and <a class="reference internal" href="../api.html#xfaster.parse_tools.dict_to_dsdqb_mat"><span class="std std-ref">dict_to_dsdqb_mat()</span></a>, that convert the dictionaries <code class="docutils literal notranslate"><span class="pre">Dmat1</span></code> (corresponding to <span class="math notranslate nohighlight">\(\mathbf{\tilde{C}}_\ell\)</span> in the equations) and <code class="docutils literal notranslate"><span class="pre">dSdqb_mat1_freq</span></code> (<span class="math notranslate nohighlight">\(\partial \mathbf{\tilde{S}}_\ell / \partial q_b\)</span>) into matrices.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Dmat1</span></code> matrix has shape <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">num_maps,</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">num_maps,</span> <span class="pre">lmax</span> <span class="pre">+</span> <span class="pre">1)</span></code> and contains the <code class="docutils literal notranslate"><span class="pre">total</span></code> model terms for each map cross spectrum, ordered as <a class="reference external" href="https://annegambrel.github.io/xfaster/algorithm.html#equation-dell">shown here</a>. The <code class="docutils literal notranslate"><span class="pre">dSdqb_mat1_freq</span></code> matrix has shape <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">num_maps,</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">num_maps,</span> <span class="pre">nbins,</span> <span class="pre">lmax</span> <span class="pre">+</span> <span class="pre">1)</span></code> and includes the CMB, residuals and frequency-corrected foreground components for all the crosses. We then compute the quantity</p>
<p><span class="math">\begin{equation}
\mathbf{\tilde{C}}^{-1} \frac{\partial \mathbf{\tilde{S}}}{\partial q_b} \mathbf{\tilde{C}}^{-1}
\end{equation}</span></p>
<p>using the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Dinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Dmat1</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gmat</span><span class="p">))</span>
<span class="n">mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij...,jk...-&gt;ik...&#39;</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">)</span>
<span class="n">mat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;klm...,ln...-&gt;knm...&#39;</span><span class="p">,</span> <span class="n">dSdqb_mat1_freq</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">)</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ik...,knm...-&gt;inm...&#39;</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>
</pre></div>
</div>
<p>The first line computes the inverse of <span class="math notranslate nohighlight">\(D\)</span>, ell-by-ell along the first two dimensions. The next two lines are necessary due to some quirk of memory access in python; this is just multiplying the first two dimensions of <code class="docutils literal notranslate"><span class="pre">Dmat1</span></code> by the identity matrix. The last two lines do the matrix multiplication along the first two dimensions of each of the matrices.</p>
<p>Now, we apply the <span class="math notranslate nohighlight">\(\mathbf{g}_\ell\)</span> mode-counting factor, and at the same time take the trace and sum over ell, computing everything needed for <span class="math notranslate nohighlight">\(q_b\)</span> except <span class="math notranslate nohighlight">\(\Sigma_b \mathcal{F}_{b b^{\prime}}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qb_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jil-&gt;k&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">Dmat_obs</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>The Fisher matrix is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jiml-&gt;km&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">dSdqb_mat1_freq</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Finally, we get our updated estimate of <span class="math notranslate nohighlight">\(q_b\)</span> and its covaraince, the inverse Fisher matrix, and then convert the former array into a readable dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qb_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">qb_vec</span><span class="p">)</span>
<span class="n">inv_fish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qb_vec</span><span class="p">)))</span>
<span class="n">qb_vec</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">qb_vec</span><span class="p">,</span> <span class="n">qb</span><span class="p">)</span>
</pre></div>
</div>
<p>With each iteration, we compare the new <code class="docutils literal notranslate"><span class="pre">qb_vec</span></code> quantity to the previous one, until the maximum fractional change in any element of the array is less than the convergence criterion (0.005 is typical).</p>
</div>
<div class="section" id="Constructing-final-bandpowers">
<h4>Constructing final bandpowers<a class="headerlink" href="#Constructing-final-bandpowers" title="Permalink to this headline">¶</a></h4>
<p>To construct bandpowers, we need to convert the <span class="math notranslate nohighlight">\(q_b\)</span> parameters to spectrum bandpowers. The function that handles this is <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.do_qb2cb"><span class="std std-ref">do_qb2cb()</span></a> This is done by first constructing window functions for each <span class="math notranslate nohighlight">\(q_b\)</span> parameter (using <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.fisher_calc"><span class="std std-ref">fisher_calc()</span></a> with the option <code class="docutils literal notranslate"><span class="pre">windows=True</span></code>), then using that to build a matrix that rotates <span class="math notranslate nohighlight">\(q_b\)</span> into bandpowers. For this example, the quantity
we want in the end should be in units of <span class="math notranslate nohighlight">\(\mathcal{D}_\ell = \ell (\ell + 1) C_\ell / 2\pi\)</span>. You can also return bandpowers in units of <span class="math notranslate nohighlight">\(C_\ell\)</span> using <code class="docutils literal notranslate"><span class="pre">return_cls=True</span></code>, which will change the rotation matrix. Explicitly, we have for the <span class="math notranslate nohighlight">\(\mathcal{D}_b\)</span> bandpowers:</p>
<p><span class="math">\begin{equation}
\mathcal{D}^{XY}_b = \sum_B q^{XY}_B \frac{\partial\langle \mathcal{D}^{XY}_b\rangle}{\partial q^{XY}_B} =
\sum_B q^{XY}_B \frac{\sum_\ell \mathcal{N}_\ell W^{XY(q)}_{b\ell} \chi^{XY}_{B \ell} \mathcal{D}^{XY(S)}_\ell} {\sum_\ell \mathcal{N}_\ell W^{XY(q)}_{b\ell} }\,,
\end{equation}</span></p>
<p>where the normalization function is</p>
<p><span class="math">\begin{equation}
\mathcal{N}_\ell = \frac{1}{2}\frac{(2\ell + 1)}{\ell (\ell + 1)}\,,
\end{equation}</span></p>
<p>and the matrix of derivatives is block-diagonal in the spectrum component <span class="math notranslate nohighlight">\(XY\)</span>. Similarly, the errors on each bandpower are:</p>
<p><span class="math">\begin{equation}
\Delta\mathcal{D}_b = \left[\sum_{BB^\prime} \mathcal{F}^{-1}_{BB^\prime} \frac{\partial\langle \mathcal{D}_b\rangle}{\partial q_B} \frac{\partial\langle \mathcal{D}_{b}\rangle}{\partial q_{B^\prime}}\right]^{1/2}\,,
\end{equation}</span></p>
<p>and the window functions for each <span class="math notranslate nohighlight">\(\mathcal{D}_b\)</span> are:</p>
<p><span class="math">\begin{equation}
W_{b\ell}^{XY(\mathcal{D})} = \sum_B W_{B\ell}^{XY(q)} \frac{\partial\langle \mathcal{D}^{XY}_b\rangle}{\partial q^{XY}_B} \,,
\end{equation}</span></p>
<p>with normalization <span class="math notranslate nohighlight">\(\sum_\ell \mathcal{N}_\ell W_{b\ell}^{(\mathcal{D})} = 1\)</span>. The bandpowers, errors, <span class="math notranslate nohighlight">\(q_b\)</span> window functions and bandpower window functions are all stored in the bandpowers output file. More details on the bandpower window functions can be found in Section 2.5 of the <a class="reference external" href="https://arxiv.org/abs/2104.01172">XFaster paper</a>.</p>
</div>
<div class="section" id="Looking-at-results">
<h4>Looking at results<a class="headerlink" href="#Looking-at-results" title="Permalink to this headline">¶</a></h4>
<p>Now we’ll just run the function that wraps up all these internal functions, <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_bandpowers"><span class="std std-ref">get_bandpowers()</span></a>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">bp</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_bandpowers</span><span class="p">(</span><span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">save_iters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="o">=</span><span class="mf">5e3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>In the plot below, we’ll plot up the maximum fractional change in <span class="math notranslate nohighlight">\(q_b\)</span> with iteration. This information is printed in the logs, but it’s helpful to visualize on a plot. You can see it bounce around early on before settling down and ultimately stopping once it gets to the desginated criterion.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">glob</span>
<span class="n">iters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;../../example/outputs_example/95x150/bandpowers_iter*&#39;</span><span class="p">))</span>
<span class="c1">### Figure for seeing how convergence looks in fqb</span>
<span class="n">fig_fqb</span><span class="p">,</span> <span class="n">ax_fqb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;convergence criterion&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">)</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Max fractional change in qb vs iter&#39;</span><span class="p">)</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Maximum absolute fqb&#39;</span><span class="p">)</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Iteration&#39;</span><span class="p">)</span>
<span class="n">fqb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iters</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bp0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">xf</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">bp0</span><span class="p">)</span>
    <span class="n">fqb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;fqb&#39;</span><span class="p">]))</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fqb</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax_fqb</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_94_0.png" src="../_images/notebooks_XFaster_Tutorial_94_0.png" />
</div>
</div>
<p>Now let’s see how the total model (summing up the <span class="math notranslate nohighlight">\(q_b\mathcal{C}_{b\ell}\)</span> terms for every component) to see how it converges to fit the data. Within a few iterations, it’s quite close.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1">### Figure for looking at how sum(qbCbl) changes with iteration to match data</span>
<span class="n">figtmp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">tmpplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">),</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">iters</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">figtmp</span><span class="p">)</span>
<span class="n">fig_dat</span><span class="p">,</span> <span class="n">ax_dat</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax_dat</span> <span class="o">=</span> <span class="n">ax_dat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tt&#39;</span><span class="p">,</span> <span class="s1">&#39;ee&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">,</span> <span class="s1">&#39;te&#39;</span><span class="p">,</span> <span class="s1">&#39;tb&#39;</span><span class="p">,</span> <span class="s1">&#39;eb&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">iters</span><span class="p">))</span><span class="o">.</span><span class="n">colors</span>
<span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bp0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">xf</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">bp0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># data cls don&#39;t change with iter- plot once.</span>
            <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;cls_obs&#39;</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">lfac</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
        <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;cls_model&#39;</span><span class="p">][</span><span class="s1">&#39;total_&#39;</span><span class="o">+</span><span class="n">spec</span><span class="p">][</span><span class="s1">&#39;150:95&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">lfac</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$D_\ell$&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
<span class="n">ax_dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">fig_dat</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">tmpplot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Iteration&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax_dat</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                 <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">fig_dat</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;95$\times$150 GHz total power fit&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0.98, &#39;95$\\times$150 GHz total power fit&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_96_1.png" src="../_images/notebooks_XFaster_Tutorial_96_1.png" />
</div>
</div>
<p>Now let’s look at just the <span class="math notranslate nohighlight">\(q_b\)</span> values for each of the different component and see how they converge as a function of iteration and bin. The lowest bins tend to have the biggest moves, but for all components, everything gets close to its final value within a handful of iterations.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1">### Figure for looking at how qb for each bandpower changes with iteration</span>
<span class="n">figtmp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">tmpplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">),</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">iters</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">figtmp</span><span class="p">)</span>
<span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tt&#39;</span><span class="p">,</span> <span class="s1">&#39;ee&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">,</span> <span class="s1">&#39;te&#39;</span><span class="p">,</span> <span class="s1">&#39;tb&#39;</span><span class="p">,</span> <span class="s1">&#39;eb&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">iters</span><span class="p">))</span><span class="o">.</span><span class="n">colors</span>
<span class="n">scatter</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">50.</span>
<span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cmb&#39;</span><span class="p">]:</span>
    <span class="n">fig_dat</span><span class="p">,</span> <span class="n">ax_dat</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
    <span class="n">fig_dat</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">comp</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39; $q_b$ vs. iteration&#39;</span><span class="p">)</span>
    <span class="n">ax_dat</span> <span class="o">=</span> <span class="n">ax_dat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
        <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bp0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">xf</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">bp0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
            <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="o">+</span> <span class="n">scatter</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span>
                              <span class="n">b</span><span class="p">[</span><span class="s1">&#39;qb&#39;</span><span class="p">][</span><span class="n">comp</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">spec</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="n">ax_dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$q_b$&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">ax_dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;bin&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">fig_dat</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">tmpplot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Iteration&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax_dat</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                     <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_98_0.png" src="../_images/notebooks_XFaster_Tutorial_98_0.png" />
</div>
</div>
<p>Now we’ll look at the noise residuals that were fit. In the script where we make the example maps, we made the “data” maps have 15% less noise in them than the those used for the noise model. So, we should expect the total noise, <span class="math notranslate nohighlight">\((1+n_b)\left&lt;N\right&gt;\)</span>, to be <span class="math notranslate nohighlight">\(0.85^2\left&lt;N\right&gt;\)</span>, where the square comes because we’re fitting in the power spectrum. So, <span class="math notranslate nohighlight">\(n_b\)</span>s should converge to about -0.28.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Now plot residuals</span>
<span class="n">fig_dat</span><span class="p">,</span> <span class="n">ax_dat</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">fig_dat</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;res $q_b$ vs. iteration&#39;</span><span class="p">)</span>
<span class="n">ax_dat</span> <span class="o">=</span> <span class="n">ax_dat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;qb&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;res&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
<span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">m0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maps</span><span class="p">):</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bp0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">xf</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">bp0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">m0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maps</span><span class="p">):</span>
        <span class="n">ax_dat</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">scatter</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span>
                          <span class="n">b</span><span class="p">[</span><span class="s1">&#39;qb&#39;</span><span class="p">][</span><span class="n">m0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$q_b$&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">ax_dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;bin&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">fig_dat</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">tmpplot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Iteration&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax_dat</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                 <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.colorbar.Colorbar at 0x7f1a10bb9730&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_100_1.png" src="../_images/notebooks_XFaster_Tutorial_100_1.png" />
</div>
</div>
<p>Now that everything has converged, let’s plot up what the final bandpowers and error bars look like. XFaster saves the binned bandpowers as <span class="math notranslate nohighlight">\(D_\ell\)</span>s by default, though they are labeled <code class="docutils literal notranslate"><span class="pre">cb</span></code>. The error bars are in <code class="docutils literal notranslate"><span class="pre">dcb</span></code>, and those are also computed without sample variance in <code class="docutils literal notranslate"><span class="pre">dcb_nosampvar</span></code>. Covariance is in <code class="docutils literal notranslate"><span class="pre">cov</span></code>, and it also has a no sample variance version, <code class="docutils literal notranslate"><span class="pre">cov_nosampvar</span></code>.</p>
<p>To calculate error bars and covariances without sample variance, XFaster just does one final calculation of the Fisher matrix (after everything has converged), with all the <span class="math notranslate nohighlight">\(q_b\)</span>s set to a very small number, thereby nulling out the signal. The error bars and covariance without sample variance come from that Fisher matrix.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cmb&#39;</span><span class="p">]:</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> final estimated bandpowers&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">):</span>
        <span class="n">sn</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lfac</span> <span class="o">*</span> <span class="n">signal_shape</span><span class="p">[</span><span class="n">sn</span><span class="p">][:</span><span class="mi">501</span><span class="p">],</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Model&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;ellb&#39;</span><span class="p">][</span><span class="n">sn</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;cb&#39;</span><span class="p">][</span><span class="n">sn</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;dcb&#39;</span><span class="p">][</span><span class="n">sn</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;sampvar&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;ellb&#39;</span><span class="p">][</span><span class="n">sn</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;cb&#39;</span><span class="p">][</span><span class="n">sn</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="s1">&#39;dcb_nosampvar&#39;</span><span class="p">][</span><span class="n">sn</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;no sampvar&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$D_\ell$&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]:</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\ell$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_102_0.png" src="../_images/notebooks_XFaster_Tutorial_102_0.png" />
</div>
</div>
<p>The error bars are just the diagonal of the covariance matrix. Let’s look at the covariance matrix with and without sample variance.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">LogNorm</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">LogNorm</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1e4</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Covariance&#39;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;cov&#39;</span><span class="p">]),</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;With sample variance&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;cov_nosampvar&#39;</span><span class="p">]),</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
<span class="n">fig_dat</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Covariance&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                 <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Without sample variance&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 1.0, &#39;Without sample variance&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_104_1.png" src="../_images/notebooks_XFaster_Tutorial_104_1.png" />
</div>
</div>
<p>This is a 120 x 120 bin matrix, with each of the 20 CMB bins for each spectrum in order (TT, EE, BB, TE, EB, TB).</p>
</div>
</div>
<div class="section" id="get_likelihood">
<h3>get_likelihood<a class="headerlink" href="#get_likelihood" title="Permalink to this headline">¶</a></h3>
<p>Now we can compute parameter likelihoods with <a class="reference internal" href="../api.html#xfaster.xfaster_class.XFaster.get_likelihood"><span class="std std-ref">get_likelihood()</span></a>. All of the things we’ve constructed so far are used, except instead of parameterizing the model with <span class="math notranslate nohighlight">\(q_b\)</span> bandpower deviations, we set those to 1, and then make the model a function of cosmological parameters. For the example, we will just use <span class="math notranslate nohighlight">\(r\)</span> as our parameter. We then compute the likelihood for the data for each step in a Monte Carlo sampler, where we
just vary <span class="math notranslate nohighlight">\(r\)</span>. For this example, since we’re only varying one paramter, we’ll do a brute force search:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">loglike</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">get_likelihood</span><span class="p">(</span><span class="n">qb</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;qb&#39;</span><span class="p">],</span> <span class="n">inv_fish</span><span class="o">=</span><span class="n">bp</span><span class="p">[</span><span class="s1">&#39;inv_fish&#39;</span><span class="p">],</span> <span class="n">mcmc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
[ 2021-08-23 20:06:53UTC ] INFO: Computing brute-force r profile likelihood
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loglike</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">loglike</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">loglike</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$r$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 0, &#39;$r$&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_XFaster_Tutorial_109_1.png" src="../_images/notebooks_XFaster_Tutorial_109_1.png" />
</div>
</div>
<p>We can see that we recover something pretty close to 1, our input <span class="math notranslate nohighlight">\(r\)</span> value for the example. If we ran this for many signal+noise sims, we should get precisely 1 in the average.</p>
<p>If you instead are using mcmc=True, the likelihoods file written to disk will have a field called “samples”. Histogramming that up, or using a program like <code class="docutils literal notranslate"><span class="pre">getdist</span></code>, especially helpful for multiple parameters, will give you the posteriors for your various parameters.</p>
<p>The likelihoods function sets the CMB qb values to 1 and all others (esp., residuals) to their maximum likelihood values. To instead include these parameters in your fit, you set the <code class="docutils literal notranslate"><span class="pre">prior</span></code> arguments. So:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r_prior</span></code>: set to [0, ‘inf’] to inclue <span class="math notranslate nohighlight">\(r\)</span> in the fit (or [‘-inf’, ‘inf’] to impose no physical prior)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha_prior</span></code>: same as <code class="docutils literal notranslate"><span class="pre">r_prior</span></code>– set to None to not fit for alpha template scalings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">res_prior</span></code>: same as previous– will vary all <span class="math notranslate nohighlight">\(n_b\)</span> parameters as part of the model</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beam_prior</span></code>: this is different! To account for beam uncertainty, set this to [0, 1], where the first parameter is the Gaussian mean, and the second is the number of standard deviations to use as the width. Here, you must have set the <code class="docutils literal notranslate"><span class="pre">beam_error_product</span></code> in your config file to a dictionary containing the one-sigma error on the beam shape per ell, and then that envelope is varied according to a Gaussian with each step to marginalize over the beam uncertainty.</p></li>
</ul>
<p>That wraps up the example!</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../api.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../algorithm.html" class="btn btn-neutral float-left" title="Algorithm" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, A. Gambrel, A. Rahlin, C. Contaldi.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>